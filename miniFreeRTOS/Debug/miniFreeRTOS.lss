
miniFreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000024  00800100  00001d7e  00001e12  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001d7e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000a8  00800124  00800124  00001e36  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001e36  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001e68  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000528  00000000  00000000  00001ea8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000076bc  00000000  00000000  000023d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000017cc  00000000  00000000  00009a8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003e04  00000000  00000000  0000b258  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000117c  00000000  00000000  0000f05c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001f68  00000000  00000000  000101d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000733d  00000000  00000000  00012140  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000860  00000000  00000000  0001947d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 88 03 	jmp	0x710	; 0x710 <__vector_6>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 8e 01 	jmp	0x31c	; 0x31c <__vector_18>
      4c:	0c 94 e9 01 	jmp	0x3d2	; 0x3d2 <__vector_19>
      50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	2a 0d       	add	r18, r10
      6a:	2a 0d       	add	r18, r10
      6c:	2a 0d       	add	r18, r10
      6e:	65 0d       	add	r22, r5
      70:	53 0d       	add	r21, r3
      72:	62 0d       	add	r22, r2
      74:	2a 0d       	add	r18, r10
      76:	2a 0d       	add	r18, r10
      78:	65 0d       	add	r22, r5
      7a:	53 0d       	add	r21, r3

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d8 e0       	ldi	r29, 0x08	; 8
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	11 e0       	ldi	r17, 0x01	; 1
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	ee e7       	ldi	r30, 0x7E	; 126
      90:	fd e1       	ldi	r31, 0x1D	; 29
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	a4 32       	cpi	r26, 0x24	; 36
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	21 e0       	ldi	r18, 0x01	; 1
      a0:	a4 e2       	ldi	r26, 0x24	; 36
      a2:	b1 e0       	ldi	r27, 0x01	; 1
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	ac 3c       	cpi	r26, 0xCC	; 204
      aa:	b2 07       	cpc	r27, r18
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 72 01 	call	0x2e4	; 0x2e4 <main>
      b2:	0c 94 bd 0e 	jmp	0x1d7a	; 0x1d7a <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      ba:	cf 93       	push	r28
      bc:	df 93       	push	r29
      be:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
      c0:	0e 94 56 08 	call	0x10ac	; 0x10ac <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
      c4:	ce 01       	movw	r24, r28
      c6:	0e 94 8c 0d 	call	0x1b18	; 0x1b18 <malloc>
      ca:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
      cc:	0e 94 21 09 	call	0x1242	; 0x1242 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
      d0:	20 97       	sbiw	r28, 0x00	; 0
      d2:	11 f4       	brne	.+4      	; 0xd8 <pvPortMalloc+0x1e>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
      d4:	0e 94 9b 00 	call	0x136	; 0x136 <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
}
      d8:	ce 01       	movw	r24, r28
      da:	df 91       	pop	r29
      dc:	cf 91       	pop	r28
      de:	08 95       	ret

000000e0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
      e0:	cf 93       	push	r28
      e2:	df 93       	push	r29
	if( pv )
      e4:	00 97       	sbiw	r24, 0x00	; 0
      e6:	41 f0       	breq	.+16     	; 0xf8 <vPortFree+0x18>
      e8:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
      ea:	0e 94 56 08 	call	0x10ac	; 0x10ac <vTaskSuspendAll>
		{
			free( pv );
      ee:	ce 01       	movw	r24, r28
      f0:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
      f4:	0e 94 21 09 	call	0x1242	; 0x1242 <xTaskResumeAll>
	}
}
      f8:	df 91       	pop	r29
      fa:	cf 91       	pop	r28
      fc:	08 95       	ret

000000fe <vApplicationIdleHook>:

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // with 1284p
	DIDR0 = 0xFF;

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino with 328p
	DIDR0 = 0x3F;
      fe:	8f e3       	ldi	r24, 0x3F	; 63
     100:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
	// When the ACD bit is written logic one, the power to the Analogue Comparator is switched off.
	// This bit can be set at any time to turn off the Analogue Comparator.
	// This will reduce power consumption in Active and Idle mode.
	// When changing the ACD bit, the Analogue Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR.
	// Otherwise an interrupt can occur when the ACD bit is changed.
	ACSR &= ~_BV(ACIE);
     104:	80 b7       	in	r24, 0x30	; 48
     106:	87 7f       	andi	r24, 0xF7	; 247
     108:	80 bf       	out	0x30, r24	; 48
	ACSR |=  _BV(ACD);
     10a:	80 b7       	in	r24, 0x30	; 48
     10c:	80 68       	ori	r24, 0x80	; 128
     10e:	80 bf       	out	0x30, r24	; 48
	// SLEEP_MODE_PWR_DOWN     _BV(SM1)
	// SLEEP_MODE_PWR_SAVE     (_BV(SM0) | _BV(SM1))
	// SLEEP_MODE_STANDBY      (_BV(SM1) | _BV(SM2))
	// SLEEP_MODE_EXT_STANDBY  (_BV(SM0) | _BV(SM1) | _BV(SM2))

	set_sleep_mode( SLEEP_MODE_IDLE );
     110:	83 b7       	in	r24, 0x33	; 51
     112:	81 7f       	andi	r24, 0xF1	; 241
     114:	83 bf       	out	0x33, r24	; 51

	portENTER_CRITICAL();
     116:	0f b6       	in	r0, 0x3f	; 63
     118:	f8 94       	cli
     11a:	0f 92       	push	r0
	sleep_enable();
     11c:	83 b7       	in	r24, 0x33	; 51
     11e:	81 60       	ori	r24, 0x01	; 1
     120:	83 bf       	out	0x33, r24	; 51

#if defined(BODS) && defined(BODSE) // only if there is support to disable the BOD.
	sleep_bod_disable();
     122:	85 b7       	in	r24, 0x35	; 53
     124:	80 66       	ori	r24, 0x60	; 96
     126:	85 bf       	out	0x35, r24	; 53
     128:	8f 7d       	andi	r24, 0xDF	; 223
     12a:	85 bf       	out	0x35, r24	; 53
#endif

	portEXIT_CRITICAL();
     12c:	0f 90       	pop	r0
     12e:	0f be       	out	0x3f, r0	; 63
	sleep_cpu();		// good night.
     130:	88 95       	sleep

	sleep_reset();		// reset the sleep_mode() faster than sleep_disable();
     132:	13 be       	out	0x33, r1	; 51
     134:	08 95       	ret

00000136 <vApplicationMallocFailedHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Goldilocks with 1284p
	DDRB  |= _BV(DDB7);
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
	DDRB  |= _BV(DDB5);
     136:	25 9a       	sbi	0x04, 5	; 4
	PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
     138:	2d 9a       	sbi	0x05, 5	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     13a:	2f e7       	ldi	r18, 0x7F	; 127
     13c:	88 e3       	ldi	r24, 0x38	; 56
     13e:	91 e0       	ldi	r25, 0x01	; 1
     140:	21 50       	subi	r18, 0x01	; 1
     142:	80 40       	sbci	r24, 0x00	; 0
     144:	90 40       	sbci	r25, 0x00	; 0
     146:	e1 f7       	brne	.-8      	; 0x140 <vApplicationMallocFailedHook+0xa>
     148:	00 c0       	rjmp	.+0      	; 0x14a <vApplicationMallocFailedHook+0x14>
     14a:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Goldilocks with 1284p
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
		PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED fast blink.
     14c:	1d 9a       	sbi	0x03, 5	; 3
     14e:	f5 cf       	rjmp	.-22     	; 0x13a <vApplicationMallocFailedHook+0x4>

00000150 <vApplicationStackOverflowHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Goldilocks with 1284p
	DDRB  |= _BV(DDB7);
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
	DDRB  |= _BV(DDB5);
     150:	25 9a       	sbi	0x04, 5	; 4
	PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
     152:	2d 9a       	sbi	0x05, 5	; 5
     154:	2f ef       	ldi	r18, 0xFF	; 255
     156:	83 ed       	ldi	r24, 0xD3	; 211
     158:	90 e3       	ldi	r25, 0x30	; 48
     15a:	21 50       	subi	r18, 0x01	; 1
     15c:	80 40       	sbci	r24, 0x00	; 0
     15e:	90 40       	sbci	r25, 0x00	; 0
     160:	e1 f7       	brne	.-8      	; 0x15a <vApplicationStackOverflowHook+0xa>
     162:	00 c0       	rjmp	.+0      	; 0x164 <vApplicationStackOverflowHook+0x14>
     164:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Goldilocks with 1284p
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
		PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED slow blink.
     166:	1d 9a       	sbi	0x03, 5	; 3
     168:	f5 cf       	rjmp	.-22     	; 0x154 <vApplicationStackOverflowHook+0x4>

0000016a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     16a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );
     16c:	03 96       	adiw	r24, 0x03	; 3
     16e:	92 83       	std	Z+2, r25	; 0x02
     170:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     172:	2f ef       	ldi	r18, 0xFF	; 255
     174:	3f ef       	ldi	r19, 0xFF	; 255
     176:	34 83       	std	Z+4, r19	; 0x04
     178:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );
     17a:	96 83       	std	Z+6, r25	; 0x06
     17c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );
     17e:	90 87       	std	Z+8, r25	; 0x08
     180:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     182:	10 82       	st	Z, r1
     184:	08 95       	ret

00000186 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     186:	fc 01       	movw	r30, r24
     188:	11 86       	std	Z+9, r1	; 0x09
     18a:	10 86       	std	Z+8, r1	; 0x08
     18c:	08 95       	ret

0000018e <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     18e:	cf 93       	push	r28
     190:	df 93       	push	r29
     192:	9c 01       	movw	r18, r24
     194:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     196:	dc 01       	movw	r26, r24
     198:	11 96       	adiw	r26, 0x01	; 1
     19a:	cd 91       	ld	r28, X+
     19c:	dc 91       	ld	r29, X
     19e:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     1a0:	d3 83       	std	Z+3, r29	; 0x03
     1a2:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     1a4:	8c 81       	ldd	r24, Y+4	; 0x04
     1a6:	9d 81       	ldd	r25, Y+5	; 0x05
     1a8:	95 83       	std	Z+5, r25	; 0x05
     1aa:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     1ac:	8c 81       	ldd	r24, Y+4	; 0x04
     1ae:	9d 81       	ldd	r25, Y+5	; 0x05
     1b0:	dc 01       	movw	r26, r24
     1b2:	13 96       	adiw	r26, 0x03	; 3
     1b4:	7c 93       	st	X, r23
     1b6:	6e 93       	st	-X, r22
     1b8:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     1ba:	7d 83       	std	Y+5, r23	; 0x05
     1bc:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     1be:	31 87       	std	Z+9, r19	; 0x09
     1c0:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     1c2:	f9 01       	movw	r30, r18
     1c4:	80 81       	ld	r24, Z
     1c6:	8f 5f       	subi	r24, 0xFF	; 255
     1c8:	80 83       	st	Z, r24
}
     1ca:	df 91       	pop	r29
     1cc:	cf 91       	pop	r28
     1ce:	08 95       	ret

000001d0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     1d0:	cf 93       	push	r28
     1d2:	df 93       	push	r29
     1d4:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     1d6:	48 81       	ld	r20, Y
     1d8:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     1da:	4f 3f       	cpi	r20, 0xFF	; 255
     1dc:	2f ef       	ldi	r18, 0xFF	; 255
     1de:	52 07       	cpc	r21, r18
     1e0:	21 f4       	brne	.+8      	; 0x1ea <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     1e2:	fc 01       	movw	r30, r24
     1e4:	a7 81       	ldd	r26, Z+7	; 0x07
     1e6:	b0 85       	ldd	r27, Z+8	; 0x08
     1e8:	0d c0       	rjmp	.+26     	; 0x204 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     1ea:	dc 01       	movw	r26, r24
     1ec:	13 96       	adiw	r26, 0x03	; 3
     1ee:	01 c0       	rjmp	.+2      	; 0x1f2 <vListInsert+0x22>
     1f0:	df 01       	movw	r26, r30
     1f2:	12 96       	adiw	r26, 0x02	; 2
     1f4:	ed 91       	ld	r30, X+
     1f6:	fc 91       	ld	r31, X
     1f8:	13 97       	sbiw	r26, 0x03	; 3
     1fa:	20 81       	ld	r18, Z
     1fc:	31 81       	ldd	r19, Z+1	; 0x01
     1fe:	42 17       	cp	r20, r18
     200:	53 07       	cpc	r21, r19
     202:	b0 f7       	brcc	.-20     	; 0x1f0 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     204:	12 96       	adiw	r26, 0x02	; 2
     206:	ed 91       	ld	r30, X+
     208:	fc 91       	ld	r31, X
     20a:	13 97       	sbiw	r26, 0x03	; 3
     20c:	fb 83       	std	Y+3, r31	; 0x03
     20e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     210:	d5 83       	std	Z+5, r29	; 0x05
     212:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     214:	bd 83       	std	Y+5, r27	; 0x05
     216:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     218:	13 96       	adiw	r26, 0x03	; 3
     21a:	dc 93       	st	X, r29
     21c:	ce 93       	st	-X, r28
     21e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     220:	99 87       	std	Y+9, r25	; 0x09
     222:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     224:	fc 01       	movw	r30, r24
     226:	20 81       	ld	r18, Z
     228:	2f 5f       	subi	r18, 0xFF	; 255
     22a:	20 83       	st	Z, r18
}
     22c:	df 91       	pop	r29
     22e:	cf 91       	pop	r28
     230:	08 95       	ret

00000232 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     232:	cf 93       	push	r28
     234:	df 93       	push	r29
     236:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     238:	a0 85       	ldd	r26, Z+8	; 0x08
     23a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     23c:	c2 81       	ldd	r28, Z+2	; 0x02
     23e:	d3 81       	ldd	r29, Z+3	; 0x03
     240:	84 81       	ldd	r24, Z+4	; 0x04
     242:	95 81       	ldd	r25, Z+5	; 0x05
     244:	9d 83       	std	Y+5, r25	; 0x05
     246:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     248:	c4 81       	ldd	r28, Z+4	; 0x04
     24a:	d5 81       	ldd	r29, Z+5	; 0x05
     24c:	82 81       	ldd	r24, Z+2	; 0x02
     24e:	93 81       	ldd	r25, Z+3	; 0x03
     250:	9b 83       	std	Y+3, r25	; 0x03
     252:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     254:	11 96       	adiw	r26, 0x01	; 1
     256:	8d 91       	ld	r24, X+
     258:	9c 91       	ld	r25, X
     25a:	12 97       	sbiw	r26, 0x02	; 2
     25c:	e8 17       	cp	r30, r24
     25e:	f9 07       	cpc	r31, r25
     260:	31 f4       	brne	.+12     	; 0x26e <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     262:	84 81       	ldd	r24, Z+4	; 0x04
     264:	95 81       	ldd	r25, Z+5	; 0x05
     266:	12 96       	adiw	r26, 0x02	; 2
     268:	9c 93       	st	X, r25
     26a:	8e 93       	st	-X, r24
     26c:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     26e:	11 86       	std	Z+9, r1	; 0x09
     270:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     272:	8c 91       	ld	r24, X
     274:	81 50       	subi	r24, 0x01	; 1
     276:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     278:	8c 91       	ld	r24, X
}
     27a:	df 91       	pop	r29
     27c:	cf 91       	pop	r28
     27e:	08 95       	ret

00000280 <TaskBlinkGreenLED>:

}

/*-----------------------------------------------------------*/
static void TaskBlinkGreenLED(void *pvParameters) // Main Green LED Flash
{
     280:	cf 93       	push	r28
     282:	df 93       	push	r29
     284:	00 d0       	rcall	.+0      	; 0x286 <TaskBlinkGreenLED+0x6>
     286:	cd b7       	in	r28, 0x3d	; 61
     288:	de b7       	in	r29, 0x3e	; 62
    TickType_t xLastWakeTime;
	/* The xLastWakeTime variable needs to be initialised with the current tick
	count.  Note that this is the only time we access this variable.  From this
	point on xLastWakeTime is managed automatically by the vTaskDelayUntil()
	API function. */
	xLastWakeTime = xTaskGetTickCount();
     28a:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <xTaskGetTickCount>
     28e:	9a 83       	std	Y+2, r25	; 0x02
     290:	89 83       	std	Y+1, r24	; 0x01

	//DDRB |= _BV(DDB5);
	DDRB |= _BV(DDB1);
     292:	21 9a       	sbi	0x04, 1	; 4

    for(;;)
    {
    	//PORTB |=  _BV(PORTB5);       // main (red PB5) LED on. Arduino LED on
		PORTB |=  _BV(PORTB1);
     294:	29 9a       	sbi	0x05, 1	; 5
		
		vTaskDelayUntil( &xLastWakeTime, ( 500 / portTICK_PERIOD_MS ) );
     296:	6f e1       	ldi	r22, 0x1F	; 31
     298:	70 e0       	ldi	r23, 0x00	; 0
     29a:	ce 01       	movw	r24, r28
     29c:	01 96       	adiw	r24, 0x01	; 1
     29e:	0e 94 a0 09 	call	0x1340	; 0x1340 <vTaskDelayUntil>

		//PORTB &= ~_BV(PORTB5);       // main (red PB5) LED off. Arduino LED off
		PORTB &= ~_BV(PORTB1);
     2a2:	29 98       	cbi	0x05, 1	; 5

		vTaskDelayUntil( &xLastWakeTime, ( 500 / portTICK_PERIOD_MS )  );
     2a4:	6f e1       	ldi	r22, 0x1F	; 31
     2a6:	70 e0       	ldi	r23, 0x00	; 0
     2a8:	ce 01       	movw	r24, r28
     2aa:	01 96       	adiw	r24, 0x01	; 1
     2ac:	0e 94 a0 09 	call	0x1340	; 0x1340 <vTaskDelayUntil>
     2b0:	f1 cf       	rjmp	.-30     	; 0x294 <TaskBlinkGreenLED+0x14>

000002b2 <TaskBlinkRedLED>:

/*-----------------------------------------------------------*/


static void TaskBlinkRedLED(void *pvParameters) // Main Red LED Flash
{
     2b2:	cf 93       	push	r28
     2b4:	df 93       	push	r29
     2b6:	00 d0       	rcall	.+0      	; 0x2b8 <TaskBlinkRedLED+0x6>
     2b8:	cd b7       	in	r28, 0x3d	; 61
     2ba:	de b7       	in	r29, 0x3e	; 62
    TickType_t xLastWakeTime;
	/* The xLastWakeTime variable needs to be initialised with the current tick
	count.  Note that this is the only time we access this variable.  From this
	point on xLastWakeTime is managed automatically by the vTaskDelayUntil()
	API function. */
	xLastWakeTime = xTaskGetTickCount();
     2bc:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <xTaskGetTickCount>
     2c0:	9a 83       	std	Y+2, r25	; 0x02
     2c2:	89 83       	std	Y+1, r24	; 0x01
	lcd_Init();
#endif
*/

	//DDRB |= _BV(DDB7);
	DDRD |= _BV(DDD7);
     2c4:	57 9a       	sbi	0x0a, 7	; 10

    for(;;)
    {

    	//PORTB |=  _BV(PORTB7);       // main (red IO_B7) LED on. EtherMega LED on
		PORTD |=  _BV(PORTD7);
     2c6:	5f 9a       	sbi	0x0b, 7	; 11
		
		vTaskDelayUntil( &xLastWakeTime, ( 500 / portTICK_PERIOD_MS ) );
     2c8:	6f e1       	ldi	r22, 0x1F	; 31
     2ca:	70 e0       	ldi	r23, 0x00	; 0
     2cc:	ce 01       	movw	r24, r28
     2ce:	01 96       	adiw	r24, 0x01	; 1
     2d0:	0e 94 a0 09 	call	0x1340	; 0x1340 <vTaskDelayUntil>

#endif
*/

		//PORTB &= ~_BV(PORTB7);       // main (red IO_B7) LED off. EtherMega LED off
		PORTD &= ~_BV(PORTD7);
     2d4:	5f 98       	cbi	0x0b, 7	; 11

		vTaskDelayUntil( &xLastWakeTime, ( 500 / portTICK_PERIOD_MS ) );
     2d6:	6f e1       	ldi	r22, 0x1F	; 31
     2d8:	70 e0       	ldi	r23, 0x00	; 0
     2da:	ce 01       	movw	r24, r28
     2dc:	01 96       	adiw	r24, 0x01	; 1
     2de:	0e 94 a0 09 	call	0x1340	; 0x1340 <vTaskDelayUntil>
     2e2:	f1 cf       	rjmp	.-30     	; 0x2c6 <TaskBlinkRedLED+0x14>

000002e4 <main>:
    // turn on the serial port for debugging or for other USART reasons.
//	xSerialPort = xSerialPortInitMinimal( USART0, 115200, portSERIAL_BUFFER_TX, portSERIAL_BUFFER_RX); //  serial port: WantedBaud, TxQueueLength, RxQueueLength (8n1)

//	avrSerialxPrint_P(&xSerialPort, PSTR("\r\n\n\nHello World!\r\n")); // Ok, so we're alive...

    xTaskCreate(
     2e4:	e1 2c       	mov	r14, r1
     2e6:	f1 2c       	mov	r15, r1
     2e8:	03 e0       	ldi	r16, 0x03	; 3
     2ea:	20 e0       	ldi	r18, 0x00	; 0
     2ec:	30 e0       	ldi	r19, 0x00	; 0
     2ee:	40 e0       	ldi	r20, 0x00	; 0
     2f0:	51 e0       	ldi	r21, 0x01	; 1
     2f2:	66 e0       	ldi	r22, 0x06	; 6
     2f4:	71 e0       	ldi	r23, 0x01	; 1
     2f6:	89 e5       	ldi	r24, 0x59	; 89
     2f8:	91 e0       	ldi	r25, 0x01	; 1
     2fa:	0e 94 11 07 	call	0xe22	; 0xe22 <xTaskCreate>
		,  256				// Tested 9 free @ 208
		,  NULL
		,  3
		,  NULL ); // */

    xTaskCreate(
     2fe:	20 e0       	ldi	r18, 0x00	; 0
     300:	30 e0       	ldi	r19, 0x00	; 0
     302:	40 e0       	ldi	r20, 0x00	; 0
     304:	51 e0       	ldi	r21, 0x01	; 1
     306:	6d e0       	ldi	r22, 0x0D	; 13
     308:	71 e0       	ldi	r23, 0x01	; 1
     30a:	80 e4       	ldi	r24, 0x40	; 64
     30c:	91 e0       	ldi	r25, 0x01	; 1
     30e:	0e 94 11 07 	call	0xe22	; 0xe22 <xTaskCreate>
		,  NULL ); // */


//	avrSerialxPrintf_P(&xSerialPort, PSTR("Free Heap Size: %u\r\n"), xPortGetFreeHeapSize() ); // needs heap_1,  heap_2 or heap_4 for this function to succeed.
//	avrSerialxPrintf_P(&xSerialPort, PSTR("Minimum Free Heap Size: %u\r\n"), xPortGetMinimumEverFreeHeapSize() ); // needs heap_4 for this function to succeed.
	vTaskStartScheduler();
     312:	0e 94 28 08 	call	0x1050	; 0x1050 <vTaskStartScheduler>

//	avrSerialxPrint_P(&xSerialPort, PSTR("\r\n\n\nGoodbye... no space for idle task!\r\n")); // Doh, so we're dead...

}
     316:	80 e0       	ldi	r24, 0x00	; 0
     318:	90 e0       	ldi	r25, 0x00	; 0
     31a:	08 95       	ret

0000031c <__vector_18>:
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART0_RX_vect )

#endif
{
     31c:	1f 92       	push	r1
     31e:	0f 92       	push	r0
     320:	0f b6       	in	r0, 0x3f	; 63
     322:	0f 92       	push	r0
     324:	11 24       	eor	r1, r1
     326:	2f 93       	push	r18
     328:	3f 93       	push	r19
     32a:	4f 93       	push	r20
     32c:	8f 93       	push	r24
     32e:	9f 93       	push	r25
     330:	af 93       	push	r26
     332:	bf 93       	push	r27
     334:	ef 93       	push	r30
     336:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR0A & (_BV(FE0)|_BV(DOR0)|_BV(UPE0)) ) )
     338:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     33c:	8c 71       	andi	r24, 0x1C	; 28
     33e:	71 f0       	breq	.+28     	; 0x35c <__vector_18+0x40>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR0A & (1<<RXC0) ) erroredByte = UDR0;
     340:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     344:	88 23       	and	r24, r24
     346:	0c f0       	brlt	.+2      	; 0x34a <__vector_18+0x2e>
     348:	36 c0       	rjmp	.+108    	; 0x3b6 <__vector_18+0x9a>
     34a:	a6 ec       	ldi	r26, 0xC6	; 198
     34c:	b0 e0       	ldi	r27, 0x00	; 0
     34e:	e0 ec       	ldi	r30, 0xC0	; 192
     350:	f0 e0       	ldi	r31, 0x00	; 0
     352:	8c 91       	ld	r24, X
     354:	80 81       	ld	r24, Z
     356:	88 23       	and	r24, r24
     358:	e4 f3       	brlt	.-8      	; 0x352 <__vector_18+0x36>
     35a:	2d c0       	rjmp	.+90     	; 0x3b6 <__vector_18+0x9a>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR0;
     35c:	40 91 c6 00 	lds	r20, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
     360:	0f b6       	in	r0, 0x3f	; 63
     362:	f8 94       	cli
     364:	0f 92       	push	r0
	{
	    count = buffer->count;
     366:	e6 ea       	ldi	r30, 0xA6	; 166
     368:	f1 e0       	ldi	r31, 0x01	; 1
     36a:	21 81       	ldd	r18, Z+1	; 0x01
     36c:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
     36e:	0f 90       	pop	r0
     370:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerialPort.xRxedChars) ) )
     372:	83 85       	ldd	r24, Z+11	; 0x0b
     374:	94 85       	ldd	r25, Z+12	; 0x0c
     376:	28 17       	cp	r18, r24
     378:	39 07       	cpc	r19, r25
     37a:	e9 f0       	breq	.+58     	; 0x3b6 <__vector_18+0x9a>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
     37c:	e7 ea       	ldi	r30, 0xA7	; 167
     37e:	f1 e0       	ldi	r31, 0x01	; 1

	*buffer->in = data;
     380:	a2 81       	ldd	r26, Z+2	; 0x02
     382:	b3 81       	ldd	r27, Z+3	; 0x03
     384:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
     386:	82 81       	ldd	r24, Z+2	; 0x02
     388:	93 81       	ldd	r25, Z+3	; 0x03
     38a:	01 96       	adiw	r24, 0x01	; 1
     38c:	93 83       	std	Z+3, r25	; 0x03
     38e:	82 83       	std	Z+2, r24	; 0x02
     390:	20 85       	ldd	r18, Z+8	; 0x08
     392:	31 85       	ldd	r19, Z+9	; 0x09
     394:	82 17       	cp	r24, r18
     396:	93 07       	cpc	r25, r19
     398:	21 f4       	brne	.+8      	; 0x3a2 <__vector_18+0x86>
	  buffer->in = buffer->start;
     39a:	86 81       	ldd	r24, Z+6	; 0x06
     39c:	97 81       	ldd	r25, Z+7	; 0x07
     39e:	93 83       	std	Z+3, r25	; 0x03
     3a0:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
     3a2:	0f b6       	in	r0, 0x3f	; 63
     3a4:	f8 94       	cli
     3a6:	0f 92       	push	r0
	{
	    buffer->count++;
     3a8:	80 81       	ld	r24, Z
     3aa:	91 81       	ldd	r25, Z+1	; 0x01
     3ac:	01 96       	adiw	r24, 0x01	; 1
     3ae:	91 83       	std	Z+1, r25	; 0x01
     3b0:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
     3b2:	0f 90       	pop	r0
     3b4:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerialPort.xRxedChars), cChar);
	}
}
     3b6:	ff 91       	pop	r31
     3b8:	ef 91       	pop	r30
     3ba:	bf 91       	pop	r27
     3bc:	af 91       	pop	r26
     3be:	9f 91       	pop	r25
     3c0:	8f 91       	pop	r24
     3c2:	4f 91       	pop	r20
     3c4:	3f 91       	pop	r19
     3c6:	2f 91       	pop	r18
     3c8:	0f 90       	pop	r0
     3ca:	0f be       	out	0x3f, r0	; 63
     3cc:	0f 90       	pop	r0
     3ce:	1f 90       	pop	r1
     3d0:	18 95       	reti

000003d2 <__vector_19>:
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART0_UDRE_vect )

#endif
{
     3d2:	1f 92       	push	r1
     3d4:	0f 92       	push	r0
     3d6:	0f b6       	in	r0, 0x3f	; 63
     3d8:	0f 92       	push	r0
     3da:	11 24       	eor	r1, r1
     3dc:	2f 93       	push	r18
     3de:	8f 93       	push	r24
     3e0:	9f 93       	push	r25
     3e2:	af 93       	push	r26
     3e4:	bf 93       	push	r27
     3e6:	ef 93       	push	r30
     3e8:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
     3ea:	0f b6       	in	r0, 0x3f	; 63
     3ec:	f8 94       	cli
     3ee:	0f 92       	push	r0
	{
	    count = buffer->count;
     3f0:	80 91 b3 01 	lds	r24, 0x01B3	; 0x8001b3 <xSerialPort+0xd>
     3f4:	90 91 b4 01 	lds	r25, 0x01B4	; 0x8001b4 <xSerialPort+0xe>
	}
	portEXIT_CRITICAL();
     3f8:	0f 90       	pop	r0
     3fa:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerialPort.xCharsForTx) ) )
     3fc:	89 2b       	or	r24, r25
     3fe:	31 f4       	brne	.+12     	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
	{
		// Queue empty, nothing to send.
		vInterrupt0_Off();
     400:	e1 ec       	ldi	r30, 0xC1	; 193
     402:	f0 e0       	ldi	r31, 0x00	; 0
     404:	80 81       	ld	r24, Z
     406:	8f 7d       	andi	r24, 0xDF	; 223
     408:	80 83       	st	Z, r24
     40a:	1c c0       	rjmp	.+56     	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
     40c:	e3 eb       	ldi	r30, 0xB3	; 179
     40e:	f1 e0       	ldi	r31, 0x01	; 1

	uint8_t data = *buffer->out;
     410:	a4 81       	ldd	r26, Z+4	; 0x04
     412:	b5 81       	ldd	r27, Z+5	; 0x05
     414:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
     416:	b5 83       	std	Z+5, r27	; 0x05
     418:	a4 83       	std	Z+4, r26	; 0x04
     41a:	80 85       	ldd	r24, Z+8	; 0x08
     41c:	91 85       	ldd	r25, Z+9	; 0x09
     41e:	a8 17       	cp	r26, r24
     420:	b9 07       	cpc	r27, r25
     422:	21 f4       	brne	.+8      	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>
	  buffer->out = buffer->start;
     424:	86 81       	ldd	r24, Z+6	; 0x06
     426:	97 81       	ldd	r25, Z+7	; 0x07
     428:	95 83       	std	Z+5, r25	; 0x05
     42a:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
     42c:	0f b6       	in	r0, 0x3f	; 63
     42e:	f8 94       	cli
     430:	0f 92       	push	r0
	{
	    buffer->count--;
     432:	80 81       	ld	r24, Z
     434:	91 81       	ldd	r25, Z+1	; 0x01
     436:	01 97       	sbiw	r24, 0x01	; 1
     438:	91 83       	std	Z+1, r25	; 0x01
     43a:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
     43c:	0f 90       	pop	r0
     43e:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR0 = ringBuffer_Pop( (ringBuffer_t*) &(xSerialPort.xCharsForTx) );
     440:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	}
}
     444:	ff 91       	pop	r31
     446:	ef 91       	pop	r30
     448:	bf 91       	pop	r27
     44a:	af 91       	pop	r26
     44c:	9f 91       	pop	r25
     44e:	8f 91       	pop	r24
     450:	2f 91       	pop	r18
     452:	0f 90       	pop	r0
     454:	0f be       	out	0x3f, r0	; 63
     456:	0f 90       	pop	r0
     458:	1f 90       	pop	r1
     45a:	18 95       	reti

0000045c <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
     45c:	31 e1       	ldi	r19, 0x11	; 17
     45e:	fc 01       	movw	r30, r24
     460:	30 83       	st	Z, r19
     462:	31 97       	sbiw	r30, 0x01	; 1
     464:	22 e2       	ldi	r18, 0x22	; 34
     466:	20 83       	st	Z, r18
     468:	31 97       	sbiw	r30, 0x01	; 1
     46a:	a3 e3       	ldi	r26, 0x33	; 51
     46c:	a0 83       	st	Z, r26
     46e:	31 97       	sbiw	r30, 0x01	; 1
     470:	60 83       	st	Z, r22
     472:	31 97       	sbiw	r30, 0x01	; 1
     474:	70 83       	st	Z, r23
     476:	31 97       	sbiw	r30, 0x01	; 1
     478:	10 82       	st	Z, r1
     47a:	31 97       	sbiw	r30, 0x01	; 1
     47c:	60 e8       	ldi	r22, 0x80	; 128
     47e:	60 83       	st	Z, r22
     480:	31 97       	sbiw	r30, 0x01	; 1
     482:	10 82       	st	Z, r1
     484:	31 97       	sbiw	r30, 0x01	; 1
     486:	62 e0       	ldi	r22, 0x02	; 2
     488:	60 83       	st	Z, r22
     48a:	31 97       	sbiw	r30, 0x01	; 1
     48c:	63 e0       	ldi	r22, 0x03	; 3
     48e:	60 83       	st	Z, r22
     490:	31 97       	sbiw	r30, 0x01	; 1
     492:	64 e0       	ldi	r22, 0x04	; 4
     494:	60 83       	st	Z, r22
     496:	31 97       	sbiw	r30, 0x01	; 1
     498:	65 e0       	ldi	r22, 0x05	; 5
     49a:	60 83       	st	Z, r22
     49c:	31 97       	sbiw	r30, 0x01	; 1
     49e:	66 e0       	ldi	r22, 0x06	; 6
     4a0:	60 83       	st	Z, r22
     4a2:	31 97       	sbiw	r30, 0x01	; 1
     4a4:	67 e0       	ldi	r22, 0x07	; 7
     4a6:	60 83       	st	Z, r22
     4a8:	31 97       	sbiw	r30, 0x01	; 1
     4aa:	68 e0       	ldi	r22, 0x08	; 8
     4ac:	60 83       	st	Z, r22
     4ae:	31 97       	sbiw	r30, 0x01	; 1
     4b0:	69 e0       	ldi	r22, 0x09	; 9
     4b2:	60 83       	st	Z, r22
     4b4:	31 97       	sbiw	r30, 0x01	; 1
     4b6:	60 e1       	ldi	r22, 0x10	; 16
     4b8:	60 83       	st	Z, r22
     4ba:	31 97       	sbiw	r30, 0x01	; 1
     4bc:	30 83       	st	Z, r19
     4be:	31 97       	sbiw	r30, 0x01	; 1
     4c0:	32 e1       	ldi	r19, 0x12	; 18
     4c2:	30 83       	st	Z, r19
     4c4:	31 97       	sbiw	r30, 0x01	; 1
     4c6:	33 e1       	ldi	r19, 0x13	; 19
     4c8:	30 83       	st	Z, r19
     4ca:	31 97       	sbiw	r30, 0x01	; 1
     4cc:	34 e1       	ldi	r19, 0x14	; 20
     4ce:	30 83       	st	Z, r19
     4d0:	31 97       	sbiw	r30, 0x01	; 1
     4d2:	35 e1       	ldi	r19, 0x15	; 21
     4d4:	30 83       	st	Z, r19
     4d6:	31 97       	sbiw	r30, 0x01	; 1
     4d8:	36 e1       	ldi	r19, 0x16	; 22
     4da:	30 83       	st	Z, r19
     4dc:	31 97       	sbiw	r30, 0x01	; 1
     4de:	37 e1       	ldi	r19, 0x17	; 23
     4e0:	30 83       	st	Z, r19
     4e2:	31 97       	sbiw	r30, 0x01	; 1
     4e4:	38 e1       	ldi	r19, 0x18	; 24
     4e6:	30 83       	st	Z, r19
     4e8:	31 97       	sbiw	r30, 0x01	; 1
     4ea:	39 e1       	ldi	r19, 0x19	; 25
     4ec:	30 83       	st	Z, r19
     4ee:	31 97       	sbiw	r30, 0x01	; 1
     4f0:	30 e2       	ldi	r19, 0x20	; 32
     4f2:	30 83       	st	Z, r19
     4f4:	31 97       	sbiw	r30, 0x01	; 1
     4f6:	31 e2       	ldi	r19, 0x21	; 33
     4f8:	30 83       	st	Z, r19
     4fa:	31 97       	sbiw	r30, 0x01	; 1
     4fc:	20 83       	st	Z, r18
     4fe:	31 97       	sbiw	r30, 0x01	; 1
     500:	23 e2       	ldi	r18, 0x23	; 35
     502:	20 83       	st	Z, r18
     504:	31 97       	sbiw	r30, 0x01	; 1
     506:	40 83       	st	Z, r20
     508:	31 97       	sbiw	r30, 0x01	; 1
     50a:	50 83       	st	Z, r21
     50c:	31 97       	sbiw	r30, 0x01	; 1
     50e:	26 e2       	ldi	r18, 0x26	; 38
     510:	20 83       	st	Z, r18
     512:	31 97       	sbiw	r30, 0x01	; 1
     514:	27 e2       	ldi	r18, 0x27	; 39
     516:	20 83       	st	Z, r18
     518:	31 97       	sbiw	r30, 0x01	; 1
     51a:	28 e2       	ldi	r18, 0x28	; 40
     51c:	20 83       	st	Z, r18
     51e:	31 97       	sbiw	r30, 0x01	; 1
     520:	29 e2       	ldi	r18, 0x29	; 41
     522:	20 83       	st	Z, r18
     524:	31 97       	sbiw	r30, 0x01	; 1
     526:	20 e3       	ldi	r18, 0x30	; 48
     528:	20 83       	st	Z, r18
     52a:	31 97       	sbiw	r30, 0x01	; 1
     52c:	21 e3       	ldi	r18, 0x31	; 49
     52e:	20 83       	st	Z, r18
     530:	86 97       	sbiw	r24, 0x26	; 38
     532:	08 95       	ret

00000534 <xPortStartScheduler>:
     534:	a8 95       	wdr
     536:	90 ec       	ldi	r25, 0xC0	; 192
     538:	88 e1       	ldi	r24, 0x18	; 24
     53a:	0f b6       	in	r0, 0x3f	; 63
     53c:	f8 94       	cli
     53e:	a8 95       	wdr
     540:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     544:	0f be       	out	0x3f, r0	; 63
     546:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     54a:	a0 91 88 01 	lds	r26, 0x0188	; 0x800188 <pxCurrentTCB>
     54e:	b0 91 89 01 	lds	r27, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
     552:	cd 91       	ld	r28, X+
     554:	cd bf       	out	0x3d, r28	; 61
     556:	dd 91       	ld	r29, X+
     558:	de bf       	out	0x3e, r29	; 62
     55a:	ff 91       	pop	r31
     55c:	ef 91       	pop	r30
     55e:	df 91       	pop	r29
     560:	cf 91       	pop	r28
     562:	bf 91       	pop	r27
     564:	af 91       	pop	r26
     566:	9f 91       	pop	r25
     568:	8f 91       	pop	r24
     56a:	7f 91       	pop	r23
     56c:	6f 91       	pop	r22
     56e:	5f 91       	pop	r21
     570:	4f 91       	pop	r20
     572:	3f 91       	pop	r19
     574:	2f 91       	pop	r18
     576:	1f 91       	pop	r17
     578:	0f 91       	pop	r16
     57a:	ff 90       	pop	r15
     57c:	ef 90       	pop	r14
     57e:	df 90       	pop	r13
     580:	cf 90       	pop	r12
     582:	bf 90       	pop	r11
     584:	af 90       	pop	r10
     586:	9f 90       	pop	r9
     588:	8f 90       	pop	r8
     58a:	7f 90       	pop	r7
     58c:	6f 90       	pop	r6
     58e:	5f 90       	pop	r5
     590:	4f 90       	pop	r4
     592:	3f 90       	pop	r3
     594:	2f 90       	pop	r2
     596:	1f 90       	pop	r1
     598:	0f 90       	pop	r0
     59a:	0f be       	out	0x3f, r0	; 63
     59c:	0f 90       	pop	r0
     59e:	08 95       	ret
     5a0:	81 e0       	ldi	r24, 0x01	; 1
     5a2:	08 95       	ret

000005a4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     5a4:	0f 92       	push	r0
     5a6:	0f b6       	in	r0, 0x3f	; 63
     5a8:	f8 94       	cli
     5aa:	0f 92       	push	r0
     5ac:	1f 92       	push	r1
     5ae:	11 24       	eor	r1, r1
     5b0:	2f 92       	push	r2
     5b2:	3f 92       	push	r3
     5b4:	4f 92       	push	r4
     5b6:	5f 92       	push	r5
     5b8:	6f 92       	push	r6
     5ba:	7f 92       	push	r7
     5bc:	8f 92       	push	r8
     5be:	9f 92       	push	r9
     5c0:	af 92       	push	r10
     5c2:	bf 92       	push	r11
     5c4:	cf 92       	push	r12
     5c6:	df 92       	push	r13
     5c8:	ef 92       	push	r14
     5ca:	ff 92       	push	r15
     5cc:	0f 93       	push	r16
     5ce:	1f 93       	push	r17
     5d0:	2f 93       	push	r18
     5d2:	3f 93       	push	r19
     5d4:	4f 93       	push	r20
     5d6:	5f 93       	push	r21
     5d8:	6f 93       	push	r22
     5da:	7f 93       	push	r23
     5dc:	8f 93       	push	r24
     5de:	9f 93       	push	r25
     5e0:	af 93       	push	r26
     5e2:	bf 93       	push	r27
     5e4:	cf 93       	push	r28
     5e6:	df 93       	push	r29
     5e8:	ef 93       	push	r30
     5ea:	ff 93       	push	r31
     5ec:	a0 91 88 01 	lds	r26, 0x0188	; 0x800188 <pxCurrentTCB>
     5f0:	b0 91 89 01 	lds	r27, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
     5f4:	0d b6       	in	r0, 0x3d	; 61
     5f6:	0d 92       	st	X+, r0
     5f8:	0e b6       	in	r0, 0x3e	; 62
     5fa:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     5fc:	0e 94 de 09 	call	0x13bc	; 0x13bc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     600:	a0 91 88 01 	lds	r26, 0x0188	; 0x800188 <pxCurrentTCB>
     604:	b0 91 89 01 	lds	r27, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
     608:	cd 91       	ld	r28, X+
     60a:	cd bf       	out	0x3d, r28	; 61
     60c:	dd 91       	ld	r29, X+
     60e:	de bf       	out	0x3e, r29	; 62
     610:	ff 91       	pop	r31
     612:	ef 91       	pop	r30
     614:	df 91       	pop	r29
     616:	cf 91       	pop	r28
     618:	bf 91       	pop	r27
     61a:	af 91       	pop	r26
     61c:	9f 91       	pop	r25
     61e:	8f 91       	pop	r24
     620:	7f 91       	pop	r23
     622:	6f 91       	pop	r22
     624:	5f 91       	pop	r21
     626:	4f 91       	pop	r20
     628:	3f 91       	pop	r19
     62a:	2f 91       	pop	r18
     62c:	1f 91       	pop	r17
     62e:	0f 91       	pop	r16
     630:	ff 90       	pop	r15
     632:	ef 90       	pop	r14
     634:	df 90       	pop	r13
     636:	cf 90       	pop	r12
     638:	bf 90       	pop	r11
     63a:	af 90       	pop	r10
     63c:	9f 90       	pop	r9
     63e:	8f 90       	pop	r8
     640:	7f 90       	pop	r7
     642:	6f 90       	pop	r6
     644:	5f 90       	pop	r5
     646:	4f 90       	pop	r4
     648:	3f 90       	pop	r3
     64a:	2f 90       	pop	r2
     64c:	1f 90       	pop	r1
     64e:	0f 90       	pop	r0
     650:	0f be       	out	0x3f, r0	; 63
     652:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     654:	08 95       	ret

00000656 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     656:	0f 92       	push	r0
     658:	0f b6       	in	r0, 0x3f	; 63
     65a:	f8 94       	cli
     65c:	0f 92       	push	r0
     65e:	1f 92       	push	r1
     660:	11 24       	eor	r1, r1
     662:	2f 92       	push	r2
     664:	3f 92       	push	r3
     666:	4f 92       	push	r4
     668:	5f 92       	push	r5
     66a:	6f 92       	push	r6
     66c:	7f 92       	push	r7
     66e:	8f 92       	push	r8
     670:	9f 92       	push	r9
     672:	af 92       	push	r10
     674:	bf 92       	push	r11
     676:	cf 92       	push	r12
     678:	df 92       	push	r13
     67a:	ef 92       	push	r14
     67c:	ff 92       	push	r15
     67e:	0f 93       	push	r16
     680:	1f 93       	push	r17
     682:	2f 93       	push	r18
     684:	3f 93       	push	r19
     686:	4f 93       	push	r20
     688:	5f 93       	push	r21
     68a:	6f 93       	push	r22
     68c:	7f 93       	push	r23
     68e:	8f 93       	push	r24
     690:	9f 93       	push	r25
     692:	af 93       	push	r26
     694:	bf 93       	push	r27
     696:	cf 93       	push	r28
     698:	df 93       	push	r29
     69a:	ef 93       	push	r30
     69c:	ff 93       	push	r31
     69e:	a0 91 88 01 	lds	r26, 0x0188	; 0x800188 <pxCurrentTCB>
     6a2:	b0 91 89 01 	lds	r27, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
     6a6:	0d b6       	in	r0, 0x3d	; 61
     6a8:	0d 92       	st	X+, r0
     6aa:	0e b6       	in	r0, 0x3e	; 62
     6ac:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
     6ae:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
     6b0:	0e 94 66 08 	call	0x10cc	; 0x10cc <xTaskIncrementTick>
     6b4:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     6b6:	0e 94 de 09 	call	0x13bc	; 0x13bc <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
     6ba:	a0 91 88 01 	lds	r26, 0x0188	; 0x800188 <pxCurrentTCB>
     6be:	b0 91 89 01 	lds	r27, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
     6c2:	cd 91       	ld	r28, X+
     6c4:	cd bf       	out	0x3d, r28	; 61
     6c6:	dd 91       	ld	r29, X+
     6c8:	de bf       	out	0x3e, r29	; 62
     6ca:	ff 91       	pop	r31
     6cc:	ef 91       	pop	r30
     6ce:	df 91       	pop	r29
     6d0:	cf 91       	pop	r28
     6d2:	bf 91       	pop	r27
     6d4:	af 91       	pop	r26
     6d6:	9f 91       	pop	r25
     6d8:	8f 91       	pop	r24
     6da:	7f 91       	pop	r23
     6dc:	6f 91       	pop	r22
     6de:	5f 91       	pop	r21
     6e0:	4f 91       	pop	r20
     6e2:	3f 91       	pop	r19
     6e4:	2f 91       	pop	r18
     6e6:	1f 91       	pop	r17
     6e8:	0f 91       	pop	r16
     6ea:	ff 90       	pop	r15
     6ec:	ef 90       	pop	r14
     6ee:	df 90       	pop	r13
     6f0:	cf 90       	pop	r12
     6f2:	bf 90       	pop	r11
     6f4:	af 90       	pop	r10
     6f6:	9f 90       	pop	r9
     6f8:	8f 90       	pop	r8
     6fa:	7f 90       	pop	r7
     6fc:	6f 90       	pop	r6
     6fe:	5f 90       	pop	r5
     700:	4f 90       	pop	r4
     702:	3f 90       	pop	r3
     704:	2f 90       	pop	r2
     706:	1f 90       	pop	r1
     708:	0f 90       	pop	r0
     70a:	0f be       	out	0x3f, r0	; 63
     70c:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     70e:	08 95       	ret

00000710 <__vector_6>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
     710:	0e 94 2b 03 	call	0x656	; 0x656 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
     714:	18 95       	reti

00000716 <prvIsQueueEmpty>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     716:	0f b6       	in	r0, 0x3f	; 63
     718:	f8 94       	cli
     71a:	0f 92       	push	r0
     71c:	fc 01       	movw	r30, r24
     71e:	92 8d       	ldd	r25, Z+26	; 0x1a
     720:	0f 90       	pop	r0
     722:	0f be       	out	0x3f, r0	; 63
     724:	81 e0       	ldi	r24, 0x01	; 1
     726:	91 11       	cpse	r25, r1
     728:	80 e0       	ldi	r24, 0x00	; 0
     72a:	08 95       	ret

0000072c <prvCopyDataToQueue>:
     72c:	0f 93       	push	r16
     72e:	1f 93       	push	r17
     730:	cf 93       	push	r28
     732:	df 93       	push	r29
     734:	ec 01       	movw	r28, r24
     736:	04 2f       	mov	r16, r20
     738:	1a 8d       	ldd	r17, Y+26	; 0x1a
     73a:	4c 8d       	ldd	r20, Y+28	; 0x1c
     73c:	41 11       	cpse	r20, r1
     73e:	0c c0       	rjmp	.+24     	; 0x758 <prvCopyDataToQueue+0x2c>
     740:	88 81       	ld	r24, Y
     742:	99 81       	ldd	r25, Y+1	; 0x01
     744:	89 2b       	or	r24, r25
     746:	09 f0       	breq	.+2      	; 0x74a <prvCopyDataToQueue+0x1e>
     748:	42 c0       	rjmp	.+132    	; 0x7ce <prvCopyDataToQueue+0xa2>
     74a:	8c 81       	ldd	r24, Y+4	; 0x04
     74c:	9d 81       	ldd	r25, Y+5	; 0x05
     74e:	0e 94 25 0b 	call	0x164a	; 0x164a <xTaskPriorityDisinherit>
     752:	1d 82       	std	Y+5, r1	; 0x05
     754:	1c 82       	std	Y+4, r1	; 0x04
     756:	42 c0       	rjmp	.+132    	; 0x7dc <prvCopyDataToQueue+0xb0>
     758:	01 11       	cpse	r16, r1
     75a:	17 c0       	rjmp	.+46     	; 0x78a <prvCopyDataToQueue+0x5e>
     75c:	50 e0       	ldi	r21, 0x00	; 0
     75e:	8a 81       	ldd	r24, Y+2	; 0x02
     760:	9b 81       	ldd	r25, Y+3	; 0x03
     762:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <memcpy>
     766:	2c 8d       	ldd	r18, Y+28	; 0x1c
     768:	8a 81       	ldd	r24, Y+2	; 0x02
     76a:	9b 81       	ldd	r25, Y+3	; 0x03
     76c:	82 0f       	add	r24, r18
     76e:	91 1d       	adc	r25, r1
     770:	9b 83       	std	Y+3, r25	; 0x03
     772:	8a 83       	std	Y+2, r24	; 0x02
     774:	2c 81       	ldd	r18, Y+4	; 0x04
     776:	3d 81       	ldd	r19, Y+5	; 0x05
     778:	82 17       	cp	r24, r18
     77a:	93 07       	cpc	r25, r19
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <prvCopyDataToQueue+0xa6>
     77e:	88 81       	ld	r24, Y
     780:	99 81       	ldd	r25, Y+1	; 0x01
     782:	9b 83       	std	Y+3, r25	; 0x03
     784:	8a 83       	std	Y+2, r24	; 0x02
     786:	80 e0       	ldi	r24, 0x00	; 0
     788:	29 c0       	rjmp	.+82     	; 0x7dc <prvCopyDataToQueue+0xb0>
     78a:	50 e0       	ldi	r21, 0x00	; 0
     78c:	8e 81       	ldd	r24, Y+6	; 0x06
     78e:	9f 81       	ldd	r25, Y+7	; 0x07
     790:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <memcpy>
     794:	8c 8d       	ldd	r24, Y+28	; 0x1c
     796:	90 e0       	ldi	r25, 0x00	; 0
     798:	91 95       	neg	r25
     79a:	81 95       	neg	r24
     79c:	91 09       	sbc	r25, r1
     79e:	2e 81       	ldd	r18, Y+6	; 0x06
     7a0:	3f 81       	ldd	r19, Y+7	; 0x07
     7a2:	28 0f       	add	r18, r24
     7a4:	39 1f       	adc	r19, r25
     7a6:	3f 83       	std	Y+7, r19	; 0x07
     7a8:	2e 83       	std	Y+6, r18	; 0x06
     7aa:	48 81       	ld	r20, Y
     7ac:	59 81       	ldd	r21, Y+1	; 0x01
     7ae:	24 17       	cp	r18, r20
     7b0:	35 07       	cpc	r19, r21
     7b2:	30 f4       	brcc	.+12     	; 0x7c0 <prvCopyDataToQueue+0x94>
     7b4:	2c 81       	ldd	r18, Y+4	; 0x04
     7b6:	3d 81       	ldd	r19, Y+5	; 0x05
     7b8:	82 0f       	add	r24, r18
     7ba:	93 1f       	adc	r25, r19
     7bc:	9f 83       	std	Y+7, r25	; 0x07
     7be:	8e 83       	std	Y+6, r24	; 0x06
     7c0:	02 30       	cpi	r16, 0x02	; 2
     7c2:	49 f4       	brne	.+18     	; 0x7d6 <prvCopyDataToQueue+0xaa>
     7c4:	11 23       	and	r17, r17
     7c6:	49 f0       	breq	.+18     	; 0x7da <prvCopyDataToQueue+0xae>
     7c8:	11 50       	subi	r17, 0x01	; 1
     7ca:	80 e0       	ldi	r24, 0x00	; 0
     7cc:	07 c0       	rjmp	.+14     	; 0x7dc <prvCopyDataToQueue+0xb0>
     7ce:	80 e0       	ldi	r24, 0x00	; 0
     7d0:	05 c0       	rjmp	.+10     	; 0x7dc <prvCopyDataToQueue+0xb0>
     7d2:	80 e0       	ldi	r24, 0x00	; 0
     7d4:	03 c0       	rjmp	.+6      	; 0x7dc <prvCopyDataToQueue+0xb0>
     7d6:	80 e0       	ldi	r24, 0x00	; 0
     7d8:	01 c0       	rjmp	.+2      	; 0x7dc <prvCopyDataToQueue+0xb0>
     7da:	80 e0       	ldi	r24, 0x00	; 0
     7dc:	1f 5f       	subi	r17, 0xFF	; 255
     7de:	1a 8f       	std	Y+26, r17	; 0x1a
     7e0:	df 91       	pop	r29
     7e2:	cf 91       	pop	r28
     7e4:	1f 91       	pop	r17
     7e6:	0f 91       	pop	r16
     7e8:	08 95       	ret

000007ea <prvCopyDataFromQueue>:
     7ea:	fc 01       	movw	r30, r24
     7ec:	44 8d       	ldd	r20, Z+28	; 0x1c
     7ee:	44 23       	and	r20, r20
     7f0:	a9 f0       	breq	.+42     	; 0x81c <prvCopyDataFromQueue+0x32>
     7f2:	50 e0       	ldi	r21, 0x00	; 0
     7f4:	26 81       	ldd	r18, Z+6	; 0x06
     7f6:	37 81       	ldd	r19, Z+7	; 0x07
     7f8:	24 0f       	add	r18, r20
     7fa:	35 1f       	adc	r19, r21
     7fc:	37 83       	std	Z+7, r19	; 0x07
     7fe:	26 83       	std	Z+6, r18	; 0x06
     800:	84 81       	ldd	r24, Z+4	; 0x04
     802:	95 81       	ldd	r25, Z+5	; 0x05
     804:	28 17       	cp	r18, r24
     806:	39 07       	cpc	r19, r25
     808:	20 f0       	brcs	.+8      	; 0x812 <prvCopyDataFromQueue+0x28>
     80a:	80 81       	ld	r24, Z
     80c:	91 81       	ldd	r25, Z+1	; 0x01
     80e:	97 83       	std	Z+7, r25	; 0x07
     810:	86 83       	std	Z+6, r24	; 0x06
     812:	cb 01       	movw	r24, r22
     814:	66 81       	ldd	r22, Z+6	; 0x06
     816:	77 81       	ldd	r23, Z+7	; 0x07
     818:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <memcpy>
     81c:	08 95       	ret

0000081e <prvUnlockQueue>:
     81e:	ef 92       	push	r14
     820:	ff 92       	push	r15
     822:	0f 93       	push	r16
     824:	1f 93       	push	r17
     826:	cf 93       	push	r28
     828:	8c 01       	movw	r16, r24
     82a:	0f b6       	in	r0, 0x3f	; 63
     82c:	f8 94       	cli
     82e:	0f 92       	push	r0
     830:	fc 01       	movw	r30, r24
     832:	c6 8d       	ldd	r28, Z+30	; 0x1e
     834:	1c 16       	cp	r1, r28
     836:	ac f4       	brge	.+42     	; 0x862 <prvUnlockQueue+0x44>
     838:	81 89       	ldd	r24, Z+17	; 0x11
     83a:	81 11       	cpse	r24, r1
     83c:	06 c0       	rjmp	.+12     	; 0x84a <prvUnlockQueue+0x2c>
     83e:	11 c0       	rjmp	.+34     	; 0x862 <prvUnlockQueue+0x44>
     840:	f8 01       	movw	r30, r16
     842:	81 89       	ldd	r24, Z+17	; 0x11
     844:	81 11       	cpse	r24, r1
     846:	05 c0       	rjmp	.+10     	; 0x852 <prvUnlockQueue+0x34>
     848:	0c c0       	rjmp	.+24     	; 0x862 <prvUnlockQueue+0x44>
     84a:	78 01       	movw	r14, r16
     84c:	f1 e1       	ldi	r31, 0x11	; 17
     84e:	ef 0e       	add	r14, r31
     850:	f1 1c       	adc	r15, r1
     852:	c7 01       	movw	r24, r14
     854:	0e 94 8a 0a 	call	0x1514	; 0x1514 <xTaskRemoveFromEventList>
     858:	81 11       	cpse	r24, r1
     85a:	0e 94 13 0b 	call	0x1626	; 0x1626 <vTaskMissedYield>
     85e:	c1 50       	subi	r28, 0x01	; 1
     860:	79 f7       	brne	.-34     	; 0x840 <prvUnlockQueue+0x22>
     862:	8f ef       	ldi	r24, 0xFF	; 255
     864:	f8 01       	movw	r30, r16
     866:	86 8f       	std	Z+30, r24	; 0x1e
     868:	0f 90       	pop	r0
     86a:	0f be       	out	0x3f, r0	; 63
     86c:	0f b6       	in	r0, 0x3f	; 63
     86e:	f8 94       	cli
     870:	0f 92       	push	r0
     872:	c5 8d       	ldd	r28, Z+29	; 0x1d
     874:	1c 16       	cp	r1, r28
     876:	ac f4       	brge	.+42     	; 0x8a2 <prvUnlockQueue+0x84>
     878:	80 85       	ldd	r24, Z+8	; 0x08
     87a:	81 11       	cpse	r24, r1
     87c:	06 c0       	rjmp	.+12     	; 0x88a <prvUnlockQueue+0x6c>
     87e:	11 c0       	rjmp	.+34     	; 0x8a2 <prvUnlockQueue+0x84>
     880:	f8 01       	movw	r30, r16
     882:	80 85       	ldd	r24, Z+8	; 0x08
     884:	81 11       	cpse	r24, r1
     886:	05 c0       	rjmp	.+10     	; 0x892 <prvUnlockQueue+0x74>
     888:	0c c0       	rjmp	.+24     	; 0x8a2 <prvUnlockQueue+0x84>
     88a:	78 01       	movw	r14, r16
     88c:	f8 e0       	ldi	r31, 0x08	; 8
     88e:	ef 0e       	add	r14, r31
     890:	f1 1c       	adc	r15, r1
     892:	c7 01       	movw	r24, r14
     894:	0e 94 8a 0a 	call	0x1514	; 0x1514 <xTaskRemoveFromEventList>
     898:	81 11       	cpse	r24, r1
     89a:	0e 94 13 0b 	call	0x1626	; 0x1626 <vTaskMissedYield>
     89e:	c1 50       	subi	r28, 0x01	; 1
     8a0:	79 f7       	brne	.-34     	; 0x880 <prvUnlockQueue+0x62>
     8a2:	8f ef       	ldi	r24, 0xFF	; 255
     8a4:	f8 01       	movw	r30, r16
     8a6:	85 8f       	std	Z+29, r24	; 0x1d
     8a8:	0f 90       	pop	r0
     8aa:	0f be       	out	0x3f, r0	; 63
     8ac:	cf 91       	pop	r28
     8ae:	1f 91       	pop	r17
     8b0:	0f 91       	pop	r16
     8b2:	ff 90       	pop	r15
     8b4:	ef 90       	pop	r14
     8b6:	08 95       	ret

000008b8 <xQueueGenericReset>:
     8b8:	cf 93       	push	r28
     8ba:	df 93       	push	r29
     8bc:	ec 01       	movw	r28, r24
     8be:	0f b6       	in	r0, 0x3f	; 63
     8c0:	f8 94       	cli
     8c2:	0f 92       	push	r0
     8c4:	e8 81       	ld	r30, Y
     8c6:	f9 81       	ldd	r31, Y+1	; 0x01
     8c8:	8b 8d       	ldd	r24, Y+27	; 0x1b
     8ca:	2c 8d       	ldd	r18, Y+28	; 0x1c
     8cc:	90 e0       	ldi	r25, 0x00	; 0
     8ce:	30 e0       	ldi	r19, 0x00	; 0
     8d0:	82 9f       	mul	r24, r18
     8d2:	a0 01       	movw	r20, r0
     8d4:	83 9f       	mul	r24, r19
     8d6:	50 0d       	add	r21, r0
     8d8:	92 9f       	mul	r25, r18
     8da:	50 0d       	add	r21, r0
     8dc:	11 24       	eor	r1, r1
     8de:	4e 0f       	add	r20, r30
     8e0:	5f 1f       	adc	r21, r31
     8e2:	5d 83       	std	Y+5, r21	; 0x05
     8e4:	4c 83       	std	Y+4, r20	; 0x04
     8e6:	1a 8e       	std	Y+26, r1	; 0x1a
     8e8:	fb 83       	std	Y+3, r31	; 0x03
     8ea:	ea 83       	std	Y+2, r30	; 0x02
     8ec:	01 97       	sbiw	r24, 0x01	; 1
     8ee:	82 9f       	mul	r24, r18
     8f0:	a0 01       	movw	r20, r0
     8f2:	83 9f       	mul	r24, r19
     8f4:	50 0d       	add	r21, r0
     8f6:	92 9f       	mul	r25, r18
     8f8:	50 0d       	add	r21, r0
     8fa:	11 24       	eor	r1, r1
     8fc:	cf 01       	movw	r24, r30
     8fe:	84 0f       	add	r24, r20
     900:	95 1f       	adc	r25, r21
     902:	9f 83       	std	Y+7, r25	; 0x07
     904:	8e 83       	std	Y+6, r24	; 0x06
     906:	8f ef       	ldi	r24, 0xFF	; 255
     908:	8d 8f       	std	Y+29, r24	; 0x1d
     90a:	8e 8f       	std	Y+30, r24	; 0x1e
     90c:	61 11       	cpse	r22, r1
     90e:	0c c0       	rjmp	.+24     	; 0x928 <__stack+0x29>
     910:	88 85       	ldd	r24, Y+8	; 0x08
     912:	88 23       	and	r24, r24
     914:	89 f0       	breq	.+34     	; 0x938 <__stack+0x39>
     916:	ce 01       	movw	r24, r28
     918:	08 96       	adiw	r24, 0x08	; 8
     91a:	0e 94 8a 0a 	call	0x1514	; 0x1514 <xTaskRemoveFromEventList>
     91e:	88 23       	and	r24, r24
     920:	59 f0       	breq	.+22     	; 0x938 <__stack+0x39>
     922:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vPortYield>
     926:	08 c0       	rjmp	.+16     	; 0x938 <__stack+0x39>
     928:	ce 01       	movw	r24, r28
     92a:	08 96       	adiw	r24, 0x08	; 8
     92c:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     930:	ce 01       	movw	r24, r28
     932:	41 96       	adiw	r24, 0x11	; 17
     934:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     938:	0f 90       	pop	r0
     93a:	0f be       	out	0x3f, r0	; 63
     93c:	81 e0       	ldi	r24, 0x01	; 1
     93e:	df 91       	pop	r29
     940:	cf 91       	pop	r28
     942:	08 95       	ret

00000944 <xQueueGenericCreate>:
     944:	0f 93       	push	r16
     946:	1f 93       	push	r17
     948:	cf 93       	push	r28
     94a:	df 93       	push	r29
     94c:	08 2f       	mov	r16, r24
     94e:	16 2f       	mov	r17, r22
     950:	66 23       	and	r22, r22
     952:	c1 f0       	breq	.+48     	; 0x984 <xQueueGenericCreate+0x40>
     954:	86 9f       	mul	r24, r22
     956:	c0 01       	movw	r24, r0
     958:	11 24       	eor	r1, r1
     95a:	4f 96       	adiw	r24, 0x1f	; 31
     95c:	0e 94 5d 00 	call	0xba	; 0xba <pvPortMalloc>
     960:	ec 01       	movw	r28, r24
     962:	00 97       	sbiw	r24, 0x00	; 0
     964:	41 f4       	brne	.+16     	; 0x976 <xQueueGenericCreate+0x32>
     966:	15 c0       	rjmp	.+42     	; 0x992 <xQueueGenericCreate+0x4e>
     968:	0b 8f       	std	Y+27, r16	; 0x1b
     96a:	1c 8f       	std	Y+28, r17	; 0x1c
     96c:	61 e0       	ldi	r22, 0x01	; 1
     96e:	ce 01       	movw	r24, r28
     970:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <xQueueGenericReset>
     974:	0e c0       	rjmp	.+28     	; 0x992 <xQueueGenericCreate+0x4e>
     976:	4f 96       	adiw	r24, 0x1f	; 31
     978:	99 83       	std	Y+1, r25	; 0x01
     97a:	88 83       	st	Y, r24
     97c:	f5 cf       	rjmp	.-22     	; 0x968 <xQueueGenericCreate+0x24>
     97e:	d9 83       	std	Y+1, r29	; 0x01
     980:	c8 83       	st	Y, r28
     982:	f2 cf       	rjmp	.-28     	; 0x968 <xQueueGenericCreate+0x24>
     984:	8f e1       	ldi	r24, 0x1F	; 31
     986:	90 e0       	ldi	r25, 0x00	; 0
     988:	0e 94 5d 00 	call	0xba	; 0xba <pvPortMalloc>
     98c:	ec 01       	movw	r28, r24
     98e:	89 2b       	or	r24, r25
     990:	b1 f7       	brne	.-20     	; 0x97e <xQueueGenericCreate+0x3a>
     992:	ce 01       	movw	r24, r28
     994:	df 91       	pop	r29
     996:	cf 91       	pop	r28
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	08 95       	ret

0000099e <xQueueGenericSend>:
     99e:	9f 92       	push	r9
     9a0:	af 92       	push	r10
     9a2:	bf 92       	push	r11
     9a4:	cf 92       	push	r12
     9a6:	df 92       	push	r13
     9a8:	ef 92       	push	r14
     9aa:	ff 92       	push	r15
     9ac:	0f 93       	push	r16
     9ae:	1f 93       	push	r17
     9b0:	cf 93       	push	r28
     9b2:	df 93       	push	r29
     9b4:	00 d0       	rcall	.+0      	; 0x9b6 <xQueueGenericSend+0x18>
     9b6:	00 d0       	rcall	.+0      	; 0x9b8 <xQueueGenericSend+0x1a>
     9b8:	1f 92       	push	r1
     9ba:	cd b7       	in	r28, 0x3d	; 61
     9bc:	de b7       	in	r29, 0x3e	; 62
     9be:	8c 01       	movw	r16, r24
     9c0:	6b 01       	movw	r12, r22
     9c2:	5d 83       	std	Y+5, r21	; 0x05
     9c4:	4c 83       	std	Y+4, r20	; 0x04
     9c6:	a2 2e       	mov	r10, r18
     9c8:	b1 2c       	mov	r11, r1
     9ca:	99 24       	eor	r9, r9
     9cc:	93 94       	inc	r9
     9ce:	7c 01       	movw	r14, r24
     9d0:	88 e0       	ldi	r24, 0x08	; 8
     9d2:	e8 0e       	add	r14, r24
     9d4:	f1 1c       	adc	r15, r1
     9d6:	0f b6       	in	r0, 0x3f	; 63
     9d8:	f8 94       	cli
     9da:	0f 92       	push	r0
     9dc:	f8 01       	movw	r30, r16
     9de:	92 8d       	ldd	r25, Z+26	; 0x1a
     9e0:	83 8d       	ldd	r24, Z+27	; 0x1b
     9e2:	98 17       	cp	r25, r24
     9e4:	18 f0       	brcs	.+6      	; 0x9ec <xQueueGenericSend+0x4e>
     9e6:	f2 e0       	ldi	r31, 0x02	; 2
     9e8:	af 12       	cpse	r10, r31
     9ea:	19 c0       	rjmp	.+50     	; 0xa1e <xQueueGenericSend+0x80>
     9ec:	4a 2d       	mov	r20, r10
     9ee:	b6 01       	movw	r22, r12
     9f0:	c8 01       	movw	r24, r16
     9f2:	0e 94 96 03 	call	0x72c	; 0x72c <prvCopyDataToQueue>
     9f6:	f8 01       	movw	r30, r16
     9f8:	91 89       	ldd	r25, Z+17	; 0x11
     9fa:	99 23       	and	r25, r25
     9fc:	49 f0       	breq	.+18     	; 0xa10 <xQueueGenericSend+0x72>
     9fe:	c8 01       	movw	r24, r16
     a00:	41 96       	adiw	r24, 0x11	; 17
     a02:	0e 94 8a 0a 	call	0x1514	; 0x1514 <xTaskRemoveFromEventList>
     a06:	88 23       	and	r24, r24
     a08:	31 f0       	breq	.+12     	; 0xa16 <xQueueGenericSend+0x78>
     a0a:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vPortYield>
     a0e:	03 c0       	rjmp	.+6      	; 0xa16 <xQueueGenericSend+0x78>
     a10:	81 11       	cpse	r24, r1
     a12:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vPortYield>
     a16:	0f 90       	pop	r0
     a18:	0f be       	out	0x3f, r0	; 63
     a1a:	81 e0       	ldi	r24, 0x01	; 1
     a1c:	50 c0       	rjmp	.+160    	; 0xabe <xQueueGenericSend+0x120>
     a1e:	8c 81       	ldd	r24, Y+4	; 0x04
     a20:	9d 81       	ldd	r25, Y+5	; 0x05
     a22:	89 2b       	or	r24, r25
     a24:	21 f4       	brne	.+8      	; 0xa2e <xQueueGenericSend+0x90>
     a26:	0f 90       	pop	r0
     a28:	0f be       	out	0x3f, r0	; 63
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 c0       	rjmp	.+144    	; 0xabe <xQueueGenericSend+0x120>
     a2e:	b1 10       	cpse	r11, r1
     a30:	05 c0       	rjmp	.+10     	; 0xa3c <xQueueGenericSend+0x9e>
     a32:	ce 01       	movw	r24, r28
     a34:	01 96       	adiw	r24, 0x01	; 1
     a36:	0e 94 d2 0a 	call	0x15a4	; 0x15a4 <vTaskInternalSetTimeOutState>
     a3a:	b9 2c       	mov	r11, r9
     a3c:	0f 90       	pop	r0
     a3e:	0f be       	out	0x3f, r0	; 63
     a40:	0e 94 56 08 	call	0x10ac	; 0x10ac <vTaskSuspendAll>
     a44:	0f b6       	in	r0, 0x3f	; 63
     a46:	f8 94       	cli
     a48:	0f 92       	push	r0
     a4a:	f8 01       	movw	r30, r16
     a4c:	85 8d       	ldd	r24, Z+29	; 0x1d
     a4e:	8f 3f       	cpi	r24, 0xFF	; 255
     a50:	09 f4       	brne	.+2      	; 0xa54 <xQueueGenericSend+0xb6>
     a52:	15 8e       	std	Z+29, r1	; 0x1d
     a54:	f8 01       	movw	r30, r16
     a56:	86 8d       	ldd	r24, Z+30	; 0x1e
     a58:	8f 3f       	cpi	r24, 0xFF	; 255
     a5a:	09 f4       	brne	.+2      	; 0xa5e <xQueueGenericSend+0xc0>
     a5c:	16 8e       	std	Z+30, r1	; 0x1e
     a5e:	0f 90       	pop	r0
     a60:	0f be       	out	0x3f, r0	; 63
     a62:	be 01       	movw	r22, r28
     a64:	6c 5f       	subi	r22, 0xFC	; 252
     a66:	7f 4f       	sbci	r23, 0xFF	; 255
     a68:	ce 01       	movw	r24, r28
     a6a:	01 96       	adiw	r24, 0x01	; 1
     a6c:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <xTaskCheckForTimeOut>
     a70:	81 11       	cpse	r24, r1
     a72:	1f c0       	rjmp	.+62     	; 0xab2 <xQueueGenericSend+0x114>
     a74:	0f b6       	in	r0, 0x3f	; 63
     a76:	f8 94       	cli
     a78:	0f 92       	push	r0
     a7a:	f8 01       	movw	r30, r16
     a7c:	92 8d       	ldd	r25, Z+26	; 0x1a
     a7e:	83 8d       	ldd	r24, Z+27	; 0x1b
     a80:	0f 90       	pop	r0
     a82:	0f be       	out	0x3f, r0	; 63
     a84:	98 13       	cpse	r25, r24
     a86:	0f c0       	rjmp	.+30     	; 0xaa6 <xQueueGenericSend+0x108>
     a88:	6c 81       	ldd	r22, Y+4	; 0x04
     a8a:	7d 81       	ldd	r23, Y+5	; 0x05
     a8c:	c7 01       	movw	r24, r14
     a8e:	0e 94 5f 0a 	call	0x14be	; 0x14be <vTaskPlaceOnEventList>
     a92:	c8 01       	movw	r24, r16
     a94:	0e 94 0f 04 	call	0x81e	; 0x81e <prvUnlockQueue>
     a98:	0e 94 21 09 	call	0x1242	; 0x1242 <xTaskResumeAll>
     a9c:	81 11       	cpse	r24, r1
     a9e:	9b cf       	rjmp	.-202    	; 0x9d6 <xQueueGenericSend+0x38>
     aa0:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vPortYield>
     aa4:	98 cf       	rjmp	.-208    	; 0x9d6 <xQueueGenericSend+0x38>
     aa6:	c8 01       	movw	r24, r16
     aa8:	0e 94 0f 04 	call	0x81e	; 0x81e <prvUnlockQueue>
     aac:	0e 94 21 09 	call	0x1242	; 0x1242 <xTaskResumeAll>
     ab0:	92 cf       	rjmp	.-220    	; 0x9d6 <xQueueGenericSend+0x38>
     ab2:	c8 01       	movw	r24, r16
     ab4:	0e 94 0f 04 	call	0x81e	; 0x81e <prvUnlockQueue>
     ab8:	0e 94 21 09 	call	0x1242	; 0x1242 <xTaskResumeAll>
     abc:	80 e0       	ldi	r24, 0x00	; 0
     abe:	0f 90       	pop	r0
     ac0:	0f 90       	pop	r0
     ac2:	0f 90       	pop	r0
     ac4:	0f 90       	pop	r0
     ac6:	0f 90       	pop	r0
     ac8:	df 91       	pop	r29
     aca:	cf 91       	pop	r28
     acc:	1f 91       	pop	r17
     ace:	0f 91       	pop	r16
     ad0:	ff 90       	pop	r15
     ad2:	ef 90       	pop	r14
     ad4:	df 90       	pop	r13
     ad6:	cf 90       	pop	r12
     ad8:	bf 90       	pop	r11
     ada:	af 90       	pop	r10
     adc:	9f 90       	pop	r9
     ade:	08 95       	ret

00000ae0 <xQueueGenericSendFromISR>:
     ae0:	ef 92       	push	r14
     ae2:	ff 92       	push	r15
     ae4:	0f 93       	push	r16
     ae6:	1f 93       	push	r17
     ae8:	cf 93       	push	r28
     aea:	df 93       	push	r29
     aec:	8a 01       	movw	r16, r20
     aee:	fc 01       	movw	r30, r24
     af0:	52 8d       	ldd	r21, Z+26	; 0x1a
     af2:	33 8d       	ldd	r19, Z+27	; 0x1b
     af4:	53 17       	cp	r21, r19
     af6:	10 f0       	brcs	.+4      	; 0xafc <xQueueGenericSendFromISR+0x1c>
     af8:	22 30       	cpi	r18, 0x02	; 2
     afa:	f1 f4       	brne	.+60     	; 0xb38 <xQueueGenericSendFromISR+0x58>
     afc:	42 2f       	mov	r20, r18
     afe:	78 01       	movw	r14, r16
     b00:	ec 01       	movw	r28, r24
     b02:	1e 8d       	ldd	r17, Y+30	; 0x1e
     b04:	0e 94 96 03 	call	0x72c	; 0x72c <prvCopyDataToQueue>
     b08:	1f 3f       	cpi	r17, 0xFF	; 255
     b0a:	81 f4       	brne	.+32     	; 0xb2c <xQueueGenericSendFromISR+0x4c>
     b0c:	89 89       	ldd	r24, Y+17	; 0x11
     b0e:	88 23       	and	r24, r24
     b10:	a9 f0       	breq	.+42     	; 0xb3c <xQueueGenericSendFromISR+0x5c>
     b12:	ce 01       	movw	r24, r28
     b14:	41 96       	adiw	r24, 0x11	; 17
     b16:	0e 94 8a 0a 	call	0x1514	; 0x1514 <xTaskRemoveFromEventList>
     b1a:	88 23       	and	r24, r24
     b1c:	89 f0       	breq	.+34     	; 0xb40 <xQueueGenericSendFromISR+0x60>
     b1e:	e1 14       	cp	r14, r1
     b20:	f1 04       	cpc	r15, r1
     b22:	81 f0       	breq	.+32     	; 0xb44 <xQueueGenericSendFromISR+0x64>
     b24:	81 e0       	ldi	r24, 0x01	; 1
     b26:	f7 01       	movw	r30, r14
     b28:	80 83       	st	Z, r24
     b2a:	0d c0       	rjmp	.+26     	; 0xb46 <xQueueGenericSendFromISR+0x66>
     b2c:	ff 24       	eor	r15, r15
     b2e:	f3 94       	inc	r15
     b30:	f1 0e       	add	r15, r17
     b32:	fe 8e       	std	Y+30, r15	; 0x1e
     b34:	81 e0       	ldi	r24, 0x01	; 1
     b36:	07 c0       	rjmp	.+14     	; 0xb46 <xQueueGenericSendFromISR+0x66>
     b38:	80 e0       	ldi	r24, 0x00	; 0
     b3a:	05 c0       	rjmp	.+10     	; 0xb46 <xQueueGenericSendFromISR+0x66>
     b3c:	81 e0       	ldi	r24, 0x01	; 1
     b3e:	03 c0       	rjmp	.+6      	; 0xb46 <xQueueGenericSendFromISR+0x66>
     b40:	81 e0       	ldi	r24, 0x01	; 1
     b42:	01 c0       	rjmp	.+2      	; 0xb46 <xQueueGenericSendFromISR+0x66>
     b44:	81 e0       	ldi	r24, 0x01	; 1
     b46:	df 91       	pop	r29
     b48:	cf 91       	pop	r28
     b4a:	1f 91       	pop	r17
     b4c:	0f 91       	pop	r16
     b4e:	ff 90       	pop	r15
     b50:	ef 90       	pop	r14
     b52:	08 95       	ret

00000b54 <xQueueReceive>:
     b54:	9f 92       	push	r9
     b56:	af 92       	push	r10
     b58:	bf 92       	push	r11
     b5a:	cf 92       	push	r12
     b5c:	df 92       	push	r13
     b5e:	ef 92       	push	r14
     b60:	ff 92       	push	r15
     b62:	0f 93       	push	r16
     b64:	1f 93       	push	r17
     b66:	cf 93       	push	r28
     b68:	df 93       	push	r29
     b6a:	00 d0       	rcall	.+0      	; 0xb6c <xQueueReceive+0x18>
     b6c:	00 d0       	rcall	.+0      	; 0xb6e <xQueueReceive+0x1a>
     b6e:	1f 92       	push	r1
     b70:	cd b7       	in	r28, 0x3d	; 61
     b72:	de b7       	in	r29, 0x3e	; 62
     b74:	8c 01       	movw	r16, r24
     b76:	5b 01       	movw	r10, r22
     b78:	5d 83       	std	Y+5, r21	; 0x05
     b7a:	4c 83       	std	Y+4, r20	; 0x04
     b7c:	e1 2c       	mov	r14, r1
     b7e:	99 24       	eor	r9, r9
     b80:	93 94       	inc	r9
     b82:	6c 01       	movw	r12, r24
     b84:	81 e1       	ldi	r24, 0x11	; 17
     b86:	c8 0e       	add	r12, r24
     b88:	d1 1c       	adc	r13, r1
     b8a:	0f b6       	in	r0, 0x3f	; 63
     b8c:	f8 94       	cli
     b8e:	0f 92       	push	r0
     b90:	f8 01       	movw	r30, r16
     b92:	f2 8c       	ldd	r15, Z+26	; 0x1a
     b94:	ff 20       	and	r15, r15
     b96:	a9 f0       	breq	.+42     	; 0xbc2 <xQueueReceive+0x6e>
     b98:	b5 01       	movw	r22, r10
     b9a:	c8 01       	movw	r24, r16
     b9c:	0e 94 f5 03 	call	0x7ea	; 0x7ea <prvCopyDataFromQueue>
     ba0:	fa 94       	dec	r15
     ba2:	f8 01       	movw	r30, r16
     ba4:	f2 8e       	std	Z+26, r15	; 0x1a
     ba6:	80 85       	ldd	r24, Z+8	; 0x08
     ba8:	88 23       	and	r24, r24
     baa:	39 f0       	breq	.+14     	; 0xbba <xQueueReceive+0x66>
     bac:	c8 01       	movw	r24, r16
     bae:	08 96       	adiw	r24, 0x08	; 8
     bb0:	0e 94 8a 0a 	call	0x1514	; 0x1514 <xTaskRemoveFromEventList>
     bb4:	81 11       	cpse	r24, r1
     bb6:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vPortYield>
     bba:	0f 90       	pop	r0
     bbc:	0f be       	out	0x3f, r0	; 63
     bbe:	81 e0       	ldi	r24, 0x01	; 1
     bc0:	51 c0       	rjmp	.+162    	; 0xc64 <xQueueReceive+0x110>
     bc2:	8c 81       	ldd	r24, Y+4	; 0x04
     bc4:	9d 81       	ldd	r25, Y+5	; 0x05
     bc6:	89 2b       	or	r24, r25
     bc8:	21 f4       	brne	.+8      	; 0xbd2 <xQueueReceive+0x7e>
     bca:	0f 90       	pop	r0
     bcc:	0f be       	out	0x3f, r0	; 63
     bce:	80 e0       	ldi	r24, 0x00	; 0
     bd0:	49 c0       	rjmp	.+146    	; 0xc64 <xQueueReceive+0x110>
     bd2:	e1 10       	cpse	r14, r1
     bd4:	05 c0       	rjmp	.+10     	; 0xbe0 <xQueueReceive+0x8c>
     bd6:	ce 01       	movw	r24, r28
     bd8:	01 96       	adiw	r24, 0x01	; 1
     bda:	0e 94 d2 0a 	call	0x15a4	; 0x15a4 <vTaskInternalSetTimeOutState>
     bde:	e9 2c       	mov	r14, r9
     be0:	0f 90       	pop	r0
     be2:	0f be       	out	0x3f, r0	; 63
     be4:	0e 94 56 08 	call	0x10ac	; 0x10ac <vTaskSuspendAll>
     be8:	0f b6       	in	r0, 0x3f	; 63
     bea:	f8 94       	cli
     bec:	0f 92       	push	r0
     bee:	f8 01       	movw	r30, r16
     bf0:	85 8d       	ldd	r24, Z+29	; 0x1d
     bf2:	8f 3f       	cpi	r24, 0xFF	; 255
     bf4:	09 f4       	brne	.+2      	; 0xbf8 <xQueueReceive+0xa4>
     bf6:	15 8e       	std	Z+29, r1	; 0x1d
     bf8:	f8 01       	movw	r30, r16
     bfa:	86 8d       	ldd	r24, Z+30	; 0x1e
     bfc:	8f 3f       	cpi	r24, 0xFF	; 255
     bfe:	09 f4       	brne	.+2      	; 0xc02 <xQueueReceive+0xae>
     c00:	16 8e       	std	Z+30, r1	; 0x1e
     c02:	0f 90       	pop	r0
     c04:	0f be       	out	0x3f, r0	; 63
     c06:	be 01       	movw	r22, r28
     c08:	6c 5f       	subi	r22, 0xFC	; 252
     c0a:	7f 4f       	sbci	r23, 0xFF	; 255
     c0c:	ce 01       	movw	r24, r28
     c0e:	01 96       	adiw	r24, 0x01	; 1
     c10:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <xTaskCheckForTimeOut>
     c14:	81 11       	cpse	r24, r1
     c16:	1a c0       	rjmp	.+52     	; 0xc4c <xQueueReceive+0xf8>
     c18:	c8 01       	movw	r24, r16
     c1a:	0e 94 8b 03 	call	0x716	; 0x716 <prvIsQueueEmpty>
     c1e:	88 23       	and	r24, r24
     c20:	79 f0       	breq	.+30     	; 0xc40 <xQueueReceive+0xec>
     c22:	6c 81       	ldd	r22, Y+4	; 0x04
     c24:	7d 81       	ldd	r23, Y+5	; 0x05
     c26:	c6 01       	movw	r24, r12
     c28:	0e 94 5f 0a 	call	0x14be	; 0x14be <vTaskPlaceOnEventList>
     c2c:	c8 01       	movw	r24, r16
     c2e:	0e 94 0f 04 	call	0x81e	; 0x81e <prvUnlockQueue>
     c32:	0e 94 21 09 	call	0x1242	; 0x1242 <xTaskResumeAll>
     c36:	81 11       	cpse	r24, r1
     c38:	a8 cf       	rjmp	.-176    	; 0xb8a <xQueueReceive+0x36>
     c3a:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vPortYield>
     c3e:	a5 cf       	rjmp	.-182    	; 0xb8a <xQueueReceive+0x36>
     c40:	c8 01       	movw	r24, r16
     c42:	0e 94 0f 04 	call	0x81e	; 0x81e <prvUnlockQueue>
     c46:	0e 94 21 09 	call	0x1242	; 0x1242 <xTaskResumeAll>
     c4a:	9f cf       	rjmp	.-194    	; 0xb8a <xQueueReceive+0x36>
     c4c:	c8 01       	movw	r24, r16
     c4e:	0e 94 0f 04 	call	0x81e	; 0x81e <prvUnlockQueue>
     c52:	0e 94 21 09 	call	0x1242	; 0x1242 <xTaskResumeAll>
     c56:	c8 01       	movw	r24, r16
     c58:	0e 94 8b 03 	call	0x716	; 0x716 <prvIsQueueEmpty>
     c5c:	88 23       	and	r24, r24
     c5e:	09 f4       	brne	.+2      	; 0xc62 <xQueueReceive+0x10e>
     c60:	94 cf       	rjmp	.-216    	; 0xb8a <xQueueReceive+0x36>
     c62:	80 e0       	ldi	r24, 0x00	; 0
     c64:	0f 90       	pop	r0
     c66:	0f 90       	pop	r0
     c68:	0f 90       	pop	r0
     c6a:	0f 90       	pop	r0
     c6c:	0f 90       	pop	r0
     c6e:	df 91       	pop	r29
     c70:	cf 91       	pop	r28
     c72:	1f 91       	pop	r17
     c74:	0f 91       	pop	r16
     c76:	ff 90       	pop	r15
     c78:	ef 90       	pop	r14
     c7a:	df 90       	pop	r13
     c7c:	cf 90       	pop	r12
     c7e:	bf 90       	pop	r11
     c80:	af 90       	pop	r10
     c82:	9f 90       	pop	r9
     c84:	08 95       	ret

00000c86 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
     c86:	cf 93       	push	r28
     c88:	df 93       	push	r29
     c8a:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
     c8c:	0f b6       	in	r0, 0x3f	; 63
     c8e:	f8 94       	cli
     c90:	0f 92       	push	r0
     c92:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c94:	8f 3f       	cpi	r24, 0xFF	; 255
     c96:	09 f4       	brne	.+2      	; 0xc9a <vQueueWaitForMessageRestricted+0x14>
     c98:	1d 8e       	std	Y+29, r1	; 0x1d
     c9a:	8e 8d       	ldd	r24, Y+30	; 0x1e
     c9c:	8f 3f       	cpi	r24, 0xFF	; 255
     c9e:	09 f4       	brne	.+2      	; 0xca2 <vQueueWaitForMessageRestricted+0x1c>
     ca0:	1e 8e       	std	Y+30, r1	; 0x1e
     ca2:	0f 90       	pop	r0
     ca4:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
     ca6:	8a 8d       	ldd	r24, Y+26	; 0x1a
     ca8:	81 11       	cpse	r24, r1
     caa:	04 c0       	rjmp	.+8      	; 0xcb4 <vQueueWaitForMessageRestricted+0x2e>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
     cac:	ce 01       	movw	r24, r28
     cae:	41 96       	adiw	r24, 0x11	; 17
     cb0:	0e 94 71 0a 	call	0x14e2	; 0x14e2 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
     cb4:	ce 01       	movw	r24, r28
     cb6:	0e 94 0f 04 	call	0x81e	; 0x81e <prvUnlockQueue>
	}
     cba:	df 91       	pop	r29
     cbc:	cf 91       	pop	r28
     cbe:	08 95       	ret

00000cc0 <prvResetNextTaskUnblockTime>:
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
     cc0:	e0 91 62 01 	lds	r30, 0x0162	; 0x800162 <pxDelayedTaskList>
     cc4:	f0 91 63 01 	lds	r31, 0x0163	; 0x800163 <pxDelayedTaskList+0x1>
     cc8:	80 81       	ld	r24, Z
     cca:	81 11       	cpse	r24, r1
     ccc:	07 c0       	rjmp	.+14     	; 0xcdc <prvResetNextTaskUnblockTime+0x1c>
     cce:	8f ef       	ldi	r24, 0xFF	; 255
     cd0:	9f ef       	ldi	r25, 0xFF	; 255
     cd2:	90 93 3a 01 	sts	0x013A, r25	; 0x80013a <xNextTaskUnblockTime+0x1>
     cd6:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <xNextTaskUnblockTime>
     cda:	08 95       	ret
     cdc:	e0 91 62 01 	lds	r30, 0x0162	; 0x800162 <pxDelayedTaskList>
     ce0:	f0 91 63 01 	lds	r31, 0x0163	; 0x800163 <pxDelayedTaskList+0x1>
     ce4:	05 80       	ldd	r0, Z+5	; 0x05
     ce6:	f6 81       	ldd	r31, Z+6	; 0x06
     ce8:	e0 2d       	mov	r30, r0
     cea:	06 80       	ldd	r0, Z+6	; 0x06
     cec:	f7 81       	ldd	r31, Z+7	; 0x07
     cee:	e0 2d       	mov	r30, r0
     cf0:	82 81       	ldd	r24, Z+2	; 0x02
     cf2:	93 81       	ldd	r25, Z+3	; 0x03
     cf4:	90 93 3a 01 	sts	0x013A, r25	; 0x80013a <xNextTaskUnblockTime+0x1>
     cf8:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <xNextTaskUnblockTime>
     cfc:	08 95       	ret

00000cfe <prvAddCurrentTaskToDelayedList>:
     cfe:	ff 92       	push	r15
     d00:	0f 93       	push	r16
     d02:	1f 93       	push	r17
     d04:	cf 93       	push	r28
     d06:	df 93       	push	r29
     d08:	ec 01       	movw	r28, r24
     d0a:	f6 2e       	mov	r15, r22
     d0c:	00 91 41 01 	lds	r16, 0x0141	; 0x800141 <xTickCount>
     d10:	10 91 42 01 	lds	r17, 0x0142	; 0x800142 <xTickCount+0x1>
     d14:	80 91 88 01 	lds	r24, 0x0188	; 0x800188 <pxCurrentTCB>
     d18:	90 91 89 01 	lds	r25, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
     d1c:	02 96       	adiw	r24, 0x02	; 2
     d1e:	0e 94 19 01 	call	0x232	; 0x232 <uxListRemove>
     d22:	cf 3f       	cpi	r28, 0xFF	; 255
     d24:	8f ef       	ldi	r24, 0xFF	; 255
     d26:	d8 07       	cpc	r29, r24
     d28:	69 f4       	brne	.+26     	; 0xd44 <prvAddCurrentTaskToDelayedList+0x46>
     d2a:	ff 20       	and	r15, r15
     d2c:	59 f0       	breq	.+22     	; 0xd44 <prvAddCurrentTaskToDelayedList+0x46>
     d2e:	60 91 88 01 	lds	r22, 0x0188	; 0x800188 <pxCurrentTCB>
     d32:	70 91 89 01 	lds	r23, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
     d36:	6e 5f       	subi	r22, 0xFE	; 254
     d38:	7f 4f       	sbci	r23, 0xFF	; 255
     d3a:	84 e4       	ldi	r24, 0x44	; 68
     d3c:	91 e0       	ldi	r25, 0x01	; 1
     d3e:	0e 94 c7 00 	call	0x18e	; 0x18e <vListInsertEnd>
     d42:	2f c0       	rjmp	.+94     	; 0xda2 <prvAddCurrentTaskToDelayedList+0xa4>
     d44:	c0 0f       	add	r28, r16
     d46:	d1 1f       	adc	r29, r17
     d48:	e0 91 88 01 	lds	r30, 0x0188	; 0x800188 <pxCurrentTCB>
     d4c:	f0 91 89 01 	lds	r31, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
     d50:	d3 83       	std	Z+3, r29	; 0x03
     d52:	c2 83       	std	Z+2, r28	; 0x02
     d54:	c0 17       	cp	r28, r16
     d56:	d1 07       	cpc	r29, r17
     d58:	68 f4       	brcc	.+26     	; 0xd74 <prvAddCurrentTaskToDelayedList+0x76>
     d5a:	60 91 88 01 	lds	r22, 0x0188	; 0x800188 <pxCurrentTCB>
     d5e:	70 91 89 01 	lds	r23, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
     d62:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <pxOverflowDelayedTaskList>
     d66:	90 91 61 01 	lds	r25, 0x0161	; 0x800161 <pxOverflowDelayedTaskList+0x1>
     d6a:	6e 5f       	subi	r22, 0xFE	; 254
     d6c:	7f 4f       	sbci	r23, 0xFF	; 255
     d6e:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <vListInsert>
     d72:	17 c0       	rjmp	.+46     	; 0xda2 <prvAddCurrentTaskToDelayedList+0xa4>
     d74:	60 91 88 01 	lds	r22, 0x0188	; 0x800188 <pxCurrentTCB>
     d78:	70 91 89 01 	lds	r23, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
     d7c:	80 91 62 01 	lds	r24, 0x0162	; 0x800162 <pxDelayedTaskList>
     d80:	90 91 63 01 	lds	r25, 0x0163	; 0x800163 <pxDelayedTaskList+0x1>
     d84:	6e 5f       	subi	r22, 0xFE	; 254
     d86:	7f 4f       	sbci	r23, 0xFF	; 255
     d88:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <vListInsert>
     d8c:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <xNextTaskUnblockTime>
     d90:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <xNextTaskUnblockTime+0x1>
     d94:	c8 17       	cp	r28, r24
     d96:	d9 07       	cpc	r29, r25
     d98:	20 f4       	brcc	.+8      	; 0xda2 <prvAddCurrentTaskToDelayedList+0xa4>
     d9a:	d0 93 3a 01 	sts	0x013A, r29	; 0x80013a <xNextTaskUnblockTime+0x1>
     d9e:	c0 93 39 01 	sts	0x0139, r28	; 0x800139 <xNextTaskUnblockTime>
     da2:	df 91       	pop	r29
     da4:	cf 91       	pop	r28
     da6:	1f 91       	pop	r17
     da8:	0f 91       	pop	r16
     daa:	ff 90       	pop	r15
     dac:	08 95       	ret

00000dae <prvIdleTask>:
     dae:	0e e4       	ldi	r16, 0x4E	; 78
     db0:	11 e0       	ldi	r17, 0x01	; 1
     db2:	0f 2e       	mov	r0, r31
     db4:	f4 e6       	ldi	r31, 0x64	; 100
     db6:	ef 2e       	mov	r14, r31
     db8:	f1 e0       	ldi	r31, 0x01	; 1
     dba:	ff 2e       	mov	r15, r31
     dbc:	f0 2d       	mov	r31, r0
     dbe:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxDeletedTasksWaitingCleanUp>
     dc2:	88 23       	and	r24, r24
     dc4:	29 f1       	breq	.+74     	; 0xe10 <prvIdleTask+0x62>
     dc6:	0f b6       	in	r0, 0x3f	; 63
     dc8:	f8 94       	cli
     dca:	0f 92       	push	r0
     dcc:	d8 01       	movw	r26, r16
     dce:	15 96       	adiw	r26, 0x05	; 5
     dd0:	ed 91       	ld	r30, X+
     dd2:	fc 91       	ld	r31, X
     dd4:	16 97       	sbiw	r26, 0x06	; 6
     dd6:	c6 81       	ldd	r28, Z+6	; 0x06
     dd8:	d7 81       	ldd	r29, Z+7	; 0x07
     dda:	ce 01       	movw	r24, r28
     ddc:	02 96       	adiw	r24, 0x02	; 2
     dde:	0e 94 19 01 	call	0x232	; 0x232 <uxListRemove>
     de2:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <uxCurrentNumberOfTasks>
     de6:	81 50       	subi	r24, 0x01	; 1
     de8:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <uxCurrentNumberOfTasks>
     dec:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxDeletedTasksWaitingCleanUp>
     df0:	81 50       	subi	r24, 0x01	; 1
     df2:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <uxDeletedTasksWaitingCleanUp>
     df6:	0f 90       	pop	r0
     df8:	0f be       	out	0x3f, r0	; 63
     dfa:	8f 89       	ldd	r24, Y+23	; 0x17
     dfc:	98 8d       	ldd	r25, Y+24	; 0x18
     dfe:	0e 94 70 00 	call	0xe0	; 0xe0 <vPortFree>
     e02:	ce 01       	movw	r24, r28
     e04:	0e 94 70 00 	call	0xe0	; 0xe0 <vPortFree>
     e08:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxDeletedTasksWaitingCleanUp>
     e0c:	81 11       	cpse	r24, r1
     e0e:	db cf       	rjmp	.-74     	; 0xdc6 <prvIdleTask+0x18>
     e10:	f7 01       	movw	r30, r14
     e12:	80 81       	ld	r24, Z
     e14:	82 30       	cpi	r24, 0x02	; 2
     e16:	10 f0       	brcs	.+4      	; 0xe1c <prvIdleTask+0x6e>
     e18:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vPortYield>
     e1c:	0e 94 7f 00 	call	0xfe	; 0xfe <vApplicationIdleHook>
     e20:	ce cf       	rjmp	.-100    	; 0xdbe <prvIdleTask+0x10>

00000e22 <xTaskCreate>:
     e22:	4f 92       	push	r4
     e24:	5f 92       	push	r5
     e26:	6f 92       	push	r6
     e28:	7f 92       	push	r7
     e2a:	8f 92       	push	r8
     e2c:	9f 92       	push	r9
     e2e:	af 92       	push	r10
     e30:	bf 92       	push	r11
     e32:	cf 92       	push	r12
     e34:	df 92       	push	r13
     e36:	ef 92       	push	r14
     e38:	ff 92       	push	r15
     e3a:	0f 93       	push	r16
     e3c:	cf 93       	push	r28
     e3e:	df 93       	push	r29
     e40:	4c 01       	movw	r8, r24
     e42:	6b 01       	movw	r12, r22
     e44:	5a 01       	movw	r10, r20
     e46:	29 01       	movw	r4, r18
     e48:	ca 01       	movw	r24, r20
     e4a:	0e 94 5d 00 	call	0xba	; 0xba <pvPortMalloc>
     e4e:	3c 01       	movw	r6, r24
     e50:	89 2b       	or	r24, r25
     e52:	09 f4       	brne	.+2      	; 0xe56 <xTaskCreate+0x34>
     e54:	ec c0       	rjmp	.+472    	; 0x102e <xTaskCreate+0x20c>
     e56:	88 e2       	ldi	r24, 0x28	; 40
     e58:	90 e0       	ldi	r25, 0x00	; 0
     e5a:	0e 94 5d 00 	call	0xba	; 0xba <pvPortMalloc>
     e5e:	ec 01       	movw	r28, r24
     e60:	89 2b       	or	r24, r25
     e62:	b1 f0       	breq	.+44     	; 0xe90 <xTaskCreate+0x6e>
     e64:	78 8e       	std	Y+24, r7	; 0x18
     e66:	6f 8a       	std	Y+23, r6	; 0x17
     e68:	a5 01       	movw	r20, r10
     e6a:	65 ea       	ldi	r22, 0xA5	; 165
     e6c:	70 e0       	ldi	r23, 0x00	; 0
     e6e:	c3 01       	movw	r24, r6
     e70:	0e 94 b6 0e 	call	0x1d6c	; 0x1d6c <memset>
     e74:	81 e0       	ldi	r24, 0x01	; 1
     e76:	a8 1a       	sub	r10, r24
     e78:	b1 08       	sbc	r11, r1
     e7a:	8f 89       	ldd	r24, Y+23	; 0x17
     e7c:	98 8d       	ldd	r25, Y+24	; 0x18
     e7e:	a8 0e       	add	r10, r24
     e80:	b9 1e       	adc	r11, r25
     e82:	d6 01       	movw	r26, r12
     e84:	8c 91       	ld	r24, X
     e86:	89 8f       	std	Y+25, r24	; 0x19
     e88:	8c 91       	ld	r24, X
     e8a:	81 11       	cpse	r24, r1
     e8c:	05 c0       	rjmp	.+10     	; 0xe98 <xTaskCreate+0x76>
     e8e:	18 c0       	rjmp	.+48     	; 0xec0 <xTaskCreate+0x9e>
     e90:	c3 01       	movw	r24, r6
     e92:	0e 94 70 00 	call	0xe0	; 0xe0 <vPortFree>
     e96:	cb c0       	rjmp	.+406    	; 0x102e <xTaskCreate+0x20c>
     e98:	ae 01       	movw	r20, r28
     e9a:	46 5e       	subi	r20, 0xE6	; 230
     e9c:	5f 4f       	sbci	r21, 0xFF	; 255
     e9e:	f6 01       	movw	r30, r12
     ea0:	31 96       	adiw	r30, 0x01	; 1
     ea2:	b8 e0       	ldi	r27, 0x08	; 8
     ea4:	cb 0e       	add	r12, r27
     ea6:	d1 1c       	adc	r13, r1
     ea8:	cf 01       	movw	r24, r30
     eaa:	21 91       	ld	r18, Z+
     eac:	da 01       	movw	r26, r20
     eae:	2d 93       	st	X+, r18
     eb0:	ad 01       	movw	r20, r26
     eb2:	dc 01       	movw	r26, r24
     eb4:	8c 91       	ld	r24, X
     eb6:	88 23       	and	r24, r24
     eb8:	19 f0       	breq	.+6      	; 0xec0 <xTaskCreate+0x9e>
     eba:	ec 15       	cp	r30, r12
     ebc:	fd 05       	cpc	r31, r13
     ebe:	a1 f7       	brne	.-24     	; 0xea8 <xTaskCreate+0x86>
     ec0:	18 a2       	std	Y+32, r1	; 0x20
     ec2:	04 30       	cpi	r16, 0x04	; 4
     ec4:	08 f0       	brcs	.+2      	; 0xec8 <xTaskCreate+0xa6>
     ec6:	03 e0       	ldi	r16, 0x03	; 3
     ec8:	0e 8b       	std	Y+22, r16	; 0x16
     eca:	09 a3       	std	Y+33, r16	; 0x21
     ecc:	1a a2       	std	Y+34, r1	; 0x22
     ece:	6e 01       	movw	r12, r28
     ed0:	b2 e0       	ldi	r27, 0x02	; 2
     ed2:	cb 0e       	add	r12, r27
     ed4:	d1 1c       	adc	r13, r1
     ed6:	c6 01       	movw	r24, r12
     ed8:	0e 94 c3 00 	call	0x186	; 0x186 <vListInitialiseItem>
     edc:	ce 01       	movw	r24, r28
     ede:	0c 96       	adiw	r24, 0x0c	; 12
     ee0:	0e 94 c3 00 	call	0x186	; 0x186 <vListInitialiseItem>
     ee4:	d9 87       	std	Y+9, r29	; 0x09
     ee6:	c8 87       	std	Y+8, r28	; 0x08
     ee8:	84 e0       	ldi	r24, 0x04	; 4
     eea:	90 e0       	ldi	r25, 0x00	; 0
     eec:	80 1b       	sub	r24, r16
     eee:	91 09       	sbc	r25, r1
     ef0:	9d 87       	std	Y+13, r25	; 0x0d
     ef2:	8c 87       	std	Y+12, r24	; 0x0c
     ef4:	db 8b       	std	Y+19, r29	; 0x13
     ef6:	ca 8b       	std	Y+18, r28	; 0x12
     ef8:	1b a2       	std	Y+35, r1	; 0x23
     efa:	1c a2       	std	Y+36, r1	; 0x24
     efc:	1d a2       	std	Y+37, r1	; 0x25
     efe:	1e a2       	std	Y+38, r1	; 0x26
     f00:	1f a2       	std	Y+39, r1	; 0x27
     f02:	a2 01       	movw	r20, r4
     f04:	b4 01       	movw	r22, r8
     f06:	c5 01       	movw	r24, r10
     f08:	0e 94 2e 02 	call	0x45c	; 0x45c <pxPortInitialiseStack>
     f0c:	99 83       	std	Y+1, r25	; 0x01
     f0e:	88 83       	st	Y, r24
     f10:	e1 14       	cp	r14, r1
     f12:	f1 04       	cpc	r15, r1
     f14:	19 f0       	breq	.+6      	; 0xf1c <xTaskCreate+0xfa>
     f16:	f7 01       	movw	r30, r14
     f18:	d1 83       	std	Z+1, r29	; 0x01
     f1a:	c0 83       	st	Z, r28
     f1c:	0f b6       	in	r0, 0x3f	; 63
     f1e:	f8 94       	cli
     f20:	0f 92       	push	r0
     f22:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <uxCurrentNumberOfTasks>
     f26:	8f 5f       	subi	r24, 0xFF	; 255
     f28:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <uxCurrentNumberOfTasks>
     f2c:	80 91 88 01 	lds	r24, 0x0188	; 0x800188 <pxCurrentTCB>
     f30:	90 91 89 01 	lds	r25, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
     f34:	89 2b       	or	r24, r25
     f36:	d1 f5       	brne	.+116    	; 0xfac <xTaskCreate+0x18a>
     f38:	d0 93 89 01 	sts	0x0189, r29	; 0x800189 <pxCurrentTCB+0x1>
     f3c:	c0 93 88 01 	sts	0x0188, r28	; 0x800188 <pxCurrentTCB>
     f40:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <uxCurrentNumberOfTasks>
     f44:	81 30       	cpi	r24, 0x01	; 1
     f46:	09 f0       	breq	.+2      	; 0xf4a <xTaskCreate+0x128>
     f48:	41 c0       	rjmp	.+130    	; 0xfcc <xTaskCreate+0x1aa>
     f4a:	84 e6       	ldi	r24, 0x64	; 100
     f4c:	91 e0       	ldi	r25, 0x01	; 1
     f4e:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     f52:	8d e6       	ldi	r24, 0x6D	; 109
     f54:	91 e0       	ldi	r25, 0x01	; 1
     f56:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     f5a:	86 e7       	ldi	r24, 0x76	; 118
     f5c:	91 e0       	ldi	r25, 0x01	; 1
     f5e:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     f62:	8f e7       	ldi	r24, 0x7F	; 127
     f64:	91 e0       	ldi	r25, 0x01	; 1
     f66:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     f6a:	8d e2       	ldi	r24, 0x2D	; 45
     f6c:	91 e0       	ldi	r25, 0x01	; 1
     f6e:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     f72:	84 e2       	ldi	r24, 0x24	; 36
     f74:	91 e0       	ldi	r25, 0x01	; 1
     f76:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     f7a:	87 e5       	ldi	r24, 0x57	; 87
     f7c:	91 e0       	ldi	r25, 0x01	; 1
     f7e:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     f82:	8e e4       	ldi	r24, 0x4E	; 78
     f84:	91 e0       	ldi	r25, 0x01	; 1
     f86:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     f8a:	84 e4       	ldi	r24, 0x44	; 68
     f8c:	91 e0       	ldi	r25, 0x01	; 1
     f8e:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     f92:	8d e2       	ldi	r24, 0x2D	; 45
     f94:	91 e0       	ldi	r25, 0x01	; 1
     f96:	90 93 63 01 	sts	0x0163, r25	; 0x800163 <pxDelayedTaskList+0x1>
     f9a:	80 93 62 01 	sts	0x0162, r24	; 0x800162 <pxDelayedTaskList>
     f9e:	84 e2       	ldi	r24, 0x24	; 36
     fa0:	91 e0       	ldi	r25, 0x01	; 1
     fa2:	90 93 61 01 	sts	0x0161, r25	; 0x800161 <pxOverflowDelayedTaskList+0x1>
     fa6:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <pxOverflowDelayedTaskList>
     faa:	10 c0       	rjmp	.+32     	; 0xfcc <xTaskCreate+0x1aa>
     fac:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <xSchedulerRunning>
     fb0:	81 11       	cpse	r24, r1
     fb2:	0c c0       	rjmp	.+24     	; 0xfcc <xTaskCreate+0x1aa>
     fb4:	e0 91 88 01 	lds	r30, 0x0188	; 0x800188 <pxCurrentTCB>
     fb8:	f0 91 89 01 	lds	r31, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
     fbc:	96 89       	ldd	r25, Z+22	; 0x16
     fbe:	8e 89       	ldd	r24, Y+22	; 0x16
     fc0:	89 17       	cp	r24, r25
     fc2:	20 f0       	brcs	.+8      	; 0xfcc <xTaskCreate+0x1aa>
     fc4:	d0 93 89 01 	sts	0x0189, r29	; 0x800189 <pxCurrentTCB+0x1>
     fc8:	c0 93 88 01 	sts	0x0188, r28	; 0x800188 <pxCurrentTCB>
     fcc:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <uxTaskNumber>
     fd0:	8f 5f       	subi	r24, 0xFF	; 255
     fd2:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <uxTaskNumber>
     fd6:	8e 89       	ldd	r24, Y+22	; 0x16
     fd8:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <uxTopReadyPriority>
     fdc:	98 17       	cp	r25, r24
     fde:	10 f4       	brcc	.+4      	; 0xfe4 <xTaskCreate+0x1c2>
     fe0:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <uxTopReadyPriority>
     fe4:	90 e0       	ldi	r25, 0x00	; 0
     fe6:	9c 01       	movw	r18, r24
     fe8:	22 0f       	add	r18, r18
     fea:	33 1f       	adc	r19, r19
     fec:	22 0f       	add	r18, r18
     fee:	33 1f       	adc	r19, r19
     ff0:	22 0f       	add	r18, r18
     ff2:	33 1f       	adc	r19, r19
     ff4:	82 0f       	add	r24, r18
     ff6:	93 1f       	adc	r25, r19
     ff8:	b6 01       	movw	r22, r12
     ffa:	8c 59       	subi	r24, 0x9C	; 156
     ffc:	9e 4f       	sbci	r25, 0xFE	; 254
     ffe:	0e 94 c7 00 	call	0x18e	; 0x18e <vListInsertEnd>
    1002:	0f 90       	pop	r0
    1004:	0f be       	out	0x3f, r0	; 63
    1006:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <xSchedulerRunning>
    100a:	88 23       	and	r24, r24
    100c:	61 f0       	breq	.+24     	; 0x1026 <xTaskCreate+0x204>
    100e:	e0 91 88 01 	lds	r30, 0x0188	; 0x800188 <pxCurrentTCB>
    1012:	f0 91 89 01 	lds	r31, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    1016:	96 89       	ldd	r25, Z+22	; 0x16
    1018:	8e 89       	ldd	r24, Y+22	; 0x16
    101a:	98 17       	cp	r25, r24
    101c:	30 f4       	brcc	.+12     	; 0x102a <xTaskCreate+0x208>
    101e:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vPortYield>
    1022:	81 e0       	ldi	r24, 0x01	; 1
    1024:	05 c0       	rjmp	.+10     	; 0x1030 <xTaskCreate+0x20e>
    1026:	81 e0       	ldi	r24, 0x01	; 1
    1028:	03 c0       	rjmp	.+6      	; 0x1030 <xTaskCreate+0x20e>
    102a:	81 e0       	ldi	r24, 0x01	; 1
    102c:	01 c0       	rjmp	.+2      	; 0x1030 <xTaskCreate+0x20e>
    102e:	8f ef       	ldi	r24, 0xFF	; 255
    1030:	df 91       	pop	r29
    1032:	cf 91       	pop	r28
    1034:	0f 91       	pop	r16
    1036:	ff 90       	pop	r15
    1038:	ef 90       	pop	r14
    103a:	df 90       	pop	r13
    103c:	cf 90       	pop	r12
    103e:	bf 90       	pop	r11
    1040:	af 90       	pop	r10
    1042:	9f 90       	pop	r9
    1044:	8f 90       	pop	r8
    1046:	7f 90       	pop	r7
    1048:	6f 90       	pop	r6
    104a:	5f 90       	pop	r5
    104c:	4f 90       	pop	r4
    104e:	08 95       	ret

00001050 <vTaskStartScheduler>:
    1050:	ef 92       	push	r14
    1052:	ff 92       	push	r15
    1054:	0f 93       	push	r16
    1056:	0f 2e       	mov	r0, r31
    1058:	f7 e3       	ldi	r31, 0x37	; 55
    105a:	ef 2e       	mov	r14, r31
    105c:	f1 e0       	ldi	r31, 0x01	; 1
    105e:	ff 2e       	mov	r15, r31
    1060:	f0 2d       	mov	r31, r0
    1062:	00 e0       	ldi	r16, 0x00	; 0
    1064:	20 e0       	ldi	r18, 0x00	; 0
    1066:	30 e0       	ldi	r19, 0x00	; 0
    1068:	45 e5       	ldi	r20, 0x55	; 85
    106a:	50 e0       	ldi	r21, 0x00	; 0
    106c:	66 e1       	ldi	r22, 0x16	; 22
    106e:	71 e0       	ldi	r23, 0x01	; 1
    1070:	87 ed       	ldi	r24, 0xD7	; 215
    1072:	96 e0       	ldi	r25, 0x06	; 6
    1074:	0e 94 11 07 	call	0xe22	; 0xe22 <xTaskCreate>
    1078:	81 30       	cpi	r24, 0x01	; 1
    107a:	a1 f4       	brne	.+40     	; 0x10a4 <vTaskStartScheduler+0x54>
    107c:	0e 94 bd 0b 	call	0x177a	; 0x177a <xTimerCreateTimerTask>
    1080:	81 30       	cpi	r24, 0x01	; 1
    1082:	81 f4       	brne	.+32     	; 0x10a4 <vTaskStartScheduler+0x54>
    1084:	f8 94       	cli
    1086:	8f ef       	ldi	r24, 0xFF	; 255
    1088:	9f ef       	ldi	r25, 0xFF	; 255
    108a:	90 93 3a 01 	sts	0x013A, r25	; 0x80013a <xNextTaskUnblockTime+0x1>
    108e:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <xNextTaskUnblockTime>
    1092:	81 e0       	ldi	r24, 0x01	; 1
    1094:	80 93 3f 01 	sts	0x013F, r24	; 0x80013f <xSchedulerRunning>
    1098:	10 92 42 01 	sts	0x0142, r1	; 0x800142 <xTickCount+0x1>
    109c:	10 92 41 01 	sts	0x0141, r1	; 0x800141 <xTickCount>
    10a0:	0e 94 9a 02 	call	0x534	; 0x534 <xPortStartScheduler>
    10a4:	0f 91       	pop	r16
    10a6:	ff 90       	pop	r15
    10a8:	ef 90       	pop	r14
    10aa:	08 95       	ret

000010ac <vTaskSuspendAll>:
    10ac:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uxSchedulerSuspended>
    10b0:	8f 5f       	subi	r24, 0xFF	; 255
    10b2:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <uxSchedulerSuspended>
    10b6:	08 95       	ret

000010b8 <xTaskGetTickCount>:
    10b8:	0f b6       	in	r0, 0x3f	; 63
    10ba:	f8 94       	cli
    10bc:	0f 92       	push	r0
    10be:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <xTickCount>
    10c2:	90 91 42 01 	lds	r25, 0x0142	; 0x800142 <xTickCount+0x1>
    10c6:	0f 90       	pop	r0
    10c8:	0f be       	out	0x3f, r0	; 63
    10ca:	08 95       	ret

000010cc <xTaskIncrementTick>:
    10cc:	cf 92       	push	r12
    10ce:	df 92       	push	r13
    10d0:	ef 92       	push	r14
    10d2:	ff 92       	push	r15
    10d4:	0f 93       	push	r16
    10d6:	1f 93       	push	r17
    10d8:	cf 93       	push	r28
    10da:	df 93       	push	r29
    10dc:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uxSchedulerSuspended>
    10e0:	81 11       	cpse	r24, r1
    10e2:	99 c0       	rjmp	.+306    	; 0x1216 <xTaskIncrementTick+0x14a>
    10e4:	e0 90 41 01 	lds	r14, 0x0141	; 0x800141 <xTickCount>
    10e8:	f0 90 42 01 	lds	r15, 0x0142	; 0x800142 <xTickCount+0x1>
    10ec:	8f ef       	ldi	r24, 0xFF	; 255
    10ee:	e8 1a       	sub	r14, r24
    10f0:	f8 0a       	sbc	r15, r24
    10f2:	f0 92 42 01 	sts	0x0142, r15	; 0x800142 <xTickCount+0x1>
    10f6:	e0 92 41 01 	sts	0x0141, r14	; 0x800141 <xTickCount>
    10fa:	e1 14       	cp	r14, r1
    10fc:	f1 04       	cpc	r15, r1
    10fe:	b9 f4       	brne	.+46     	; 0x112e <xTaskIncrementTick+0x62>
    1100:	80 91 62 01 	lds	r24, 0x0162	; 0x800162 <pxDelayedTaskList>
    1104:	90 91 63 01 	lds	r25, 0x0163	; 0x800163 <pxDelayedTaskList+0x1>
    1108:	20 91 60 01 	lds	r18, 0x0160	; 0x800160 <pxOverflowDelayedTaskList>
    110c:	30 91 61 01 	lds	r19, 0x0161	; 0x800161 <pxOverflowDelayedTaskList+0x1>
    1110:	30 93 63 01 	sts	0x0163, r19	; 0x800163 <pxDelayedTaskList+0x1>
    1114:	20 93 62 01 	sts	0x0162, r18	; 0x800162 <pxDelayedTaskList>
    1118:	90 93 61 01 	sts	0x0161, r25	; 0x800161 <pxOverflowDelayedTaskList+0x1>
    111c:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <pxOverflowDelayedTaskList>
    1120:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <xNumOfOverflows>
    1124:	8f 5f       	subi	r24, 0xFF	; 255
    1126:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <xNumOfOverflows>
    112a:	0e 94 60 06 	call	0xcc0	; 0xcc0 <prvResetNextTaskUnblockTime>
    112e:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <xNextTaskUnblockTime>
    1132:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <xNextTaskUnblockTime+0x1>
    1136:	e8 16       	cp	r14, r24
    1138:	f9 06       	cpc	r15, r25
    113a:	10 f4       	brcc	.+4      	; 0x1140 <xTaskIncrementTick+0x74>
    113c:	d1 2c       	mov	r13, r1
    113e:	53 c0       	rjmp	.+166    	; 0x11e6 <xTaskIncrementTick+0x11a>
    1140:	d1 2c       	mov	r13, r1
    1142:	cc 24       	eor	r12, r12
    1144:	c3 94       	inc	r12
    1146:	e0 91 62 01 	lds	r30, 0x0162	; 0x800162 <pxDelayedTaskList>
    114a:	f0 91 63 01 	lds	r31, 0x0163	; 0x800163 <pxDelayedTaskList+0x1>
    114e:	80 81       	ld	r24, Z
    1150:	81 11       	cpse	r24, r1
    1152:	07 c0       	rjmp	.+14     	; 0x1162 <xTaskIncrementTick+0x96>
    1154:	8f ef       	ldi	r24, 0xFF	; 255
    1156:	9f ef       	ldi	r25, 0xFF	; 255
    1158:	90 93 3a 01 	sts	0x013A, r25	; 0x80013a <xNextTaskUnblockTime+0x1>
    115c:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <xNextTaskUnblockTime>
    1160:	42 c0       	rjmp	.+132    	; 0x11e6 <xTaskIncrementTick+0x11a>
    1162:	e0 91 62 01 	lds	r30, 0x0162	; 0x800162 <pxDelayedTaskList>
    1166:	f0 91 63 01 	lds	r31, 0x0163	; 0x800163 <pxDelayedTaskList+0x1>
    116a:	05 80       	ldd	r0, Z+5	; 0x05
    116c:	f6 81       	ldd	r31, Z+6	; 0x06
    116e:	e0 2d       	mov	r30, r0
    1170:	c6 81       	ldd	r28, Z+6	; 0x06
    1172:	d7 81       	ldd	r29, Z+7	; 0x07
    1174:	8a 81       	ldd	r24, Y+2	; 0x02
    1176:	9b 81       	ldd	r25, Y+3	; 0x03
    1178:	e8 16       	cp	r14, r24
    117a:	f9 06       	cpc	r15, r25
    117c:	28 f4       	brcc	.+10     	; 0x1188 <xTaskIncrementTick+0xbc>
    117e:	90 93 3a 01 	sts	0x013A, r25	; 0x80013a <xNextTaskUnblockTime+0x1>
    1182:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <xNextTaskUnblockTime>
    1186:	2f c0       	rjmp	.+94     	; 0x11e6 <xTaskIncrementTick+0x11a>
    1188:	8e 01       	movw	r16, r28
    118a:	0e 5f       	subi	r16, 0xFE	; 254
    118c:	1f 4f       	sbci	r17, 0xFF	; 255
    118e:	c8 01       	movw	r24, r16
    1190:	0e 94 19 01 	call	0x232	; 0x232 <uxListRemove>
    1194:	8c 89       	ldd	r24, Y+20	; 0x14
    1196:	9d 89       	ldd	r25, Y+21	; 0x15
    1198:	89 2b       	or	r24, r25
    119a:	21 f0       	breq	.+8      	; 0x11a4 <xTaskIncrementTick+0xd8>
    119c:	ce 01       	movw	r24, r28
    119e:	0c 96       	adiw	r24, 0x0c	; 12
    11a0:	0e 94 19 01 	call	0x232	; 0x232 <uxListRemove>
    11a4:	8e 89       	ldd	r24, Y+22	; 0x16
    11a6:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <uxTopReadyPriority>
    11aa:	98 17       	cp	r25, r24
    11ac:	10 f4       	brcc	.+4      	; 0x11b2 <xTaskIncrementTick+0xe6>
    11ae:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <uxTopReadyPriority>
    11b2:	90 e0       	ldi	r25, 0x00	; 0
    11b4:	9c 01       	movw	r18, r24
    11b6:	22 0f       	add	r18, r18
    11b8:	33 1f       	adc	r19, r19
    11ba:	22 0f       	add	r18, r18
    11bc:	33 1f       	adc	r19, r19
    11be:	22 0f       	add	r18, r18
    11c0:	33 1f       	adc	r19, r19
    11c2:	82 0f       	add	r24, r18
    11c4:	93 1f       	adc	r25, r19
    11c6:	b8 01       	movw	r22, r16
    11c8:	8c 59       	subi	r24, 0x9C	; 156
    11ca:	9e 4f       	sbci	r25, 0xFE	; 254
    11cc:	0e 94 c7 00 	call	0x18e	; 0x18e <vListInsertEnd>
    11d0:	e0 91 88 01 	lds	r30, 0x0188	; 0x800188 <pxCurrentTCB>
    11d4:	f0 91 89 01 	lds	r31, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    11d8:	9e 89       	ldd	r25, Y+22	; 0x16
    11da:	86 89       	ldd	r24, Z+22	; 0x16
    11dc:	98 17       	cp	r25, r24
    11de:	08 f4       	brcc	.+2      	; 0x11e2 <xTaskIncrementTick+0x116>
    11e0:	b2 cf       	rjmp	.-156    	; 0x1146 <xTaskIncrementTick+0x7a>
    11e2:	dc 2c       	mov	r13, r12
    11e4:	b0 cf       	rjmp	.-160    	; 0x1146 <xTaskIncrementTick+0x7a>
    11e6:	e0 91 88 01 	lds	r30, 0x0188	; 0x800188 <pxCurrentTCB>
    11ea:	f0 91 89 01 	lds	r31, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    11ee:	86 89       	ldd	r24, Z+22	; 0x16
    11f0:	90 e0       	ldi	r25, 0x00	; 0
    11f2:	fc 01       	movw	r30, r24
    11f4:	ee 0f       	add	r30, r30
    11f6:	ff 1f       	adc	r31, r31
    11f8:	ee 0f       	add	r30, r30
    11fa:	ff 1f       	adc	r31, r31
    11fc:	ee 0f       	add	r30, r30
    11fe:	ff 1f       	adc	r31, r31
    1200:	8e 0f       	add	r24, r30
    1202:	9f 1f       	adc	r25, r31
    1204:	fc 01       	movw	r30, r24
    1206:	ec 59       	subi	r30, 0x9C	; 156
    1208:	fe 4f       	sbci	r31, 0xFE	; 254
    120a:	80 81       	ld	r24, Z
    120c:	82 30       	cpi	r24, 0x02	; 2
    120e:	48 f0       	brcs	.+18     	; 0x1222 <xTaskIncrementTick+0x156>
    1210:	dd 24       	eor	r13, r13
    1212:	d3 94       	inc	r13
    1214:	06 c0       	rjmp	.+12     	; 0x1222 <xTaskIncrementTick+0x156>
    1216:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <uxPendedTicks>
    121a:	8f 5f       	subi	r24, 0xFF	; 255
    121c:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <uxPendedTicks>
    1220:	d1 2c       	mov	r13, r1
    1222:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <xYieldPending>
    1226:	88 23       	and	r24, r24
    1228:	11 f0       	breq	.+4      	; 0x122e <xTaskIncrementTick+0x162>
    122a:	dd 24       	eor	r13, r13
    122c:	d3 94       	inc	r13
    122e:	8d 2d       	mov	r24, r13
    1230:	df 91       	pop	r29
    1232:	cf 91       	pop	r28
    1234:	1f 91       	pop	r17
    1236:	0f 91       	pop	r16
    1238:	ff 90       	pop	r15
    123a:	ef 90       	pop	r14
    123c:	df 90       	pop	r13
    123e:	cf 90       	pop	r12
    1240:	08 95       	ret

00001242 <xTaskResumeAll>:
    1242:	df 92       	push	r13
    1244:	ef 92       	push	r14
    1246:	ff 92       	push	r15
    1248:	0f 93       	push	r16
    124a:	1f 93       	push	r17
    124c:	cf 93       	push	r28
    124e:	df 93       	push	r29
    1250:	0f b6       	in	r0, 0x3f	; 63
    1252:	f8 94       	cli
    1254:	0f 92       	push	r0
    1256:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uxSchedulerSuspended>
    125a:	81 50       	subi	r24, 0x01	; 1
    125c:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <uxSchedulerSuspended>
    1260:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uxSchedulerSuspended>
    1264:	81 11       	cpse	r24, r1
    1266:	5f c0       	rjmp	.+190    	; 0x1326 <xTaskResumeAll+0xe4>
    1268:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <uxCurrentNumberOfTasks>
    126c:	81 11       	cpse	r24, r1
    126e:	33 c0       	rjmp	.+102    	; 0x12d6 <xTaskResumeAll+0x94>
    1270:	5d c0       	rjmp	.+186    	; 0x132c <xTaskResumeAll+0xea>
    1272:	d7 01       	movw	r26, r14
    1274:	15 96       	adiw	r26, 0x05	; 5
    1276:	ed 91       	ld	r30, X+
    1278:	fc 91       	ld	r31, X
    127a:	16 97       	sbiw	r26, 0x06	; 6
    127c:	c6 81       	ldd	r28, Z+6	; 0x06
    127e:	d7 81       	ldd	r29, Z+7	; 0x07
    1280:	ce 01       	movw	r24, r28
    1282:	0c 96       	adiw	r24, 0x0c	; 12
    1284:	0e 94 19 01 	call	0x232	; 0x232 <uxListRemove>
    1288:	8e 01       	movw	r16, r28
    128a:	0e 5f       	subi	r16, 0xFE	; 254
    128c:	1f 4f       	sbci	r17, 0xFF	; 255
    128e:	c8 01       	movw	r24, r16
    1290:	0e 94 19 01 	call	0x232	; 0x232 <uxListRemove>
    1294:	8e 89       	ldd	r24, Y+22	; 0x16
    1296:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <uxTopReadyPriority>
    129a:	98 17       	cp	r25, r24
    129c:	10 f4       	brcc	.+4      	; 0x12a2 <xTaskResumeAll+0x60>
    129e:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <uxTopReadyPriority>
    12a2:	90 e0       	ldi	r25, 0x00	; 0
    12a4:	9c 01       	movw	r18, r24
    12a6:	22 0f       	add	r18, r18
    12a8:	33 1f       	adc	r19, r19
    12aa:	22 0f       	add	r18, r18
    12ac:	33 1f       	adc	r19, r19
    12ae:	22 0f       	add	r18, r18
    12b0:	33 1f       	adc	r19, r19
    12b2:	82 0f       	add	r24, r18
    12b4:	93 1f       	adc	r25, r19
    12b6:	b8 01       	movw	r22, r16
    12b8:	8c 59       	subi	r24, 0x9C	; 156
    12ba:	9e 4f       	sbci	r25, 0xFE	; 254
    12bc:	0e 94 c7 00 	call	0x18e	; 0x18e <vListInsertEnd>
    12c0:	e0 91 88 01 	lds	r30, 0x0188	; 0x800188 <pxCurrentTCB>
    12c4:	f0 91 89 01 	lds	r31, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    12c8:	9e 89       	ldd	r25, Y+22	; 0x16
    12ca:	86 89       	ldd	r24, Z+22	; 0x16
    12cc:	98 17       	cp	r25, r24
    12ce:	68 f0       	brcs	.+26     	; 0x12ea <xTaskResumeAll+0xa8>
    12d0:	d0 92 3d 01 	sts	0x013D, r13	; 0x80013d <xYieldPending>
    12d4:	0a c0       	rjmp	.+20     	; 0x12ea <xTaskResumeAll+0xa8>
    12d6:	c0 e0       	ldi	r28, 0x00	; 0
    12d8:	d0 e0       	ldi	r29, 0x00	; 0
    12da:	0f 2e       	mov	r0, r31
    12dc:	f7 e5       	ldi	r31, 0x57	; 87
    12de:	ef 2e       	mov	r14, r31
    12e0:	f1 e0       	ldi	r31, 0x01	; 1
    12e2:	ff 2e       	mov	r15, r31
    12e4:	f0 2d       	mov	r31, r0
    12e6:	dd 24       	eor	r13, r13
    12e8:	d3 94       	inc	r13
    12ea:	f7 01       	movw	r30, r14
    12ec:	80 81       	ld	r24, Z
    12ee:	81 11       	cpse	r24, r1
    12f0:	c0 cf       	rjmp	.-128    	; 0x1272 <xTaskResumeAll+0x30>
    12f2:	cd 2b       	or	r28, r29
    12f4:	11 f0       	breq	.+4      	; 0x12fa <xTaskResumeAll+0xb8>
    12f6:	0e 94 60 06 	call	0xcc0	; 0xcc0 <prvResetNextTaskUnblockTime>
    12fa:	c0 91 3e 01 	lds	r28, 0x013E	; 0x80013e <uxPendedTicks>
    12fe:	cc 23       	and	r28, r28
    1300:	51 f0       	breq	.+20     	; 0x1316 <xTaskResumeAll+0xd4>
    1302:	d1 e0       	ldi	r29, 0x01	; 1
    1304:	0e 94 66 08 	call	0x10cc	; 0x10cc <xTaskIncrementTick>
    1308:	81 11       	cpse	r24, r1
    130a:	d0 93 3d 01 	sts	0x013D, r29	; 0x80013d <xYieldPending>
    130e:	c1 50       	subi	r28, 0x01	; 1
    1310:	c9 f7       	brne	.-14     	; 0x1304 <xTaskResumeAll+0xc2>
    1312:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <uxPendedTicks>
    1316:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <xYieldPending>
    131a:	88 23       	and	r24, r24
    131c:	31 f0       	breq	.+12     	; 0x132a <xTaskResumeAll+0xe8>
    131e:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vPortYield>
    1322:	81 e0       	ldi	r24, 0x01	; 1
    1324:	03 c0       	rjmp	.+6      	; 0x132c <xTaskResumeAll+0xea>
    1326:	80 e0       	ldi	r24, 0x00	; 0
    1328:	01 c0       	rjmp	.+2      	; 0x132c <xTaskResumeAll+0xea>
    132a:	80 e0       	ldi	r24, 0x00	; 0
    132c:	0f 90       	pop	r0
    132e:	0f be       	out	0x3f, r0	; 63
    1330:	df 91       	pop	r29
    1332:	cf 91       	pop	r28
    1334:	1f 91       	pop	r17
    1336:	0f 91       	pop	r16
    1338:	ff 90       	pop	r15
    133a:	ef 90       	pop	r14
    133c:	df 90       	pop	r13
    133e:	08 95       	ret

00001340 <vTaskDelayUntil>:
    1340:	0f 93       	push	r16
    1342:	1f 93       	push	r17
    1344:	cf 93       	push	r28
    1346:	df 93       	push	r29
    1348:	8c 01       	movw	r16, r24
    134a:	eb 01       	movw	r28, r22
    134c:	0e 94 56 08 	call	0x10ac	; 0x10ac <vTaskSuspendAll>
    1350:	40 91 41 01 	lds	r20, 0x0141	; 0x800141 <xTickCount>
    1354:	50 91 42 01 	lds	r21, 0x0142	; 0x800142 <xTickCount+0x1>
    1358:	f8 01       	movw	r30, r16
    135a:	20 81       	ld	r18, Z
    135c:	31 81       	ldd	r19, Z+1	; 0x01
    135e:	c9 01       	movw	r24, r18
    1360:	8c 0f       	add	r24, r28
    1362:	9d 1f       	adc	r25, r29
    1364:	42 17       	cp	r20, r18
    1366:	53 07       	cpc	r21, r19
    1368:	48 f4       	brcc	.+18     	; 0x137c <vTaskDelayUntil+0x3c>
    136a:	82 17       	cp	r24, r18
    136c:	93 07       	cpc	r25, r19
    136e:	e8 f4       	brcc	.+58     	; 0x13aa <vTaskDelayUntil+0x6a>
    1370:	91 83       	std	Z+1, r25	; 0x01
    1372:	80 83       	st	Z, r24
    1374:	48 17       	cp	r20, r24
    1376:	59 07       	cpc	r21, r25
    1378:	68 f4       	brcc	.+26     	; 0x1394 <vTaskDelayUntil+0x54>
    137a:	07 c0       	rjmp	.+14     	; 0x138a <vTaskDelayUntil+0x4a>
    137c:	82 17       	cp	r24, r18
    137e:	93 07       	cpc	r25, r19
    1380:	80 f0       	brcs	.+32     	; 0x13a2 <vTaskDelayUntil+0x62>
    1382:	48 17       	cp	r20, r24
    1384:	59 07       	cpc	r21, r25
    1386:	68 f0       	brcs	.+26     	; 0x13a2 <vTaskDelayUntil+0x62>
    1388:	10 c0       	rjmp	.+32     	; 0x13aa <vTaskDelayUntil+0x6a>
    138a:	60 e0       	ldi	r22, 0x00	; 0
    138c:	84 1b       	sub	r24, r20
    138e:	95 0b       	sbc	r25, r21
    1390:	0e 94 7f 06 	call	0xcfe	; 0xcfe <prvAddCurrentTaskToDelayedList>
    1394:	0e 94 21 09 	call	0x1242	; 0x1242 <xTaskResumeAll>
    1398:	81 11       	cpse	r24, r1
    139a:	0b c0       	rjmp	.+22     	; 0x13b2 <vTaskDelayUntil+0x72>
    139c:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vPortYield>
    13a0:	08 c0       	rjmp	.+16     	; 0x13b2 <vTaskDelayUntil+0x72>
    13a2:	f8 01       	movw	r30, r16
    13a4:	91 83       	std	Z+1, r25	; 0x01
    13a6:	80 83       	st	Z, r24
    13a8:	f0 cf       	rjmp	.-32     	; 0x138a <vTaskDelayUntil+0x4a>
    13aa:	f8 01       	movw	r30, r16
    13ac:	91 83       	std	Z+1, r25	; 0x01
    13ae:	80 83       	st	Z, r24
    13b0:	f1 cf       	rjmp	.-30     	; 0x1394 <vTaskDelayUntil+0x54>
    13b2:	df 91       	pop	r29
    13b4:	cf 91       	pop	r28
    13b6:	1f 91       	pop	r17
    13b8:	0f 91       	pop	r16
    13ba:	08 95       	ret

000013bc <vTaskSwitchContext>:
    13bc:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uxSchedulerSuspended>
    13c0:	88 23       	and	r24, r24
    13c2:	21 f0       	breq	.+8      	; 0x13cc <vTaskSwitchContext+0x10>
    13c4:	81 e0       	ldi	r24, 0x01	; 1
    13c6:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <xYieldPending>
    13ca:	08 95       	ret
    13cc:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <xYieldPending>
    13d0:	a0 91 88 01 	lds	r26, 0x0188	; 0x800188 <pxCurrentTCB>
    13d4:	b0 91 89 01 	lds	r27, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    13d8:	e0 91 88 01 	lds	r30, 0x0188	; 0x800188 <pxCurrentTCB>
    13dc:	f0 91 89 01 	lds	r31, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    13e0:	2d 91       	ld	r18, X+
    13e2:	3c 91       	ld	r19, X
    13e4:	87 89       	ldd	r24, Z+23	; 0x17
    13e6:	90 8d       	ldd	r25, Z+24	; 0x18
    13e8:	82 17       	cp	r24, r18
    13ea:	93 07       	cpc	r25, r19
    13ec:	60 f0       	brcs	.+24     	; 0x1406 <vTaskSwitchContext+0x4a>
    13ee:	60 91 88 01 	lds	r22, 0x0188	; 0x800188 <pxCurrentTCB>
    13f2:	70 91 89 01 	lds	r23, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    13f6:	80 91 88 01 	lds	r24, 0x0188	; 0x800188 <pxCurrentTCB>
    13fa:	90 91 89 01 	lds	r25, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    13fe:	67 5e       	subi	r22, 0xE7	; 231
    1400:	7f 4f       	sbci	r23, 0xFF	; 255
    1402:	0e 94 a8 00 	call	0x150	; 0x150 <vApplicationStackOverflowHook>
    1406:	20 91 40 01 	lds	r18, 0x0140	; 0x800140 <uxTopReadyPriority>
    140a:	82 2f       	mov	r24, r18
    140c:	90 e0       	ldi	r25, 0x00	; 0
    140e:	fc 01       	movw	r30, r24
    1410:	ee 0f       	add	r30, r30
    1412:	ff 1f       	adc	r31, r31
    1414:	ee 0f       	add	r30, r30
    1416:	ff 1f       	adc	r31, r31
    1418:	ee 0f       	add	r30, r30
    141a:	ff 1f       	adc	r31, r31
    141c:	e8 0f       	add	r30, r24
    141e:	f9 1f       	adc	r31, r25
    1420:	ec 59       	subi	r30, 0x9C	; 156
    1422:	fe 4f       	sbci	r31, 0xFE	; 254
    1424:	30 81       	ld	r19, Z
    1426:	31 11       	cpse	r19, r1
    1428:	11 c0       	rjmp	.+34     	; 0x144c <vTaskSwitchContext+0x90>
    142a:	21 50       	subi	r18, 0x01	; 1
    142c:	82 2f       	mov	r24, r18
    142e:	90 e0       	ldi	r25, 0x00	; 0
    1430:	fc 01       	movw	r30, r24
    1432:	ee 0f       	add	r30, r30
    1434:	ff 1f       	adc	r31, r31
    1436:	ee 0f       	add	r30, r30
    1438:	ff 1f       	adc	r31, r31
    143a:	ee 0f       	add	r30, r30
    143c:	ff 1f       	adc	r31, r31
    143e:	e8 0f       	add	r30, r24
    1440:	f9 1f       	adc	r31, r25
    1442:	ec 59       	subi	r30, 0x9C	; 156
    1444:	fe 4f       	sbci	r31, 0xFE	; 254
    1446:	30 81       	ld	r19, Z
    1448:	33 23       	and	r19, r19
    144a:	79 f3       	breq	.-34     	; 0x142a <vTaskSwitchContext+0x6e>
    144c:	ac 01       	movw	r20, r24
    144e:	44 0f       	add	r20, r20
    1450:	55 1f       	adc	r21, r21
    1452:	44 0f       	add	r20, r20
    1454:	55 1f       	adc	r21, r21
    1456:	44 0f       	add	r20, r20
    1458:	55 1f       	adc	r21, r21
    145a:	48 0f       	add	r20, r24
    145c:	59 1f       	adc	r21, r25
    145e:	da 01       	movw	r26, r20
    1460:	ac 59       	subi	r26, 0x9C	; 156
    1462:	be 4f       	sbci	r27, 0xFE	; 254
    1464:	11 96       	adiw	r26, 0x01	; 1
    1466:	ed 91       	ld	r30, X+
    1468:	fc 91       	ld	r31, X
    146a:	12 97       	sbiw	r26, 0x02	; 2
    146c:	02 80       	ldd	r0, Z+2	; 0x02
    146e:	f3 81       	ldd	r31, Z+3	; 0x03
    1470:	e0 2d       	mov	r30, r0
    1472:	12 96       	adiw	r26, 0x02	; 2
    1474:	fc 93       	st	X, r31
    1476:	ee 93       	st	-X, r30
    1478:	11 97       	sbiw	r26, 0x01	; 1
    147a:	49 59       	subi	r20, 0x99	; 153
    147c:	5e 4f       	sbci	r21, 0xFE	; 254
    147e:	e4 17       	cp	r30, r20
    1480:	f5 07       	cpc	r31, r21
    1482:	29 f4       	brne	.+10     	; 0x148e <vTaskSwitchContext+0xd2>
    1484:	42 81       	ldd	r20, Z+2	; 0x02
    1486:	53 81       	ldd	r21, Z+3	; 0x03
    1488:	fd 01       	movw	r30, r26
    148a:	52 83       	std	Z+2, r21	; 0x02
    148c:	41 83       	std	Z+1, r20	; 0x01
    148e:	fc 01       	movw	r30, r24
    1490:	ee 0f       	add	r30, r30
    1492:	ff 1f       	adc	r31, r31
    1494:	ee 0f       	add	r30, r30
    1496:	ff 1f       	adc	r31, r31
    1498:	ee 0f       	add	r30, r30
    149a:	ff 1f       	adc	r31, r31
    149c:	8e 0f       	add	r24, r30
    149e:	9f 1f       	adc	r25, r31
    14a0:	fc 01       	movw	r30, r24
    14a2:	ec 59       	subi	r30, 0x9C	; 156
    14a4:	fe 4f       	sbci	r31, 0xFE	; 254
    14a6:	01 80       	ldd	r0, Z+1	; 0x01
    14a8:	f2 81       	ldd	r31, Z+2	; 0x02
    14aa:	e0 2d       	mov	r30, r0
    14ac:	86 81       	ldd	r24, Z+6	; 0x06
    14ae:	97 81       	ldd	r25, Z+7	; 0x07
    14b0:	90 93 89 01 	sts	0x0189, r25	; 0x800189 <pxCurrentTCB+0x1>
    14b4:	80 93 88 01 	sts	0x0188, r24	; 0x800188 <pxCurrentTCB>
    14b8:	20 93 40 01 	sts	0x0140, r18	; 0x800140 <uxTopReadyPriority>
    14bc:	08 95       	ret

000014be <vTaskPlaceOnEventList>:
    14be:	cf 93       	push	r28
    14c0:	df 93       	push	r29
    14c2:	eb 01       	movw	r28, r22
    14c4:	60 91 88 01 	lds	r22, 0x0188	; 0x800188 <pxCurrentTCB>
    14c8:	70 91 89 01 	lds	r23, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    14cc:	64 5f       	subi	r22, 0xF4	; 244
    14ce:	7f 4f       	sbci	r23, 0xFF	; 255
    14d0:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <vListInsert>
    14d4:	61 e0       	ldi	r22, 0x01	; 1
    14d6:	ce 01       	movw	r24, r28
    14d8:	0e 94 7f 06 	call	0xcfe	; 0xcfe <prvAddCurrentTaskToDelayedList>
    14dc:	df 91       	pop	r29
    14de:	cf 91       	pop	r28
    14e0:	08 95       	ret

000014e2 <vTaskPlaceOnEventListRestricted>:
    14e2:	0f 93       	push	r16
    14e4:	1f 93       	push	r17
    14e6:	cf 93       	push	r28
    14e8:	8b 01       	movw	r16, r22
    14ea:	c4 2f       	mov	r28, r20
    14ec:	60 91 88 01 	lds	r22, 0x0188	; 0x800188 <pxCurrentTCB>
    14f0:	70 91 89 01 	lds	r23, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    14f4:	64 5f       	subi	r22, 0xF4	; 244
    14f6:	7f 4f       	sbci	r23, 0xFF	; 255
    14f8:	0e 94 c7 00 	call	0x18e	; 0x18e <vListInsertEnd>
    14fc:	cc 23       	and	r28, r28
    14fe:	11 f0       	breq	.+4      	; 0x1504 <vTaskPlaceOnEventListRestricted+0x22>
    1500:	0f ef       	ldi	r16, 0xFF	; 255
    1502:	1f ef       	ldi	r17, 0xFF	; 255
    1504:	6c 2f       	mov	r22, r28
    1506:	c8 01       	movw	r24, r16
    1508:	0e 94 7f 06 	call	0xcfe	; 0xcfe <prvAddCurrentTaskToDelayedList>
    150c:	cf 91       	pop	r28
    150e:	1f 91       	pop	r17
    1510:	0f 91       	pop	r16
    1512:	08 95       	ret

00001514 <xTaskRemoveFromEventList>:
    1514:	0f 93       	push	r16
    1516:	1f 93       	push	r17
    1518:	cf 93       	push	r28
    151a:	df 93       	push	r29
    151c:	dc 01       	movw	r26, r24
    151e:	15 96       	adiw	r26, 0x05	; 5
    1520:	ed 91       	ld	r30, X+
    1522:	fc 91       	ld	r31, X
    1524:	16 97       	sbiw	r26, 0x06	; 6
    1526:	c6 81       	ldd	r28, Z+6	; 0x06
    1528:	d7 81       	ldd	r29, Z+7	; 0x07
    152a:	8e 01       	movw	r16, r28
    152c:	04 5f       	subi	r16, 0xF4	; 244
    152e:	1f 4f       	sbci	r17, 0xFF	; 255
    1530:	c8 01       	movw	r24, r16
    1532:	0e 94 19 01 	call	0x232	; 0x232 <uxListRemove>
    1536:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uxSchedulerSuspended>
    153a:	81 11       	cpse	r24, r1
    153c:	1c c0       	rjmp	.+56     	; 0x1576 <xTaskRemoveFromEventList+0x62>
    153e:	0a 50       	subi	r16, 0x0A	; 10
    1540:	11 09       	sbc	r17, r1
    1542:	c8 01       	movw	r24, r16
    1544:	0e 94 19 01 	call	0x232	; 0x232 <uxListRemove>
    1548:	8e 89       	ldd	r24, Y+22	; 0x16
    154a:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <uxTopReadyPriority>
    154e:	98 17       	cp	r25, r24
    1550:	10 f4       	brcc	.+4      	; 0x1556 <xTaskRemoveFromEventList+0x42>
    1552:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <uxTopReadyPriority>
    1556:	90 e0       	ldi	r25, 0x00	; 0
    1558:	9c 01       	movw	r18, r24
    155a:	22 0f       	add	r18, r18
    155c:	33 1f       	adc	r19, r19
    155e:	22 0f       	add	r18, r18
    1560:	33 1f       	adc	r19, r19
    1562:	22 0f       	add	r18, r18
    1564:	33 1f       	adc	r19, r19
    1566:	82 0f       	add	r24, r18
    1568:	93 1f       	adc	r25, r19
    156a:	b8 01       	movw	r22, r16
    156c:	8c 59       	subi	r24, 0x9C	; 156
    156e:	9e 4f       	sbci	r25, 0xFE	; 254
    1570:	0e 94 c7 00 	call	0x18e	; 0x18e <vListInsertEnd>
    1574:	05 c0       	rjmp	.+10     	; 0x1580 <xTaskRemoveFromEventList+0x6c>
    1576:	b8 01       	movw	r22, r16
    1578:	87 e5       	ldi	r24, 0x57	; 87
    157a:	91 e0       	ldi	r25, 0x01	; 1
    157c:	0e 94 c7 00 	call	0x18e	; 0x18e <vListInsertEnd>
    1580:	e0 91 88 01 	lds	r30, 0x0188	; 0x800188 <pxCurrentTCB>
    1584:	f0 91 89 01 	lds	r31, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    1588:	9e 89       	ldd	r25, Y+22	; 0x16
    158a:	86 89       	ldd	r24, Z+22	; 0x16
    158c:	89 17       	cp	r24, r25
    158e:	20 f4       	brcc	.+8      	; 0x1598 <xTaskRemoveFromEventList+0x84>
    1590:	81 e0       	ldi	r24, 0x01	; 1
    1592:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <xYieldPending>
    1596:	01 c0       	rjmp	.+2      	; 0x159a <xTaskRemoveFromEventList+0x86>
    1598:	80 e0       	ldi	r24, 0x00	; 0
    159a:	df 91       	pop	r29
    159c:	cf 91       	pop	r28
    159e:	1f 91       	pop	r17
    15a0:	0f 91       	pop	r16
    15a2:	08 95       	ret

000015a4 <vTaskInternalSetTimeOutState>:
    15a4:	20 91 3c 01 	lds	r18, 0x013C	; 0x80013c <xNumOfOverflows>
    15a8:	fc 01       	movw	r30, r24
    15aa:	20 83       	st	Z, r18
    15ac:	20 91 41 01 	lds	r18, 0x0141	; 0x800141 <xTickCount>
    15b0:	30 91 42 01 	lds	r19, 0x0142	; 0x800142 <xTickCount+0x1>
    15b4:	32 83       	std	Z+2, r19	; 0x02
    15b6:	21 83       	std	Z+1, r18	; 0x01
    15b8:	08 95       	ret

000015ba <xTaskCheckForTimeOut>:
    15ba:	cf 93       	push	r28
    15bc:	df 93       	push	r29
    15be:	0f b6       	in	r0, 0x3f	; 63
    15c0:	f8 94       	cli
    15c2:	0f 92       	push	r0
    15c4:	20 91 41 01 	lds	r18, 0x0141	; 0x800141 <xTickCount>
    15c8:	30 91 42 01 	lds	r19, 0x0142	; 0x800142 <xTickCount+0x1>
    15cc:	db 01       	movw	r26, r22
    15ce:	4d 91       	ld	r20, X+
    15d0:	5c 91       	ld	r21, X
    15d2:	4f 3f       	cpi	r20, 0xFF	; 255
    15d4:	bf ef       	ldi	r27, 0xFF	; 255
    15d6:	5b 07       	cpc	r21, r27
    15d8:	f1 f0       	breq	.+60     	; 0x1616 <xTaskCheckForTimeOut+0x5c>
    15da:	ec 01       	movw	r28, r24
    15dc:	e9 81       	ldd	r30, Y+1	; 0x01
    15de:	fa 81       	ldd	r31, Y+2	; 0x02
    15e0:	a0 91 3c 01 	lds	r26, 0x013C	; 0x80013c <xNumOfOverflows>
    15e4:	b8 81       	ld	r27, Y
    15e6:	ba 17       	cp	r27, r26
    15e8:	19 f0       	breq	.+6      	; 0x15f0 <xTaskCheckForTimeOut+0x36>
    15ea:	2e 17       	cp	r18, r30
    15ec:	3f 07       	cpc	r19, r31
    15ee:	a8 f4       	brcc	.+42     	; 0x161a <xTaskCheckForTimeOut+0x60>
    15f0:	2e 1b       	sub	r18, r30
    15f2:	3f 0b       	sbc	r19, r31
    15f4:	24 17       	cp	r18, r20
    15f6:	35 07       	cpc	r19, r21
    15f8:	48 f4       	brcc	.+18     	; 0x160c <xTaskCheckForTimeOut+0x52>
    15fa:	fb 01       	movw	r30, r22
    15fc:	42 1b       	sub	r20, r18
    15fe:	53 0b       	sbc	r21, r19
    1600:	51 83       	std	Z+1, r21	; 0x01
    1602:	40 83       	st	Z, r20
    1604:	0e 94 d2 0a 	call	0x15a4	; 0x15a4 <vTaskInternalSetTimeOutState>
    1608:	80 e0       	ldi	r24, 0x00	; 0
    160a:	08 c0       	rjmp	.+16     	; 0x161c <xTaskCheckForTimeOut+0x62>
    160c:	fb 01       	movw	r30, r22
    160e:	11 82       	std	Z+1, r1	; 0x01
    1610:	10 82       	st	Z, r1
    1612:	81 e0       	ldi	r24, 0x01	; 1
    1614:	03 c0       	rjmp	.+6      	; 0x161c <xTaskCheckForTimeOut+0x62>
    1616:	80 e0       	ldi	r24, 0x00	; 0
    1618:	01 c0       	rjmp	.+2      	; 0x161c <xTaskCheckForTimeOut+0x62>
    161a:	81 e0       	ldi	r24, 0x01	; 1
    161c:	0f 90       	pop	r0
    161e:	0f be       	out	0x3f, r0	; 63
    1620:	df 91       	pop	r29
    1622:	cf 91       	pop	r28
    1624:	08 95       	ret

00001626 <vTaskMissedYield>:
    1626:	81 e0       	ldi	r24, 0x01	; 1
    1628:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <xYieldPending>
    162c:	08 95       	ret

0000162e <xTaskGetSchedulerState>:
    162e:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <xSchedulerRunning>
    1632:	88 23       	and	r24, r24
    1634:	31 f0       	breq	.+12     	; 0x1642 <xTaskGetSchedulerState+0x14>
    1636:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uxSchedulerSuspended>
    163a:	88 23       	and	r24, r24
    163c:	21 f0       	breq	.+8      	; 0x1646 <xTaskGetSchedulerState+0x18>
    163e:	80 e0       	ldi	r24, 0x00	; 0
    1640:	08 95       	ret
    1642:	81 e0       	ldi	r24, 0x01	; 1
    1644:	08 95       	ret
    1646:	82 e0       	ldi	r24, 0x02	; 2
    1648:	08 95       	ret

0000164a <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    164a:	0f 93       	push	r16
    164c:	1f 93       	push	r17
    164e:	cf 93       	push	r28
    1650:	df 93       	push	r29
    1652:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    1654:	89 2b       	or	r24, r25
    1656:	79 f1       	breq	.+94     	; 0x16b6 <xTaskPriorityDisinherit+0x6c>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    1658:	82 a1       	ldd	r24, Z+34	; 0x22
    165a:	81 50       	subi	r24, 0x01	; 1
    165c:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    165e:	26 89       	ldd	r18, Z+22	; 0x16
    1660:	91 a1       	ldd	r25, Z+33	; 0x21
    1662:	29 17       	cp	r18, r25
    1664:	51 f1       	breq	.+84     	; 0x16ba <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    1666:	81 11       	cpse	r24, r1
    1668:	2a c0       	rjmp	.+84     	; 0x16be <xTaskPriorityDisinherit+0x74>
    166a:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    166c:	8f 01       	movw	r16, r30
    166e:	0e 5f       	subi	r16, 0xFE	; 254
    1670:	1f 4f       	sbci	r17, 0xFF	; 255
    1672:	c8 01       	movw	r24, r16
    1674:	0e 94 19 01 	call	0x232	; 0x232 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    1678:	89 a1       	ldd	r24, Y+33	; 0x21
    167a:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority );
    167c:	24 e0       	ldi	r18, 0x04	; 4
    167e:	30 e0       	ldi	r19, 0x00	; 0
    1680:	28 1b       	sub	r18, r24
    1682:	31 09       	sbc	r19, r1
    1684:	3d 87       	std	Y+13, r19	; 0x0d
    1686:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    1688:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <uxTopReadyPriority>
    168c:	98 17       	cp	r25, r24
    168e:	10 f4       	brcc	.+4      	; 0x1694 <xTaskPriorityDisinherit+0x4a>
    1690:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <uxTopReadyPriority>
    1694:	90 e0       	ldi	r25, 0x00	; 0
    1696:	9c 01       	movw	r18, r24
    1698:	22 0f       	add	r18, r18
    169a:	33 1f       	adc	r19, r19
    169c:	22 0f       	add	r18, r18
    169e:	33 1f       	adc	r19, r19
    16a0:	22 0f       	add	r18, r18
    16a2:	33 1f       	adc	r19, r19
    16a4:	82 0f       	add	r24, r18
    16a6:	93 1f       	adc	r25, r19
    16a8:	b8 01       	movw	r22, r16
    16aa:	8c 59       	subi	r24, 0x9C	; 156
    16ac:	9e 4f       	sbci	r25, 0xFE	; 254
    16ae:	0e 94 c7 00 	call	0x18e	; 0x18e <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    16b2:	81 e0       	ldi	r24, 0x01	; 1
    16b4:	05 c0       	rjmp	.+10     	; 0x16c0 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    TCB_t * const pxTCB = pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    16b6:	80 e0       	ldi	r24, 0x00	; 0
    16b8:	03 c0       	rjmp	.+6      	; 0x16c0 <xTaskPriorityDisinherit+0x76>
    16ba:	80 e0       	ldi	r24, 0x00	; 0
    16bc:	01 c0       	rjmp	.+2      	; 0x16c0 <xTaskPriorityDisinherit+0x76>
    16be:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    16c0:	df 91       	pop	r29
    16c2:	cf 91       	pop	r28
    16c4:	1f 91       	pop	r17
    16c6:	0f 91       	pop	r16
    16c8:	08 95       	ret

000016ca <prvInsertTimerInActiveList>:
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */
		}

		return pxNewTimer;
	}
    16ca:	fc 01       	movw	r30, r24
    16cc:	73 83       	std	Z+3, r23	; 0x03
    16ce:	62 83       	std	Z+2, r22	; 0x02
    16d0:	91 87       	std	Z+9, r25	; 0x09
    16d2:	80 87       	std	Z+8, r24	; 0x08
    16d4:	46 17       	cp	r20, r22
    16d6:	57 07       	cpc	r21, r23
    16d8:	90 f0       	brcs	.+36     	; 0x16fe <prvInsertTimerInActiveList+0x34>
    16da:	42 1b       	sub	r20, r18
    16dc:	53 0b       	sbc	r21, r19
    16de:	84 85       	ldd	r24, Z+12	; 0x0c
    16e0:	95 85       	ldd	r25, Z+13	; 0x0d
    16e2:	48 17       	cp	r20, r24
    16e4:	59 07       	cpc	r21, r25
    16e6:	e0 f4       	brcc	.+56     	; 0x1720 <prvInsertTimerInActiveList+0x56>
    16e8:	bf 01       	movw	r22, r30
    16ea:	6e 5f       	subi	r22, 0xFE	; 254
    16ec:	7f 4f       	sbci	r23, 0xFF	; 255
    16ee:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <pxOverflowTimerList>
    16f2:	90 91 a3 01 	lds	r25, 0x01A3	; 0x8001a3 <pxOverflowTimerList+0x1>
    16f6:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <vListInsert>
    16fa:	80 e0       	ldi	r24, 0x00	; 0
    16fc:	08 95       	ret
    16fe:	42 17       	cp	r20, r18
    1700:	53 07       	cpc	r21, r19
    1702:	18 f4       	brcc	.+6      	; 0x170a <prvInsertTimerInActiveList+0x40>
    1704:	62 17       	cp	r22, r18
    1706:	73 07       	cpc	r23, r19
    1708:	68 f4       	brcc	.+26     	; 0x1724 <prvInsertTimerInActiveList+0x5a>
    170a:	bf 01       	movw	r22, r30
    170c:	6e 5f       	subi	r22, 0xFE	; 254
    170e:	7f 4f       	sbci	r23, 0xFF	; 255
    1710:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <pxCurrentTimerList>
    1714:	90 91 a5 01 	lds	r25, 0x01A5	; 0x8001a5 <pxCurrentTimerList+0x1>
    1718:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <vListInsert>
    171c:	80 e0       	ldi	r24, 0x00	; 0
    171e:	08 95       	ret
    1720:	81 e0       	ldi	r24, 0x01	; 1
    1722:	08 95       	ret
    1724:	81 e0       	ldi	r24, 0x01	; 1
    1726:	08 95       	ret

00001728 <prvCheckForValidListAndQueue>:
    1728:	0f b6       	in	r0, 0x3f	; 63
    172a:	f8 94       	cli
    172c:	0f 92       	push	r0
    172e:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <xTimerQueue>
    1732:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <xTimerQueue+0x1>
    1736:	89 2b       	or	r24, r25
    1738:	e9 f4       	brne	.+58     	; 0x1774 <prvCheckForValidListAndQueue+0x4c>
    173a:	83 e9       	ldi	r24, 0x93	; 147
    173c:	91 e0       	ldi	r25, 0x01	; 1
    173e:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
    1742:	8a e8       	ldi	r24, 0x8A	; 138
    1744:	91 e0       	ldi	r25, 0x01	; 1
    1746:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
    174a:	83 e9       	ldi	r24, 0x93	; 147
    174c:	91 e0       	ldi	r25, 0x01	; 1
    174e:	90 93 a5 01 	sts	0x01A5, r25	; 0x8001a5 <pxCurrentTimerList+0x1>
    1752:	80 93 a4 01 	sts	0x01A4, r24	; 0x8001a4 <pxCurrentTimerList>
    1756:	8a e8       	ldi	r24, 0x8A	; 138
    1758:	91 e0       	ldi	r25, 0x01	; 1
    175a:	90 93 a3 01 	sts	0x01A3, r25	; 0x8001a3 <pxOverflowTimerList+0x1>
    175e:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <pxOverflowTimerList>
    1762:	40 e0       	ldi	r20, 0x00	; 0
    1764:	65 e0       	ldi	r22, 0x05	; 5
    1766:	8a e0       	ldi	r24, 0x0A	; 10
    1768:	0e 94 a2 04 	call	0x944	; 0x944 <xQueueGenericCreate>
    176c:	90 93 a1 01 	sts	0x01A1, r25	; 0x8001a1 <xTimerQueue+0x1>
    1770:	80 93 a0 01 	sts	0x01A0, r24	; 0x8001a0 <xTimerQueue>
    1774:	0f 90       	pop	r0
    1776:	0f be       	out	0x3f, r0	; 63
    1778:	08 95       	ret

0000177a <xTimerCreateTimerTask>:
    177a:	ef 92       	push	r14
    177c:	ff 92       	push	r15
    177e:	0f 93       	push	r16
    1780:	0e 94 94 0b 	call	0x1728	; 0x1728 <prvCheckForValidListAndQueue>
    1784:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <xTimerQueue>
    1788:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <xTimerQueue+0x1>
    178c:	89 2b       	or	r24, r25
    178e:	91 f0       	breq	.+36     	; 0x17b4 <xTimerCreateTimerTask+0x3a>
    1790:	0f 2e       	mov	r0, r31
    1792:	fe e9       	ldi	r31, 0x9E	; 158
    1794:	ef 2e       	mov	r14, r31
    1796:	f1 e0       	ldi	r31, 0x01	; 1
    1798:	ff 2e       	mov	r15, r31
    179a:	f0 2d       	mov	r31, r0
    179c:	03 e0       	ldi	r16, 0x03	; 3
    179e:	20 e0       	ldi	r18, 0x00	; 0
    17a0:	30 e0       	ldi	r19, 0x00	; 0
    17a2:	45 e5       	ldi	r20, 0x55	; 85
    17a4:	50 e0       	ldi	r21, 0x00	; 0
    17a6:	6b e1       	ldi	r22, 0x1B	; 27
    17a8:	71 e0       	ldi	r23, 0x01	; 1
    17aa:	87 e9       	ldi	r24, 0x97	; 151
    17ac:	9c e0       	ldi	r25, 0x0C	; 12
    17ae:	0e 94 11 07 	call	0xe22	; 0xe22 <xTaskCreate>
    17b2:	01 c0       	rjmp	.+2      	; 0x17b6 <xTimerCreateTimerTask+0x3c>
    17b4:	80 e0       	ldi	r24, 0x00	; 0
    17b6:	0f 91       	pop	r16
    17b8:	ff 90       	pop	r15
    17ba:	ef 90       	pop	r14
    17bc:	08 95       	ret

000017be <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    17be:	0f 93       	push	r16
    17c0:	1f 93       	push	r17
    17c2:	cf 93       	push	r28
    17c4:	df 93       	push	r29
    17c6:	00 d0       	rcall	.+0      	; 0x17c8 <xTimerGenericCommand+0xa>
    17c8:	00 d0       	rcall	.+0      	; 0x17ca <xTimerGenericCommand+0xc>
    17ca:	1f 92       	push	r1
    17cc:	cd b7       	in	r28, 0x3d	; 61
    17ce:	de b7       	in	r29, 0x3e	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    17d0:	e0 91 a0 01 	lds	r30, 0x01A0	; 0x8001a0 <xTimerQueue>
    17d4:	f0 91 a1 01 	lds	r31, 0x01A1	; 0x8001a1 <xTimerQueue+0x1>
    17d8:	30 97       	sbiw	r30, 0x00	; 0
    17da:	71 f1       	breq	.+92     	; 0x1838 <xTimerGenericCommand+0x7a>
    17dc:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    17de:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    17e0:	5b 83       	std	Y+3, r21	; 0x03
    17e2:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    17e4:	9d 83       	std	Y+5, r25	; 0x05
    17e6:	8c 83       	std	Y+4, r24	; 0x04

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    17e8:	66 30       	cpi	r22, 0x06	; 6
    17ea:	ec f4       	brge	.+58     	; 0x1826 <xTimerGenericCommand+0x68>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    17ec:	0e 94 17 0b 	call	0x162e	; 0x162e <xTaskGetSchedulerState>
    17f0:	82 30       	cpi	r24, 0x02	; 2
    17f2:	61 f4       	brne	.+24     	; 0x180c <xTimerGenericCommand+0x4e>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    17f4:	20 e0       	ldi	r18, 0x00	; 0
    17f6:	a8 01       	movw	r20, r16
    17f8:	be 01       	movw	r22, r28
    17fa:	6f 5f       	subi	r22, 0xFF	; 255
    17fc:	7f 4f       	sbci	r23, 0xFF	; 255
    17fe:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <xTimerQueue>
    1802:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <xTimerQueue+0x1>
    1806:	0e 94 cf 04 	call	0x99e	; 0x99e <xQueueGenericSend>
    180a:	17 c0       	rjmp	.+46     	; 0x183a <xTimerGenericCommand+0x7c>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    180c:	20 e0       	ldi	r18, 0x00	; 0
    180e:	40 e0       	ldi	r20, 0x00	; 0
    1810:	50 e0       	ldi	r21, 0x00	; 0
    1812:	be 01       	movw	r22, r28
    1814:	6f 5f       	subi	r22, 0xFF	; 255
    1816:	7f 4f       	sbci	r23, 0xFF	; 255
    1818:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <xTimerQueue>
    181c:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <xTimerQueue+0x1>
    1820:	0e 94 cf 04 	call	0x99e	; 0x99e <xQueueGenericSend>
    1824:	0a c0       	rjmp	.+20     	; 0x183a <xTimerGenericCommand+0x7c>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    1826:	20 e0       	ldi	r18, 0x00	; 0
    1828:	ad 01       	movw	r20, r26
    182a:	be 01       	movw	r22, r28
    182c:	6f 5f       	subi	r22, 0xFF	; 255
    182e:	7f 4f       	sbci	r23, 0xFF	; 255
    1830:	cf 01       	movw	r24, r30
    1832:	0e 94 70 05 	call	0xae0	; 0xae0 <xQueueGenericSendFromISR>
    1836:	01 c0       	rjmp	.+2      	; 0x183a <xTimerGenericCommand+0x7c>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    1838:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    183a:	0f 90       	pop	r0
    183c:	0f 90       	pop	r0
    183e:	0f 90       	pop	r0
    1840:	0f 90       	pop	r0
    1842:	0f 90       	pop	r0
    1844:	df 91       	pop	r29
    1846:	cf 91       	pop	r28
    1848:	1f 91       	pop	r17
    184a:	0f 91       	pop	r16
    184c:	08 95       	ret

0000184e <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    184e:	af 92       	push	r10
    1850:	bf 92       	push	r11
    1852:	cf 92       	push	r12
    1854:	df 92       	push	r13
    1856:	ef 92       	push	r14
    1858:	ff 92       	push	r15
    185a:	0f 93       	push	r16
    185c:	1f 93       	push	r17
    185e:	cf 93       	push	r28
    1860:	df 93       	push	r29
    1862:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U;

	xTimeNow = xTaskGetTickCount();
    1864:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <xTaskGetTickCount>
    1868:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    186a:	80 91 9c 01 	lds	r24, 0x019C	; 0x80019c <xLastTime.2379>
    186e:	90 91 9d 01 	lds	r25, 0x019D	; 0x80019d <xLastTime.2379+0x1>
    1872:	e8 16       	cp	r14, r24
    1874:	f9 06       	cpc	r15, r25
    1876:	08 f0       	brcs	.+2      	; 0x187a <prvSampleTimeNow+0x2c>
    1878:	48 c0       	rjmp	.+144    	; 0x190a <prvSampleTimeNow+0xbc>
    187a:	30 c0       	rjmp	.+96     	; 0x18dc <prvSampleTimeNow+0x8e>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    187c:	05 80       	ldd	r0, Z+5	; 0x05
    187e:	f6 81       	ldd	r31, Z+6	; 0x06
    1880:	e0 2d       	mov	r30, r0
    1882:	a0 80       	ld	r10, Z
    1884:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    1886:	c6 81       	ldd	r28, Z+6	; 0x06
    1888:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    188a:	8e 01       	movw	r16, r28
    188c:	0e 5f       	subi	r16, 0xFE	; 254
    188e:	1f 4f       	sbci	r17, 0xFF	; 255
    1890:	c8 01       	movw	r24, r16
    1892:	0e 94 19 01 	call	0x232	; 0x232 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1896:	e9 89       	ldd	r30, Y+17	; 0x11
    1898:	fa 89       	ldd	r31, Y+18	; 0x12
    189a:	ce 01       	movw	r24, r28
    189c:	09 95       	icall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    189e:	8e 85       	ldd	r24, Y+14	; 0x0e
    18a0:	81 30       	cpi	r24, 0x01	; 1
    18a2:	e1 f4       	brne	.+56     	; 0x18dc <prvSampleTimeNow+0x8e>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    18a4:	8c 85       	ldd	r24, Y+12	; 0x0c
    18a6:	9d 85       	ldd	r25, Y+13	; 0x0d
    18a8:	8a 0d       	add	r24, r10
    18aa:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    18ac:	a8 16       	cp	r10, r24
    18ae:	b9 06       	cpc	r11, r25
    18b0:	60 f4       	brcc	.+24     	; 0x18ca <prvSampleTimeNow+0x7c>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    18b2:	9b 83       	std	Y+3, r25	; 0x03
    18b4:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    18b6:	d9 87       	std	Y+9, r29	; 0x09
    18b8:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    18ba:	b8 01       	movw	r22, r16
    18bc:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <pxCurrentTimerList>
    18c0:	90 91 a5 01 	lds	r25, 0x01A5	; 0x8001a5 <pxCurrentTimerList+0x1>
    18c4:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <vListInsert>
    18c8:	09 c0       	rjmp	.+18     	; 0x18dc <prvSampleTimeNow+0x8e>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    18ca:	00 e0       	ldi	r16, 0x00	; 0
    18cc:	10 e0       	ldi	r17, 0x00	; 0
    18ce:	20 e0       	ldi	r18, 0x00	; 0
    18d0:	30 e0       	ldi	r19, 0x00	; 0
    18d2:	a5 01       	movw	r20, r10
    18d4:	60 e0       	ldi	r22, 0x00	; 0
    18d6:	ce 01       	movw	r24, r28
    18d8:	0e 94 df 0b 	call	0x17be	; 0x17be <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    18dc:	e0 91 a4 01 	lds	r30, 0x01A4	; 0x8001a4 <pxCurrentTimerList>
    18e0:	f0 91 a5 01 	lds	r31, 0x01A5	; 0x8001a5 <pxCurrentTimerList+0x1>
    18e4:	80 81       	ld	r24, Z
    18e6:	81 11       	cpse	r24, r1
    18e8:	c9 cf       	rjmp	.-110    	; 0x187c <prvSampleTimeNow+0x2e>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    18ea:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <pxOverflowTimerList>
    18ee:	90 91 a3 01 	lds	r25, 0x01A3	; 0x8001a3 <pxOverflowTimerList+0x1>
    18f2:	90 93 a5 01 	sts	0x01A5, r25	; 0x8001a5 <pxCurrentTimerList+0x1>
    18f6:	80 93 a4 01 	sts	0x01A4, r24	; 0x8001a4 <pxCurrentTimerList>
	pxOverflowTimerList = pxTemp;
    18fa:	f0 93 a3 01 	sts	0x01A3, r31	; 0x8001a3 <pxOverflowTimerList+0x1>
    18fe:	e0 93 a2 01 	sts	0x01A2, r30	; 0x8001a2 <pxOverflowTimerList>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    1902:	81 e0       	ldi	r24, 0x01	; 1
    1904:	f6 01       	movw	r30, r12
    1906:	80 83       	st	Z, r24
    1908:	02 c0       	rjmp	.+4      	; 0x190e <prvSampleTimeNow+0xc0>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    190a:	f6 01       	movw	r30, r12
    190c:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    190e:	f0 92 9d 01 	sts	0x019D, r15	; 0x80019d <xLastTime.2379+0x1>
    1912:	e0 92 9c 01 	sts	0x019C, r14	; 0x80019c <xLastTime.2379>

	return xTimeNow;
}
    1916:	c7 01       	movw	r24, r14
    1918:	df 91       	pop	r29
    191a:	cf 91       	pop	r28
    191c:	1f 91       	pop	r17
    191e:	0f 91       	pop	r16
    1920:	ff 90       	pop	r15
    1922:	ef 90       	pop	r14
    1924:	df 90       	pop	r13
    1926:	cf 90       	pop	r12
    1928:	bf 90       	pop	r11
    192a:	af 90       	pop	r10
    192c:	08 95       	ret

0000192e <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    192e:	cf 93       	push	r28
    1930:	df 93       	push	r29
    1932:	00 d0       	rcall	.+0      	; 0x1934 <prvTimerTask+0x6>
    1934:	00 d0       	rcall	.+0      	; 0x1936 <prvTimerTask+0x8>
    1936:	00 d0       	rcall	.+0      	; 0x1938 <prvTimerTask+0xa>
    1938:	cd b7       	in	r28, 0x3d	; 61
    193a:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    193c:	ce 01       	movw	r24, r28
    193e:	01 96       	adiw	r24, 0x01	; 1
    1940:	4c 01       	movw	r8, r24
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1942:	44 24       	eor	r4, r4
    1944:	43 94       	inc	r4
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    1946:	e1 2c       	mov	r14, r1
    1948:	f1 2c       	mov	r15, r1
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    194a:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
    194c:	c8 2e       	mov	r12, r24
    194e:	d9 2c       	mov	r13, r9
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    1950:	e0 91 a4 01 	lds	r30, 0x01A4	; 0x8001a4 <pxCurrentTimerList>
    1954:	f0 91 a5 01 	lds	r31, 0x01A5	; 0x8001a5 <pxCurrentTimerList+0x1>
    1958:	80 81       	ld	r24, Z
	if( *pxListWasEmpty == pdFALSE )
    195a:	88 23       	and	r24, r24
    195c:	09 f4       	brne	.+2      	; 0x1960 <prvTimerTask+0x32>
    195e:	c2 c0       	rjmp	.+388    	; 0x1ae4 <prvTimerTask+0x1b6>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1960:	05 80       	ldd	r0, Z+5	; 0x05
    1962:	f6 81       	ldd	r31, Z+6	; 0x06
    1964:	e0 2d       	mov	r30, r0
    1966:	a0 80       	ld	r10, Z
    1968:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    196a:	0e 94 56 08 	call	0x10ac	; 0x10ac <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    196e:	c4 01       	movw	r24, r8
    1970:	0e 94 27 0c 	call	0x184e	; 0x184e <prvSampleTimeNow>
    1974:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    1976:	89 81       	ldd	r24, Y+1	; 0x01
    1978:	81 11       	cpse	r24, r1
    197a:	47 c0       	rjmp	.+142    	; 0x1a0a <prvTimerTask+0xdc>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    197c:	0a 15       	cp	r16, r10
    197e:	1b 05       	cpc	r17, r11
    1980:	98 f1       	brcs	.+102    	; 0x19e8 <prvTimerTask+0xba>
			{
				( void ) xTaskResumeAll();
    1982:	0e 94 21 09 	call	0x1242	; 0x1242 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    1986:	e0 91 a4 01 	lds	r30, 0x01A4	; 0x8001a4 <pxCurrentTimerList>
    198a:	f0 91 a5 01 	lds	r31, 0x01A5	; 0x8001a5 <pxCurrentTimerList+0x1>
    198e:	05 80       	ldd	r0, Z+5	; 0x05
    1990:	f6 81       	ldd	r31, Z+6	; 0x06
    1992:	e0 2d       	mov	r30, r0
    1994:	66 80       	ldd	r6, Z+6	; 0x06
    1996:	77 80       	ldd	r7, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1998:	c3 01       	movw	r24, r6
    199a:	02 96       	adiw	r24, 0x02	; 2
    199c:	0e 94 19 01 	call	0x232	; 0x232 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    19a0:	d3 01       	movw	r26, r6
    19a2:	1e 96       	adiw	r26, 0x0e	; 14
    19a4:	8c 91       	ld	r24, X
    19a6:	1e 97       	sbiw	r26, 0x0e	; 14
    19a8:	81 30       	cpi	r24, 0x01	; 1
    19aa:	b1 f4       	brne	.+44     	; 0x19d8 <prvTimerTask+0xaa>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    19ac:	1c 96       	adiw	r26, 0x0c	; 12
    19ae:	6d 91       	ld	r22, X+
    19b0:	7c 91       	ld	r23, X
    19b2:	1d 97       	sbiw	r26, 0x0d	; 13
    19b4:	6a 0d       	add	r22, r10
    19b6:	7b 1d       	adc	r23, r11
    19b8:	95 01       	movw	r18, r10
    19ba:	a8 01       	movw	r20, r16
    19bc:	c3 01       	movw	r24, r6
    19be:	0e 94 65 0b 	call	0x16ca	; 0x16ca <prvInsertTimerInActiveList>
    19c2:	88 23       	and	r24, r24
    19c4:	49 f0       	breq	.+18     	; 0x19d8 <prvTimerTask+0xaa>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    19c6:	0e 2d       	mov	r16, r14
    19c8:	1f 2d       	mov	r17, r15
    19ca:	2e 2d       	mov	r18, r14
    19cc:	3f 2d       	mov	r19, r15
    19ce:	a5 01       	movw	r20, r10
    19d0:	65 2d       	mov	r22, r5
    19d2:	c3 01       	movw	r24, r6
    19d4:	0e 94 df 0b 	call	0x17be	; 0x17be <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    19d8:	d3 01       	movw	r26, r6
    19da:	51 96       	adiw	r26, 0x11	; 17
    19dc:	ed 91       	ld	r30, X+
    19de:	fc 91       	ld	r31, X
    19e0:	52 97       	sbiw	r26, 0x12	; 18
    19e2:	c3 01       	movw	r24, r6
    19e4:	09 95       	icall
    19e6:	71 c0       	rjmp	.+226    	; 0x1aca <prvTimerTask+0x19c>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    19e8:	45 2d       	mov	r20, r5
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    19ea:	b5 01       	movw	r22, r10
    19ec:	60 1b       	sub	r22, r16
    19ee:	71 0b       	sbc	r23, r17
    19f0:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <xTimerQueue>
    19f4:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <xTimerQueue+0x1>
    19f8:	0e 94 43 06 	call	0xc86	; 0xc86 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    19fc:	0e 94 21 09 	call	0x1242	; 0x1242 <xTaskResumeAll>
    1a00:	81 11       	cpse	r24, r1
    1a02:	63 c0       	rjmp	.+198    	; 0x1aca <prvTimerTask+0x19c>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    1a04:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vPortYield>
    1a08:	60 c0       	rjmp	.+192    	; 0x1aca <prvTimerTask+0x19c>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    1a0a:	0e 94 21 09 	call	0x1242	; 0x1242 <xTaskResumeAll>
    1a0e:	5d c0       	rjmp	.+186    	; 0x1aca <prvTimerTask+0x19c>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    1a10:	89 81       	ldd	r24, Y+1	; 0x01
    1a12:	88 23       	and	r24, r24
    1a14:	0c f4       	brge	.+2      	; 0x1a18 <prvTimerTask+0xea>
    1a16:	59 c0       	rjmp	.+178    	; 0x1aca <prvTimerTask+0x19c>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    1a18:	ac 80       	ldd	r10, Y+4	; 0x04
    1a1a:	bd 80       	ldd	r11, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    1a1c:	f5 01       	movw	r30, r10
    1a1e:	82 85       	ldd	r24, Z+10	; 0x0a
    1a20:	93 85       	ldd	r25, Z+11	; 0x0b
    1a22:	89 2b       	or	r24, r25
    1a24:	21 f0       	breq	.+8      	; 0x1a2e <prvTimerTask+0x100>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1a26:	c5 01       	movw	r24, r10
    1a28:	02 96       	adiw	r24, 0x02	; 2
    1a2a:	0e 94 19 01 	call	0x232	; 0x232 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1a2e:	ce 01       	movw	r24, r28
    1a30:	06 96       	adiw	r24, 0x06	; 6
    1a32:	0e 94 27 0c 	call	0x184e	; 0x184e <prvSampleTimeNow>

			switch( xMessage.xMessageID )
    1a36:	e9 81       	ldd	r30, Y+1	; 0x01
    1a38:	0e 2f       	mov	r16, r30
    1a3a:	ee 0f       	add	r30, r30
    1a3c:	11 0b       	sbc	r17, r17
    1a3e:	22 0b       	sbc	r18, r18
    1a40:	33 0b       	sbc	r19, r19
    1a42:	0a 30       	cpi	r16, 0x0A	; 10
    1a44:	11 05       	cpc	r17, r1
    1a46:	08 f0       	brcs	.+2      	; 0x1a4a <prvTimerTask+0x11c>
    1a48:	40 c0       	rjmp	.+128    	; 0x1aca <prvTimerTask+0x19c>
    1a4a:	f8 01       	movw	r30, r16
    1a4c:	ec 5c       	subi	r30, 0xCC	; 204
    1a4e:	ff 4f       	sbci	r31, 0xFF	; 255
    1a50:	0c 94 86 0d 	jmp	0x1b0c	; 0x1b0c <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    1a54:	2a 81       	ldd	r18, Y+2	; 0x02
    1a56:	3b 81       	ldd	r19, Y+3	; 0x03
    1a58:	d5 01       	movw	r26, r10
    1a5a:	1c 96       	adiw	r26, 0x0c	; 12
    1a5c:	6d 91       	ld	r22, X+
    1a5e:	7c 91       	ld	r23, X
    1a60:	1d 97       	sbiw	r26, 0x0d	; 13
    1a62:	62 0f       	add	r22, r18
    1a64:	73 1f       	adc	r23, r19
    1a66:	ac 01       	movw	r20, r24
    1a68:	c5 01       	movw	r24, r10
    1a6a:	0e 94 65 0b 	call	0x16ca	; 0x16ca <prvInsertTimerInActiveList>
    1a6e:	88 23       	and	r24, r24
    1a70:	61 f1       	breq	.+88     	; 0x1aca <prvTimerTask+0x19c>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1a72:	d5 01       	movw	r26, r10
    1a74:	51 96       	adiw	r26, 0x11	; 17
    1a76:	ed 91       	ld	r30, X+
    1a78:	fc 91       	ld	r31, X
    1a7a:	52 97       	sbiw	r26, 0x12	; 18
    1a7c:	c5 01       	movw	r24, r10
    1a7e:	09 95       	icall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1a80:	f5 01       	movw	r30, r10
    1a82:	86 85       	ldd	r24, Z+14	; 0x0e
    1a84:	81 30       	cpi	r24, 0x01	; 1
    1a86:	09 f5       	brne	.+66     	; 0x1aca <prvTimerTask+0x19c>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    1a88:	4a 81       	ldd	r20, Y+2	; 0x02
    1a8a:	5b 81       	ldd	r21, Y+3	; 0x03
    1a8c:	84 85       	ldd	r24, Z+12	; 0x0c
    1a8e:	95 85       	ldd	r25, Z+13	; 0x0d
    1a90:	48 0f       	add	r20, r24
    1a92:	59 1f       	adc	r21, r25
    1a94:	0e 2d       	mov	r16, r14
    1a96:	1f 2d       	mov	r17, r15
    1a98:	2e 2d       	mov	r18, r14
    1a9a:	3f 2d       	mov	r19, r15
    1a9c:	65 2d       	mov	r22, r5
    1a9e:	c5 01       	movw	r24, r10
    1aa0:	0e 94 df 0b 	call	0x17be	; 0x17be <xTimerGenericCommand>
    1aa4:	12 c0       	rjmp	.+36     	; 0x1aca <prvTimerTask+0x19c>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    1aa6:	6a 81       	ldd	r22, Y+2	; 0x02
    1aa8:	7b 81       	ldd	r23, Y+3	; 0x03
    1aaa:	d5 01       	movw	r26, r10
    1aac:	1d 96       	adiw	r26, 0x0d	; 13
    1aae:	7c 93       	st	X, r23
    1ab0:	6e 93       	st	-X, r22
    1ab2:	1c 97       	sbiw	r26, 0x0c	; 12
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    1ab4:	68 0f       	add	r22, r24
    1ab6:	79 1f       	adc	r23, r25
    1ab8:	9c 01       	movw	r18, r24
    1aba:	ac 01       	movw	r20, r24
    1abc:	c5 01       	movw	r24, r10
    1abe:	0e 94 65 0b 	call	0x16ca	; 0x16ca <prvInsertTimerInActiveList>
    1ac2:	03 c0       	rjmp	.+6      	; 0x1aca <prvTimerTask+0x19c>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
    1ac4:	c5 01       	movw	r24, r10
    1ac6:	0e 94 70 00 	call	0xe0	; 0xe0 <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
    1aca:	4e 2d       	mov	r20, r14
    1acc:	5f 2d       	mov	r21, r15
    1ace:	6c 2d       	mov	r22, r12
    1ad0:	7d 2d       	mov	r23, r13
    1ad2:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <xTimerQueue>
    1ad6:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <xTimerQueue+0x1>
    1ada:	0e 94 aa 05 	call	0xb54	; 0xb54 <xQueueReceive>
    1ade:	81 11       	cpse	r24, r1
    1ae0:	97 cf       	rjmp	.-210    	; 0x1a10 <prvTimerTask+0xe2>
    1ae2:	36 cf       	rjmp	.-404    	; 0x1950 <prvTimerTask+0x22>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    1ae4:	0e 94 56 08 	call	0x10ac	; 0x10ac <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1ae8:	c4 01       	movw	r24, r8
    1aea:	0e 94 27 0c 	call	0x184e	; 0x184e <prvSampleTimeNow>
    1aee:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    1af0:	89 81       	ldd	r24, Y+1	; 0x01
    1af2:	81 11       	cpse	r24, r1
    1af4:	8a cf       	rjmp	.-236    	; 0x1a0a <prvTimerTask+0xdc>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1af6:	e0 91 a2 01 	lds	r30, 0x01A2	; 0x8001a2 <pxOverflowTimerList>
    1afa:	f0 91 a3 01 	lds	r31, 0x01A3	; 0x8001a3 <pxOverflowTimerList+0x1>
    1afe:	80 81       	ld	r24, Z
    1b00:	44 2d       	mov	r20, r4
    1b02:	81 11       	cpse	r24, r1
    1b04:	45 2d       	mov	r20, r5
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    1b06:	ae 2c       	mov	r10, r14
    1b08:	bf 2c       	mov	r11, r15
    1b0a:	6f cf       	rjmp	.-290    	; 0x19ea <prvTimerTask+0xbc>

00001b0c <__tablejump2__>:
    1b0c:	ee 0f       	add	r30, r30
    1b0e:	ff 1f       	adc	r31, r31
    1b10:	05 90       	lpm	r0, Z+
    1b12:	f4 91       	lpm	r31, Z
    1b14:	e0 2d       	mov	r30, r0
    1b16:	09 94       	ijmp

00001b18 <malloc>:
    1b18:	0f 93       	push	r16
    1b1a:	1f 93       	push	r17
    1b1c:	cf 93       	push	r28
    1b1e:	df 93       	push	r29
    1b20:	82 30       	cpi	r24, 0x02	; 2
    1b22:	91 05       	cpc	r25, r1
    1b24:	10 f4       	brcc	.+4      	; 0x1b2a <malloc+0x12>
    1b26:	82 e0       	ldi	r24, 0x02	; 2
    1b28:	90 e0       	ldi	r25, 0x00	; 0
    1b2a:	e0 91 ca 01 	lds	r30, 0x01CA	; 0x8001ca <__flp>
    1b2e:	f0 91 cb 01 	lds	r31, 0x01CB	; 0x8001cb <__flp+0x1>
    1b32:	20 e0       	ldi	r18, 0x00	; 0
    1b34:	30 e0       	ldi	r19, 0x00	; 0
    1b36:	a0 e0       	ldi	r26, 0x00	; 0
    1b38:	b0 e0       	ldi	r27, 0x00	; 0
    1b3a:	30 97       	sbiw	r30, 0x00	; 0
    1b3c:	19 f1       	breq	.+70     	; 0x1b84 <malloc+0x6c>
    1b3e:	40 81       	ld	r20, Z
    1b40:	51 81       	ldd	r21, Z+1	; 0x01
    1b42:	02 81       	ldd	r16, Z+2	; 0x02
    1b44:	13 81       	ldd	r17, Z+3	; 0x03
    1b46:	48 17       	cp	r20, r24
    1b48:	59 07       	cpc	r21, r25
    1b4a:	c8 f0       	brcs	.+50     	; 0x1b7e <malloc+0x66>
    1b4c:	84 17       	cp	r24, r20
    1b4e:	95 07       	cpc	r25, r21
    1b50:	69 f4       	brne	.+26     	; 0x1b6c <malloc+0x54>
    1b52:	10 97       	sbiw	r26, 0x00	; 0
    1b54:	31 f0       	breq	.+12     	; 0x1b62 <malloc+0x4a>
    1b56:	12 96       	adiw	r26, 0x02	; 2
    1b58:	0c 93       	st	X, r16
    1b5a:	12 97       	sbiw	r26, 0x02	; 2
    1b5c:	13 96       	adiw	r26, 0x03	; 3
    1b5e:	1c 93       	st	X, r17
    1b60:	27 c0       	rjmp	.+78     	; 0x1bb0 <malloc+0x98>
    1b62:	00 93 ca 01 	sts	0x01CA, r16	; 0x8001ca <__flp>
    1b66:	10 93 cb 01 	sts	0x01CB, r17	; 0x8001cb <__flp+0x1>
    1b6a:	22 c0       	rjmp	.+68     	; 0x1bb0 <malloc+0x98>
    1b6c:	21 15       	cp	r18, r1
    1b6e:	31 05       	cpc	r19, r1
    1b70:	19 f0       	breq	.+6      	; 0x1b78 <malloc+0x60>
    1b72:	42 17       	cp	r20, r18
    1b74:	53 07       	cpc	r21, r19
    1b76:	18 f4       	brcc	.+6      	; 0x1b7e <malloc+0x66>
    1b78:	9a 01       	movw	r18, r20
    1b7a:	bd 01       	movw	r22, r26
    1b7c:	ef 01       	movw	r28, r30
    1b7e:	df 01       	movw	r26, r30
    1b80:	f8 01       	movw	r30, r16
    1b82:	db cf       	rjmp	.-74     	; 0x1b3a <malloc+0x22>
    1b84:	21 15       	cp	r18, r1
    1b86:	31 05       	cpc	r19, r1
    1b88:	f9 f0       	breq	.+62     	; 0x1bc8 <malloc+0xb0>
    1b8a:	28 1b       	sub	r18, r24
    1b8c:	39 0b       	sbc	r19, r25
    1b8e:	24 30       	cpi	r18, 0x04	; 4
    1b90:	31 05       	cpc	r19, r1
    1b92:	80 f4       	brcc	.+32     	; 0x1bb4 <malloc+0x9c>
    1b94:	8a 81       	ldd	r24, Y+2	; 0x02
    1b96:	9b 81       	ldd	r25, Y+3	; 0x03
    1b98:	61 15       	cp	r22, r1
    1b9a:	71 05       	cpc	r23, r1
    1b9c:	21 f0       	breq	.+8      	; 0x1ba6 <malloc+0x8e>
    1b9e:	fb 01       	movw	r30, r22
    1ba0:	93 83       	std	Z+3, r25	; 0x03
    1ba2:	82 83       	std	Z+2, r24	; 0x02
    1ba4:	04 c0       	rjmp	.+8      	; 0x1bae <malloc+0x96>
    1ba6:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__flp+0x1>
    1baa:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__flp>
    1bae:	fe 01       	movw	r30, r28
    1bb0:	32 96       	adiw	r30, 0x02	; 2
    1bb2:	44 c0       	rjmp	.+136    	; 0x1c3c <malloc+0x124>
    1bb4:	fe 01       	movw	r30, r28
    1bb6:	e2 0f       	add	r30, r18
    1bb8:	f3 1f       	adc	r31, r19
    1bba:	81 93       	st	Z+, r24
    1bbc:	91 93       	st	Z+, r25
    1bbe:	22 50       	subi	r18, 0x02	; 2
    1bc0:	31 09       	sbc	r19, r1
    1bc2:	39 83       	std	Y+1, r19	; 0x01
    1bc4:	28 83       	st	Y, r18
    1bc6:	3a c0       	rjmp	.+116    	; 0x1c3c <malloc+0x124>
    1bc8:	20 91 c8 01 	lds	r18, 0x01C8	; 0x8001c8 <__brkval>
    1bcc:	30 91 c9 01 	lds	r19, 0x01C9	; 0x8001c9 <__brkval+0x1>
    1bd0:	23 2b       	or	r18, r19
    1bd2:	41 f4       	brne	.+16     	; 0x1be4 <malloc+0xcc>
    1bd4:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    1bd8:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    1bdc:	30 93 c9 01 	sts	0x01C9, r19	; 0x8001c9 <__brkval+0x1>
    1be0:	20 93 c8 01 	sts	0x01C8, r18	; 0x8001c8 <__brkval>
    1be4:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    1be8:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    1bec:	21 15       	cp	r18, r1
    1bee:	31 05       	cpc	r19, r1
    1bf0:	41 f4       	brne	.+16     	; 0x1c02 <malloc+0xea>
    1bf2:	2d b7       	in	r18, 0x3d	; 61
    1bf4:	3e b7       	in	r19, 0x3e	; 62
    1bf6:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    1bfa:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    1bfe:	24 1b       	sub	r18, r20
    1c00:	35 0b       	sbc	r19, r21
    1c02:	e0 91 c8 01 	lds	r30, 0x01C8	; 0x8001c8 <__brkval>
    1c06:	f0 91 c9 01 	lds	r31, 0x01C9	; 0x8001c9 <__brkval+0x1>
    1c0a:	e2 17       	cp	r30, r18
    1c0c:	f3 07       	cpc	r31, r19
    1c0e:	a0 f4       	brcc	.+40     	; 0x1c38 <malloc+0x120>
    1c10:	2e 1b       	sub	r18, r30
    1c12:	3f 0b       	sbc	r19, r31
    1c14:	28 17       	cp	r18, r24
    1c16:	39 07       	cpc	r19, r25
    1c18:	78 f0       	brcs	.+30     	; 0x1c38 <malloc+0x120>
    1c1a:	ac 01       	movw	r20, r24
    1c1c:	4e 5f       	subi	r20, 0xFE	; 254
    1c1e:	5f 4f       	sbci	r21, 0xFF	; 255
    1c20:	24 17       	cp	r18, r20
    1c22:	35 07       	cpc	r19, r21
    1c24:	48 f0       	brcs	.+18     	; 0x1c38 <malloc+0x120>
    1c26:	4e 0f       	add	r20, r30
    1c28:	5f 1f       	adc	r21, r31
    1c2a:	50 93 c9 01 	sts	0x01C9, r21	; 0x8001c9 <__brkval+0x1>
    1c2e:	40 93 c8 01 	sts	0x01C8, r20	; 0x8001c8 <__brkval>
    1c32:	81 93       	st	Z+, r24
    1c34:	91 93       	st	Z+, r25
    1c36:	02 c0       	rjmp	.+4      	; 0x1c3c <malloc+0x124>
    1c38:	e0 e0       	ldi	r30, 0x00	; 0
    1c3a:	f0 e0       	ldi	r31, 0x00	; 0
    1c3c:	cf 01       	movw	r24, r30
    1c3e:	df 91       	pop	r29
    1c40:	cf 91       	pop	r28
    1c42:	1f 91       	pop	r17
    1c44:	0f 91       	pop	r16
    1c46:	08 95       	ret

00001c48 <free>:
    1c48:	cf 93       	push	r28
    1c4a:	df 93       	push	r29
    1c4c:	00 97       	sbiw	r24, 0x00	; 0
    1c4e:	09 f4       	brne	.+2      	; 0x1c52 <free+0xa>
    1c50:	81 c0       	rjmp	.+258    	; 0x1d54 <free+0x10c>
    1c52:	fc 01       	movw	r30, r24
    1c54:	32 97       	sbiw	r30, 0x02	; 2
    1c56:	13 82       	std	Z+3, r1	; 0x03
    1c58:	12 82       	std	Z+2, r1	; 0x02
    1c5a:	a0 91 ca 01 	lds	r26, 0x01CA	; 0x8001ca <__flp>
    1c5e:	b0 91 cb 01 	lds	r27, 0x01CB	; 0x8001cb <__flp+0x1>
    1c62:	10 97       	sbiw	r26, 0x00	; 0
    1c64:	81 f4       	brne	.+32     	; 0x1c86 <free+0x3e>
    1c66:	20 81       	ld	r18, Z
    1c68:	31 81       	ldd	r19, Z+1	; 0x01
    1c6a:	82 0f       	add	r24, r18
    1c6c:	93 1f       	adc	r25, r19
    1c6e:	20 91 c8 01 	lds	r18, 0x01C8	; 0x8001c8 <__brkval>
    1c72:	30 91 c9 01 	lds	r19, 0x01C9	; 0x8001c9 <__brkval+0x1>
    1c76:	28 17       	cp	r18, r24
    1c78:	39 07       	cpc	r19, r25
    1c7a:	51 f5       	brne	.+84     	; 0x1cd0 <free+0x88>
    1c7c:	f0 93 c9 01 	sts	0x01C9, r31	; 0x8001c9 <__brkval+0x1>
    1c80:	e0 93 c8 01 	sts	0x01C8, r30	; 0x8001c8 <__brkval>
    1c84:	67 c0       	rjmp	.+206    	; 0x1d54 <free+0x10c>
    1c86:	ed 01       	movw	r28, r26
    1c88:	20 e0       	ldi	r18, 0x00	; 0
    1c8a:	30 e0       	ldi	r19, 0x00	; 0
    1c8c:	ce 17       	cp	r28, r30
    1c8e:	df 07       	cpc	r29, r31
    1c90:	40 f4       	brcc	.+16     	; 0x1ca2 <free+0x5a>
    1c92:	4a 81       	ldd	r20, Y+2	; 0x02
    1c94:	5b 81       	ldd	r21, Y+3	; 0x03
    1c96:	9e 01       	movw	r18, r28
    1c98:	41 15       	cp	r20, r1
    1c9a:	51 05       	cpc	r21, r1
    1c9c:	f1 f0       	breq	.+60     	; 0x1cda <free+0x92>
    1c9e:	ea 01       	movw	r28, r20
    1ca0:	f5 cf       	rjmp	.-22     	; 0x1c8c <free+0x44>
    1ca2:	d3 83       	std	Z+3, r29	; 0x03
    1ca4:	c2 83       	std	Z+2, r28	; 0x02
    1ca6:	40 81       	ld	r20, Z
    1ca8:	51 81       	ldd	r21, Z+1	; 0x01
    1caa:	84 0f       	add	r24, r20
    1cac:	95 1f       	adc	r25, r21
    1cae:	c8 17       	cp	r28, r24
    1cb0:	d9 07       	cpc	r29, r25
    1cb2:	59 f4       	brne	.+22     	; 0x1cca <free+0x82>
    1cb4:	88 81       	ld	r24, Y
    1cb6:	99 81       	ldd	r25, Y+1	; 0x01
    1cb8:	84 0f       	add	r24, r20
    1cba:	95 1f       	adc	r25, r21
    1cbc:	02 96       	adiw	r24, 0x02	; 2
    1cbe:	91 83       	std	Z+1, r25	; 0x01
    1cc0:	80 83       	st	Z, r24
    1cc2:	8a 81       	ldd	r24, Y+2	; 0x02
    1cc4:	9b 81       	ldd	r25, Y+3	; 0x03
    1cc6:	93 83       	std	Z+3, r25	; 0x03
    1cc8:	82 83       	std	Z+2, r24	; 0x02
    1cca:	21 15       	cp	r18, r1
    1ccc:	31 05       	cpc	r19, r1
    1cce:	29 f4       	brne	.+10     	; 0x1cda <free+0x92>
    1cd0:	f0 93 cb 01 	sts	0x01CB, r31	; 0x8001cb <__flp+0x1>
    1cd4:	e0 93 ca 01 	sts	0x01CA, r30	; 0x8001ca <__flp>
    1cd8:	3d c0       	rjmp	.+122    	; 0x1d54 <free+0x10c>
    1cda:	e9 01       	movw	r28, r18
    1cdc:	fb 83       	std	Y+3, r31	; 0x03
    1cde:	ea 83       	std	Y+2, r30	; 0x02
    1ce0:	49 91       	ld	r20, Y+
    1ce2:	59 91       	ld	r21, Y+
    1ce4:	c4 0f       	add	r28, r20
    1ce6:	d5 1f       	adc	r29, r21
    1ce8:	ec 17       	cp	r30, r28
    1cea:	fd 07       	cpc	r31, r29
    1cec:	61 f4       	brne	.+24     	; 0x1d06 <free+0xbe>
    1cee:	80 81       	ld	r24, Z
    1cf0:	91 81       	ldd	r25, Z+1	; 0x01
    1cf2:	84 0f       	add	r24, r20
    1cf4:	95 1f       	adc	r25, r21
    1cf6:	02 96       	adiw	r24, 0x02	; 2
    1cf8:	e9 01       	movw	r28, r18
    1cfa:	99 83       	std	Y+1, r25	; 0x01
    1cfc:	88 83       	st	Y, r24
    1cfe:	82 81       	ldd	r24, Z+2	; 0x02
    1d00:	93 81       	ldd	r25, Z+3	; 0x03
    1d02:	9b 83       	std	Y+3, r25	; 0x03
    1d04:	8a 83       	std	Y+2, r24	; 0x02
    1d06:	e0 e0       	ldi	r30, 0x00	; 0
    1d08:	f0 e0       	ldi	r31, 0x00	; 0
    1d0a:	12 96       	adiw	r26, 0x02	; 2
    1d0c:	8d 91       	ld	r24, X+
    1d0e:	9c 91       	ld	r25, X
    1d10:	13 97       	sbiw	r26, 0x03	; 3
    1d12:	00 97       	sbiw	r24, 0x00	; 0
    1d14:	19 f0       	breq	.+6      	; 0x1d1c <free+0xd4>
    1d16:	fd 01       	movw	r30, r26
    1d18:	dc 01       	movw	r26, r24
    1d1a:	f7 cf       	rjmp	.-18     	; 0x1d0a <free+0xc2>
    1d1c:	8d 91       	ld	r24, X+
    1d1e:	9c 91       	ld	r25, X
    1d20:	11 97       	sbiw	r26, 0x01	; 1
    1d22:	9d 01       	movw	r18, r26
    1d24:	2e 5f       	subi	r18, 0xFE	; 254
    1d26:	3f 4f       	sbci	r19, 0xFF	; 255
    1d28:	82 0f       	add	r24, r18
    1d2a:	93 1f       	adc	r25, r19
    1d2c:	20 91 c8 01 	lds	r18, 0x01C8	; 0x8001c8 <__brkval>
    1d30:	30 91 c9 01 	lds	r19, 0x01C9	; 0x8001c9 <__brkval+0x1>
    1d34:	28 17       	cp	r18, r24
    1d36:	39 07       	cpc	r19, r25
    1d38:	69 f4       	brne	.+26     	; 0x1d54 <free+0x10c>
    1d3a:	30 97       	sbiw	r30, 0x00	; 0
    1d3c:	29 f4       	brne	.+10     	; 0x1d48 <free+0x100>
    1d3e:	10 92 cb 01 	sts	0x01CB, r1	; 0x8001cb <__flp+0x1>
    1d42:	10 92 ca 01 	sts	0x01CA, r1	; 0x8001ca <__flp>
    1d46:	02 c0       	rjmp	.+4      	; 0x1d4c <free+0x104>
    1d48:	13 82       	std	Z+3, r1	; 0x03
    1d4a:	12 82       	std	Z+2, r1	; 0x02
    1d4c:	b0 93 c9 01 	sts	0x01C9, r27	; 0x8001c9 <__brkval+0x1>
    1d50:	a0 93 c8 01 	sts	0x01C8, r26	; 0x8001c8 <__brkval>
    1d54:	df 91       	pop	r29
    1d56:	cf 91       	pop	r28
    1d58:	08 95       	ret

00001d5a <memcpy>:
    1d5a:	fb 01       	movw	r30, r22
    1d5c:	dc 01       	movw	r26, r24
    1d5e:	02 c0       	rjmp	.+4      	; 0x1d64 <memcpy+0xa>
    1d60:	01 90       	ld	r0, Z+
    1d62:	0d 92       	st	X+, r0
    1d64:	41 50       	subi	r20, 0x01	; 1
    1d66:	50 40       	sbci	r21, 0x00	; 0
    1d68:	d8 f7       	brcc	.-10     	; 0x1d60 <memcpy+0x6>
    1d6a:	08 95       	ret

00001d6c <memset>:
    1d6c:	dc 01       	movw	r26, r24
    1d6e:	01 c0       	rjmp	.+2      	; 0x1d72 <memset+0x6>
    1d70:	6d 93       	st	X+, r22
    1d72:	41 50       	subi	r20, 0x01	; 1
    1d74:	50 40       	sbci	r21, 0x00	; 0
    1d76:	e0 f7       	brcc	.-8      	; 0x1d70 <memset+0x4>
    1d78:	08 95       	ret

00001d7a <_exit>:
    1d7a:	f8 94       	cli

00001d7c <__stop_program>:
    1d7c:	ff cf       	rjmp	.-2      	; 0x1d7c <__stop_program>
