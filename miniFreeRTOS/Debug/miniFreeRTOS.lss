
miniFreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000024  00800100  00002924  000029b8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002924  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000ac  00800124  00800124  000029dc  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000029dc  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002a38  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000528  00000000  00000000  00002a78  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00007938  00000000  00000000  00002fa0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001842  00000000  00000000  0000a8d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003e5c  00000000  00000000  0000c11a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001184  00000000  00000000  0000ff78  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001f6d  00000000  00000000  000110fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000736a  00000000  00000000  00013069  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000860  00000000  00000000  0001a3d3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 81 00 	jmp	0x102	; 0x102 <__ctors_end>
       4:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
       8:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
       c:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      10:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      14:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      18:	0c 94 1f 06 	jmp	0xc3e	; 0xc3e <__vector_6>
      1c:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      20:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      24:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      28:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      2c:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      30:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      34:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      38:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      3c:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      40:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      44:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      48:	0c 94 25 04 	jmp	0x84a	; 0x84a <__vector_18>
      4c:	0c 94 80 04 	jmp	0x900	; 0x900 <__vector_19>
      50:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      54:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      58:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      5c:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      60:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      64:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
      68:	de 0f       	add	r29, r30
      6a:	de 0f       	add	r29, r30
      6c:	de 0f       	add	r29, r30
      6e:	19 10       	cpse	r1, r9
      70:	07 10       	cpse	r0, r7
      72:	16 10       	cpse	r1, r6
      74:	de 0f       	add	r29, r30
      76:	de 0f       	add	r29, r30
      78:	19 10       	cpse	r1, r9
      7a:	07 10       	cpse	r0, r7

0000007c <__trampolines_end>:
      7c:	52 65       	ori	r21, 0x52	; 82
      7e:	64 4c       	sbci	r22, 0xC4	; 196
      80:	45 44       	sbci	r20, 0x45	; 69
      82:	20 48       	sbci	r18, 0x80	; 128
      84:	69 67       	ori	r22, 0x79	; 121
      86:	68 57       	subi	r22, 0x78	; 120
      88:	61 74       	andi	r22, 0x41	; 65
      8a:	65 72       	andi	r22, 0x25	; 37
      8c:	20 40       	sbci	r18, 0x00	; 0
      8e:	20 25       	eor	r18, r0
      90:	75 0d       	add	r23, r5
      92:	0a 00       	.word	0x000a	; ????

00000094 <__c.2816>:
      94:	43 75 72 72 65 6e 74 20 54 69 6d 65 73 74 61 6d     Current Timestam
      a4:	70 3a 20 25 6c 75 20 78 54 61 73 6b 47 65 74 54     p: %lu xTaskGetT
      b4:	69 63 6b 43 6f 75 6e 74 28 29 3a 20 25 75 0d 0a     ickCount(): %u..
	...

000000c5 <__c.2803>:
      c5:	0d 0a 0a 0a 47 6f 6f 64 62 79 65 2e 2e 2e 20 6e     ....Goodbye... n
      d5:	6f 20 73 70 61 63 65 20 66 6f 72 20 69 64 6c 65     o space for idle
      e5:	20 74 61 73 6b 21 0d 0a 00                           task!...

000000ee <__c.2801>:
      ee:	0d 0a 0a 0a 48 65 6c 6c 6f 20 57 6f 72 6c 64 21     ....Hello World!
      fe:	0d 0a 00 00                                         ....

00000102 <__ctors_end>:
     102:	11 24       	eor	r1, r1
     104:	1f be       	out	0x3f, r1	; 63
     106:	cf ef       	ldi	r28, 0xFF	; 255
     108:	d8 e0       	ldi	r29, 0x08	; 8
     10a:	de bf       	out	0x3e, r29	; 62
     10c:	cd bf       	out	0x3d, r28	; 61

0000010e <__do_copy_data>:
     10e:	11 e0       	ldi	r17, 0x01	; 1
     110:	a0 e0       	ldi	r26, 0x00	; 0
     112:	b1 e0       	ldi	r27, 0x01	; 1
     114:	e4 e2       	ldi	r30, 0x24	; 36
     116:	f9 e2       	ldi	r31, 0x29	; 41
     118:	02 c0       	rjmp	.+4      	; 0x11e <__do_copy_data+0x10>
     11a:	05 90       	lpm	r0, Z+
     11c:	0d 92       	st	X+, r0
     11e:	a4 32       	cpi	r26, 0x24	; 36
     120:	b1 07       	cpc	r27, r17
     122:	d9 f7       	brne	.-10     	; 0x11a <__do_copy_data+0xc>

00000124 <__do_clear_bss>:
     124:	21 e0       	ldi	r18, 0x01	; 1
     126:	a4 e2       	ldi	r26, 0x24	; 36
     128:	b1 e0       	ldi	r27, 0x01	; 1
     12a:	01 c0       	rjmp	.+2      	; 0x12e <.do_clear_bss_start>

0000012c <.do_clear_bss_loop>:
     12c:	1d 92       	st	X+, r1

0000012e <.do_clear_bss_start>:
     12e:	a0 3d       	cpi	r26, 0xD0	; 208
     130:	b2 07       	cpc	r27, r18
     132:	e1 f7       	brne	.-8      	; 0x12c <.do_clear_bss_loop>
     134:	0e 94 03 02 	call	0x406	; 0x406 <main>
     138:	0c 94 90 14 	jmp	0x2920	; 0x2920 <_exit>

0000013c <__bad_interrupt>:
     13c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000140 <time>:
     140:	fc 01       	movw	r30, r24
     142:	0f b6       	in	r0, 0x3f	; 63
     144:	f8 94       	cli
     146:	60 91 cc 01 	lds	r22, 0x01CC	; 0x8001cc <__system_time>
     14a:	70 91 cd 01 	lds	r23, 0x01CD	; 0x8001cd <__system_time+0x1>
     14e:	80 91 ce 01 	lds	r24, 0x01CE	; 0x8001ce <__system_time+0x2>
     152:	90 91 cf 01 	lds	r25, 0x01CF	; 0x8001cf <__system_time+0x3>
     156:	0f be       	out	0x3f, r0	; 63
     158:	30 97       	sbiw	r30, 0x00	; 0
     15a:	21 f0       	breq	.+8      	; 0x164 <time+0x24>
     15c:	60 83       	st	Z, r22
     15e:	71 83       	std	Z+1, r23	; 0x01
     160:	82 83       	std	Z+2, r24	; 0x02
     162:	93 83       	std	Z+3, r25	; 0x03
     164:	08 95       	ret

00000166 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     166:	cf 93       	push	r28
     168:	df 93       	push	r29
     16a:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
     16c:	0e 94 ed 0a 	call	0x15da	; 0x15da <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
     170:	ce 01       	movw	r24, r28
     172:	0e 94 62 10 	call	0x20c4	; 0x20c4 <malloc>
     176:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     178:	0e 94 b8 0b 	call	0x1770	; 0x1770 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
     17c:	20 97       	sbiw	r28, 0x00	; 0
     17e:	11 f4       	brne	.+4      	; 0x184 <pvPortMalloc+0x1e>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
     180:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
}
     184:	ce 01       	movw	r24, r28
     186:	df 91       	pop	r29
     188:	cf 91       	pop	r28
     18a:	08 95       	ret

0000018c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     18c:	cf 93       	push	r28
     18e:	df 93       	push	r29
	if( pv )
     190:	00 97       	sbiw	r24, 0x00	; 0
     192:	41 f0       	breq	.+16     	; 0x1a4 <vPortFree+0x18>
     194:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
     196:	0e 94 ed 0a 	call	0x15da	; 0x15da <vTaskSuspendAll>
		{
			free( pv );
     19a:	ce 01       	movw	r24, r28
     19c:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
     1a0:	0e 94 b8 0b 	call	0x1770	; 0x1770 <xTaskResumeAll>
	}
}
     1a4:	df 91       	pop	r29
     1a6:	cf 91       	pop	r28
     1a8:	08 95       	ret

000001aa <vApplicationIdleHook>:

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // with 1284p
	DIDR0 = 0xFF;

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino with 328p
	DIDR0 = 0x3F;
     1aa:	8f e3       	ldi	r24, 0x3F	; 63
     1ac:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
	// When the ACD bit is written logic one, the power to the Analogue Comparator is switched off.
	// This bit can be set at any time to turn off the Analogue Comparator.
	// This will reduce power consumption in Active and Idle mode.
	// When changing the ACD bit, the Analogue Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR.
	// Otherwise an interrupt can occur when the ACD bit is changed.
	ACSR &= ~_BV(ACIE);
     1b0:	80 b7       	in	r24, 0x30	; 48
     1b2:	87 7f       	andi	r24, 0xF7	; 247
     1b4:	80 bf       	out	0x30, r24	; 48
	ACSR |=  _BV(ACD);
     1b6:	80 b7       	in	r24, 0x30	; 48
     1b8:	80 68       	ori	r24, 0x80	; 128
     1ba:	80 bf       	out	0x30, r24	; 48
	// SLEEP_MODE_PWR_DOWN     _BV(SM1)
	// SLEEP_MODE_PWR_SAVE     (_BV(SM0) | _BV(SM1))
	// SLEEP_MODE_STANDBY      (_BV(SM1) | _BV(SM2))
	// SLEEP_MODE_EXT_STANDBY  (_BV(SM0) | _BV(SM1) | _BV(SM2))

	set_sleep_mode( SLEEP_MODE_IDLE );
     1bc:	83 b7       	in	r24, 0x33	; 51
     1be:	81 7f       	andi	r24, 0xF1	; 241
     1c0:	83 bf       	out	0x33, r24	; 51

	portENTER_CRITICAL();
     1c2:	0f b6       	in	r0, 0x3f	; 63
     1c4:	f8 94       	cli
     1c6:	0f 92       	push	r0
	sleep_enable();
     1c8:	83 b7       	in	r24, 0x33	; 51
     1ca:	81 60       	ori	r24, 0x01	; 1
     1cc:	83 bf       	out	0x33, r24	; 51

#if defined(BODS) && defined(BODSE) // only if there is support to disable the BOD.
	sleep_bod_disable();
     1ce:	85 b7       	in	r24, 0x35	; 53
     1d0:	80 66       	ori	r24, 0x60	; 96
     1d2:	85 bf       	out	0x35, r24	; 53
     1d4:	8f 7d       	andi	r24, 0xDF	; 223
     1d6:	85 bf       	out	0x35, r24	; 53
#endif

	portEXIT_CRITICAL();
     1d8:	0f 90       	pop	r0
     1da:	0f be       	out	0x3f, r0	; 63
	sleep_cpu();		// good night.
     1dc:	88 95       	sleep

	sleep_reset();		// reset the sleep_mode() faster than sleep_disable();
     1de:	13 be       	out	0x33, r1	; 51
     1e0:	08 95       	ret

000001e2 <vApplicationMallocFailedHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Goldilocks with 1284p
	DDRB  |= _BV(DDB7);
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
	DDRB  |= _BV(DDB5);
     1e2:	25 9a       	sbi	0x04, 5	; 4
	PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
     1e4:	2d 9a       	sbi	0x05, 5	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     1e6:	2f e7       	ldi	r18, 0x7F	; 127
     1e8:	88 e3       	ldi	r24, 0x38	; 56
     1ea:	91 e0       	ldi	r25, 0x01	; 1
     1ec:	21 50       	subi	r18, 0x01	; 1
     1ee:	80 40       	sbci	r24, 0x00	; 0
     1f0:	90 40       	sbci	r25, 0x00	; 0
     1f2:	e1 f7       	brne	.-8      	; 0x1ec <vApplicationMallocFailedHook+0xa>
     1f4:	00 c0       	rjmp	.+0      	; 0x1f6 <vApplicationMallocFailedHook+0x14>
     1f6:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Goldilocks with 1284p
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
		PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED fast blink.
     1f8:	1d 9a       	sbi	0x03, 5	; 3
     1fa:	f5 cf       	rjmp	.-22     	; 0x1e6 <vApplicationMallocFailedHook+0x4>

000001fc <vApplicationStackOverflowHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Goldilocks with 1284p
	DDRB  |= _BV(DDB7);
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
	DDRB  |= _BV(DDB5);
     1fc:	25 9a       	sbi	0x04, 5	; 4
	PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
     1fe:	2d 9a       	sbi	0x05, 5	; 5
     200:	2f ef       	ldi	r18, 0xFF	; 255
     202:	83 ed       	ldi	r24, 0xD3	; 211
     204:	90 e3       	ldi	r25, 0x30	; 48
     206:	21 50       	subi	r18, 0x01	; 1
     208:	80 40       	sbci	r24, 0x00	; 0
     20a:	90 40       	sbci	r25, 0x00	; 0
     20c:	e1 f7       	brne	.-8      	; 0x206 <vApplicationStackOverflowHook+0xa>
     20e:	00 c0       	rjmp	.+0      	; 0x210 <vApplicationStackOverflowHook+0x14>
     210:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Goldilocks with 1284p
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
		PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED slow blink.
     212:	1d 9a       	sbi	0x03, 5	; 3
     214:	f5 cf       	rjmp	.-22     	; 0x200 <vApplicationStackOverflowHook+0x4>

00000216 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     216:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );
     218:	03 96       	adiw	r24, 0x03	; 3
     21a:	92 83       	std	Z+2, r25	; 0x02
     21c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     21e:	2f ef       	ldi	r18, 0xFF	; 255
     220:	3f ef       	ldi	r19, 0xFF	; 255
     222:	34 83       	std	Z+4, r19	; 0x04
     224:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );
     226:	96 83       	std	Z+6, r25	; 0x06
     228:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );
     22a:	90 87       	std	Z+8, r25	; 0x08
     22c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     22e:	10 82       	st	Z, r1
     230:	08 95       	ret

00000232 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     232:	fc 01       	movw	r30, r24
     234:	11 86       	std	Z+9, r1	; 0x09
     236:	10 86       	std	Z+8, r1	; 0x08
     238:	08 95       	ret

0000023a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     23a:	cf 93       	push	r28
     23c:	df 93       	push	r29
     23e:	9c 01       	movw	r18, r24
     240:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     242:	dc 01       	movw	r26, r24
     244:	11 96       	adiw	r26, 0x01	; 1
     246:	cd 91       	ld	r28, X+
     248:	dc 91       	ld	r29, X
     24a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     24c:	d3 83       	std	Z+3, r29	; 0x03
     24e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     250:	8c 81       	ldd	r24, Y+4	; 0x04
     252:	9d 81       	ldd	r25, Y+5	; 0x05
     254:	95 83       	std	Z+5, r25	; 0x05
     256:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     258:	8c 81       	ldd	r24, Y+4	; 0x04
     25a:	9d 81       	ldd	r25, Y+5	; 0x05
     25c:	dc 01       	movw	r26, r24
     25e:	13 96       	adiw	r26, 0x03	; 3
     260:	7c 93       	st	X, r23
     262:	6e 93       	st	-X, r22
     264:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     266:	7d 83       	std	Y+5, r23	; 0x05
     268:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     26a:	31 87       	std	Z+9, r19	; 0x09
     26c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     26e:	f9 01       	movw	r30, r18
     270:	80 81       	ld	r24, Z
     272:	8f 5f       	subi	r24, 0xFF	; 255
     274:	80 83       	st	Z, r24
}
     276:	df 91       	pop	r29
     278:	cf 91       	pop	r28
     27a:	08 95       	ret

0000027c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     27c:	cf 93       	push	r28
     27e:	df 93       	push	r29
     280:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     282:	48 81       	ld	r20, Y
     284:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     286:	4f 3f       	cpi	r20, 0xFF	; 255
     288:	2f ef       	ldi	r18, 0xFF	; 255
     28a:	52 07       	cpc	r21, r18
     28c:	21 f4       	brne	.+8      	; 0x296 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     28e:	fc 01       	movw	r30, r24
     290:	a7 81       	ldd	r26, Z+7	; 0x07
     292:	b0 85       	ldd	r27, Z+8	; 0x08
     294:	0d c0       	rjmp	.+26     	; 0x2b0 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     296:	dc 01       	movw	r26, r24
     298:	13 96       	adiw	r26, 0x03	; 3
     29a:	01 c0       	rjmp	.+2      	; 0x29e <vListInsert+0x22>
     29c:	df 01       	movw	r26, r30
     29e:	12 96       	adiw	r26, 0x02	; 2
     2a0:	ed 91       	ld	r30, X+
     2a2:	fc 91       	ld	r31, X
     2a4:	13 97       	sbiw	r26, 0x03	; 3
     2a6:	20 81       	ld	r18, Z
     2a8:	31 81       	ldd	r19, Z+1	; 0x01
     2aa:	42 17       	cp	r20, r18
     2ac:	53 07       	cpc	r21, r19
     2ae:	b0 f7       	brcc	.-20     	; 0x29c <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     2b0:	12 96       	adiw	r26, 0x02	; 2
     2b2:	ed 91       	ld	r30, X+
     2b4:	fc 91       	ld	r31, X
     2b6:	13 97       	sbiw	r26, 0x03	; 3
     2b8:	fb 83       	std	Y+3, r31	; 0x03
     2ba:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     2bc:	d5 83       	std	Z+5, r29	; 0x05
     2be:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     2c0:	bd 83       	std	Y+5, r27	; 0x05
     2c2:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     2c4:	13 96       	adiw	r26, 0x03	; 3
     2c6:	dc 93       	st	X, r29
     2c8:	ce 93       	st	-X, r28
     2ca:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     2cc:	99 87       	std	Y+9, r25	; 0x09
     2ce:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     2d0:	fc 01       	movw	r30, r24
     2d2:	20 81       	ld	r18, Z
     2d4:	2f 5f       	subi	r18, 0xFF	; 255
     2d6:	20 83       	st	Z, r18
}
     2d8:	df 91       	pop	r29
     2da:	cf 91       	pop	r28
     2dc:	08 95       	ret

000002de <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     2de:	cf 93       	push	r28
     2e0:	df 93       	push	r29
     2e2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     2e4:	a0 85       	ldd	r26, Z+8	; 0x08
     2e6:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     2e8:	c2 81       	ldd	r28, Z+2	; 0x02
     2ea:	d3 81       	ldd	r29, Z+3	; 0x03
     2ec:	84 81       	ldd	r24, Z+4	; 0x04
     2ee:	95 81       	ldd	r25, Z+5	; 0x05
     2f0:	9d 83       	std	Y+5, r25	; 0x05
     2f2:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     2f4:	c4 81       	ldd	r28, Z+4	; 0x04
     2f6:	d5 81       	ldd	r29, Z+5	; 0x05
     2f8:	82 81       	ldd	r24, Z+2	; 0x02
     2fa:	93 81       	ldd	r25, Z+3	; 0x03
     2fc:	9b 83       	std	Y+3, r25	; 0x03
     2fe:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     300:	11 96       	adiw	r26, 0x01	; 1
     302:	8d 91       	ld	r24, X+
     304:	9c 91       	ld	r25, X
     306:	12 97       	sbiw	r26, 0x02	; 2
     308:	e8 17       	cp	r30, r24
     30a:	f9 07       	cpc	r31, r25
     30c:	31 f4       	brne	.+12     	; 0x31a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     30e:	84 81       	ldd	r24, Z+4	; 0x04
     310:	95 81       	ldd	r25, Z+5	; 0x05
     312:	12 96       	adiw	r26, 0x02	; 2
     314:	9c 93       	st	X, r25
     316:	8e 93       	st	-X, r24
     318:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     31a:	11 86       	std	Z+9, r1	; 0x09
     31c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     31e:	8c 91       	ld	r24, X
     320:	81 50       	subi	r24, 0x01	; 1
     322:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     324:	8c 91       	ld	r24, X
}
     326:	df 91       	pop	r29
     328:	cf 91       	pop	r28
     32a:	08 95       	ret

0000032c <TaskBlinkGreenLED>:

}

/*-----------------------------------------------------------*/
static void TaskBlinkGreenLED(void *pvParameters) // Main Green LED Flash
{
     32c:	cf 93       	push	r28
     32e:	df 93       	push	r29
     330:	00 d0       	rcall	.+0      	; 0x332 <TaskBlinkGreenLED+0x6>
     332:	cd b7       	in	r28, 0x3d	; 61
     334:	de b7       	in	r29, 0x3e	; 62
    TickType_t xLastWakeTime;
	/* The xLastWakeTime variable needs to be initialised with the current tick
	count.  Note that this is the only time we access this variable.  From this
	point on xLastWakeTime is managed automatically by the vTaskDelayUntil()
	API function. */
	xLastWakeTime = xTaskGetTickCount();
     336:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <xTaskGetTickCount>
     33a:	9a 83       	std	Y+2, r25	; 0x02
     33c:	89 83       	std	Y+1, r24	; 0x01

	//DDRB |= _BV(DDB5);
	DDRB |= _BV(DDB1);
     33e:	21 9a       	sbi	0x04, 1	; 4
		//PORTB &= ~_BV(PORTB5);       // main (red PB5) LED off. Arduino LED off
		PORTB &= ~_BV(PORTB1);

		vTaskDelayUntil( &xLastWakeTime, ( 500 / portTICK_PERIOD_MS )  );

		xSerialxPrintf_P(&xSerialPort, PSTR("Current Timestamp: %lu xTaskGetTickCount(): %u\r\n"), time(NULL), xTaskGetTickCount());
     340:	0f 2e       	mov	r0, r31
     342:	f4 e9       	ldi	r31, 0x94	; 148
     344:	ef 2e       	mov	r14, r31
     346:	f0 e0       	ldi	r31, 0x00	; 0
     348:	ff 2e       	mov	r15, r31
     34a:	f0 2d       	mov	r31, r0
     34c:	06 ea       	ldi	r16, 0xA6	; 166
     34e:	11 e0       	ldi	r17, 0x01	; 1
	DDRB |= _BV(DDB1);

    for(;;)
    {
    	//PORTB |=  _BV(PORTB5);       // main (red PB5) LED on. Arduino LED on
		PORTB |=  _BV(PORTB1);
     350:	29 9a       	sbi	0x05, 1	; 5
		
		vTaskDelayUntil( &xLastWakeTime, ( 500 / portTICK_PERIOD_MS ) );
     352:	6f e1       	ldi	r22, 0x1F	; 31
     354:	70 e0       	ldi	r23, 0x00	; 0
     356:	ce 01       	movw	r24, r28
     358:	01 96       	adiw	r24, 0x01	; 1
     35a:	0e 94 37 0c 	call	0x186e	; 0x186e <vTaskDelayUntil>

		//PORTB &= ~_BV(PORTB5);       // main (red PB5) LED off. Arduino LED off
		PORTB &= ~_BV(PORTB1);
     35e:	29 98       	cbi	0x05, 1	; 5

		vTaskDelayUntil( &xLastWakeTime, ( 500 / portTICK_PERIOD_MS )  );
     360:	6f e1       	ldi	r22, 0x1F	; 31
     362:	70 e0       	ldi	r23, 0x00	; 0
     364:	ce 01       	movw	r24, r28
     366:	01 96       	adiw	r24, 0x01	; 1
     368:	0e 94 37 0c 	call	0x186e	; 0x186e <vTaskDelayUntil>

		xSerialxPrintf_P(&xSerialPort, PSTR("Current Timestamp: %lu xTaskGetTickCount(): %u\r\n"), time(NULL), xTaskGetTickCount());
     36c:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <xTaskGetTickCount>
     370:	d8 2e       	mov	r13, r24
     372:	c9 2e       	mov	r12, r25
     374:	80 e0       	ldi	r24, 0x00	; 0
     376:	90 e0       	ldi	r25, 0x00	; 0
     378:	0e 94 a0 00 	call	0x140	; 0x140 <time>
     37c:	cf 92       	push	r12
     37e:	df 92       	push	r13
     380:	9f 93       	push	r25
     382:	8f 93       	push	r24
     384:	7f 93       	push	r23
     386:	6f 93       	push	r22
     388:	ff 92       	push	r15
     38a:	ef 92       	push	r14
     38c:	1f 93       	push	r17
     38e:	0f 93       	push	r16
     390:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <xSerialxPrintf_P>
     394:	0f b6       	in	r0, 0x3f	; 63
     396:	f8 94       	cli
     398:	de bf       	out	0x3e, r29	; 62
     39a:	0f be       	out	0x3f, r0	; 63
     39c:	cd bf       	out	0x3d, r28	; 61
     39e:	d8 cf       	rjmp	.-80     	; 0x350 <TaskBlinkGreenLED+0x24>

000003a0 <TaskBlinkRedLED>:

/*-----------------------------------------------------------*/


static void TaskBlinkRedLED(void *pvParameters) // Main Red LED Flash
{
     3a0:	cf 93       	push	r28
     3a2:	df 93       	push	r29
     3a4:	00 d0       	rcall	.+0      	; 0x3a6 <TaskBlinkRedLED+0x6>
     3a6:	cd b7       	in	r28, 0x3d	; 61
     3a8:	de b7       	in	r29, 0x3e	; 62
    TickType_t xLastWakeTime;
	/* The xLastWakeTime variable needs to be initialised with the current tick
	count.  Note that this is the only time we access this variable.  From this
	point on xLastWakeTime is managed automatically by the vTaskDelayUntil()
	API function. */
	xLastWakeTime = xTaskGetTickCount();
     3aa:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <xTaskGetTickCount>
     3ae:	9a 83       	std	Y+2, r25	; 0x02
     3b0:	89 83       	std	Y+1, r24	; 0x01
	lcd_Init();
#endif
*/

	//DDRB |= _BV(DDB7);
	DDRD |= _BV(DDD7);
     3b2:	57 9a       	sbi	0x0a, 7	; 10
		//PORTB &= ~_BV(PORTB7);       // main (red IO_B7) LED off. EtherMega LED off
		PORTD &= ~_BV(PORTD7);

		vTaskDelayUntil( &xLastWakeTime, ( 500 / portTICK_PERIOD_MS ) );

		xSerialxPrintf_P(&xSerialPort, PSTR("RedLED HighWater @ %u\r\n"), uxTaskGetStackHighWaterMark(NULL));
     3b4:	0f 2e       	mov	r0, r31
     3b6:	fc e7       	ldi	r31, 0x7C	; 124
     3b8:	ef 2e       	mov	r14, r31
     3ba:	f0 e0       	ldi	r31, 0x00	; 0
     3bc:	ff 2e       	mov	r15, r31
     3be:	f0 2d       	mov	r31, r0
     3c0:	06 ea       	ldi	r16, 0xA6	; 166
     3c2:	11 e0       	ldi	r17, 0x01	; 1

    for(;;)
    {

    	//PORTB |=  _BV(PORTB7);       // main (red IO_B7) LED on. EtherMega LED on
		PORTD |=  _BV(PORTD7);
     3c4:	5f 9a       	sbi	0x0b, 7	; 11
		
		vTaskDelayUntil( &xLastWakeTime, ( 500 / portTICK_PERIOD_MS ) );
     3c6:	6f e1       	ldi	r22, 0x1F	; 31
     3c8:	70 e0       	ldi	r23, 0x00	; 0
     3ca:	ce 01       	movw	r24, r28
     3cc:	01 96       	adiw	r24, 0x01	; 1
     3ce:	0e 94 37 0c 	call	0x186e	; 0x186e <vTaskDelayUntil>

#endif
*/

		//PORTB &= ~_BV(PORTB7);       // main (red IO_B7) LED off. EtherMega LED off
		PORTD &= ~_BV(PORTD7);
     3d2:	5f 98       	cbi	0x0b, 7	; 11

		vTaskDelayUntil( &xLastWakeTime, ( 500 / portTICK_PERIOD_MS ) );
     3d4:	6f e1       	ldi	r22, 0x1F	; 31
     3d6:	70 e0       	ldi	r23, 0x00	; 0
     3d8:	ce 01       	movw	r24, r28
     3da:	01 96       	adiw	r24, 0x01	; 1
     3dc:	0e 94 37 0c 	call	0x186e	; 0x186e <vTaskDelayUntil>

		xSerialxPrintf_P(&xSerialPort, PSTR("RedLED HighWater @ %u\r\n"), uxTaskGetStackHighWaterMark(NULL));
     3e0:	80 e0       	ldi	r24, 0x00	; 0
     3e2:	90 e0       	ldi	r25, 0x00	; 0
     3e4:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <uxTaskGetStackHighWaterMark>
     3e8:	9f 93       	push	r25
     3ea:	8f 93       	push	r24
     3ec:	ff 92       	push	r15
     3ee:	ef 92       	push	r14
     3f0:	1f 93       	push	r17
     3f2:	0f 93       	push	r16
     3f4:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <xSerialxPrintf_P>
     3f8:	0f 90       	pop	r0
     3fa:	0f 90       	pop	r0
     3fc:	0f 90       	pop	r0
     3fe:	0f 90       	pop	r0
     400:	0f 90       	pop	r0
     402:	0f 90       	pop	r0
     404:	df cf       	rjmp	.-66     	; 0x3c4 <TaskBlinkRedLED+0x24>

00000406 <main>:

/* Main program loop */
int main(void) __attribute__ ((OS_main));

int main(void)
{
     406:	cd b7       	in	r28, 0x3d	; 61
     408:	de b7       	in	r29, 0x3e	; 62
     40a:	a2 97       	sbiw	r28, 0x22	; 34
     40c:	de bf       	out	0x3e, r29	; 62
     40e:	cd bf       	out	0x3d, r28	; 61
    // turn on the serial port for debugging or for other USART reasons.
	xSerialPort = xSerialPortInitMinimal( USART0, 115200, portSERIAL_BUFFER_TX, portSERIAL_BUFFER_RX); //  serial port: WantedBaud, TxQueueLength, RxQueueLength (8n1)
     410:	68 94       	set
     412:	ee 24       	eor	r14, r14
     414:	e5 f8       	bld	r14, 5
     416:	f1 2c       	mov	r15, r1
     418:	00 e8       	ldi	r16, 0x80	; 128
     41a:	10 e0       	ldi	r17, 0x00	; 0
     41c:	20 e0       	ldi	r18, 0x00	; 0
     41e:	32 ec       	ldi	r19, 0xC2	; 194
     420:	41 e0       	ldi	r20, 0x01	; 1
     422:	50 e0       	ldi	r21, 0x00	; 0
     424:	60 e0       	ldi	r22, 0x00	; 0
     426:	ce 01       	movw	r24, r28
     428:	01 96       	adiw	r24, 0x01	; 1
     42a:	0e 94 01 03 	call	0x602	; 0x602 <xSerialPortInitMinimal>
     42e:	82 e2       	ldi	r24, 0x22	; 34
     430:	fe 01       	movw	r30, r28
     432:	31 96       	adiw	r30, 0x01	; 1
     434:	a6 ea       	ldi	r26, 0xA6	; 166
     436:	b1 e0       	ldi	r27, 0x01	; 1
     438:	01 90       	ld	r0, Z+
     43a:	0d 92       	st	X+, r0
     43c:	8a 95       	dec	r24
     43e:	e1 f7       	brne	.-8      	; 0x438 <main+0x32>

	avrSerialxPrint_P(&xSerialPort, PSTR("\r\n\n\nHello World!\r\n")); // Ok, so we're alive...
     440:	6e ee       	ldi	r22, 0xEE	; 238
     442:	70 e0       	ldi	r23, 0x00	; 0
     444:	86 ea       	ldi	r24, 0xA6	; 166
     446:	91 e0       	ldi	r25, 0x01	; 1
     448:	0e 94 ee 03 	call	0x7dc	; 0x7dc <avrSerialxPrint_P>

    xTaskCreate(
     44c:	e1 2c       	mov	r14, r1
     44e:	f1 2c       	mov	r15, r1
     450:	03 e0       	ldi	r16, 0x03	; 3
     452:	20 e0       	ldi	r18, 0x00	; 0
     454:	30 e0       	ldi	r19, 0x00	; 0
     456:	40 e0       	ldi	r20, 0x00	; 0
     458:	51 e0       	ldi	r21, 0x01	; 1
     45a:	66 e0       	ldi	r22, 0x06	; 6
     45c:	71 e0       	ldi	r23, 0x01	; 1
     45e:	80 ed       	ldi	r24, 0xD0	; 208
     460:	91 e0       	ldi	r25, 0x01	; 1
     462:	0e 94 a8 09 	call	0x1350	; 0x1350 <xTaskCreate>
		,  256				// Tested 9 free @ 208
		,  NULL
		,  3
		,  NULL ); // */

    xTaskCreate(
     466:	20 e0       	ldi	r18, 0x00	; 0
     468:	30 e0       	ldi	r19, 0x00	; 0
     46a:	40 e0       	ldi	r20, 0x00	; 0
     46c:	51 e0       	ldi	r21, 0x01	; 1
     46e:	6d e0       	ldi	r22, 0x0D	; 13
     470:	71 e0       	ldi	r23, 0x01	; 1
     472:	86 e9       	ldi	r24, 0x96	; 150
     474:	91 e0       	ldi	r25, 0x01	; 1
     476:	0e 94 a8 09 	call	0x1350	; 0x1350 <xTaskCreate>


	//arek: not in heap3.c
	//avrSerialxPrintf_P(&xSerialPort, PSTR("Free Heap Size: %u\r\n"), xPortGetFreeHeapSize() ); // needs heap_1,  heap_2 or heap_4 for this function to succeed.
	//avrSerialxPrintf_P(&xSerialPort, PSTR("Minimum Free Heap Size: %u\r\n"), xPortGetMinimumEverFreeHeapSize() ); // needs heap_4 for this function to succeed.
	vTaskStartScheduler();
     47a:	0e 94 bf 0a 	call	0x157e	; 0x157e <vTaskStartScheduler>

	avrSerialxPrint_P(&xSerialPort, PSTR("\r\n\n\nGoodbye... no space for idle task!\r\n")); // Doh, so we're dead...
     47e:	65 ec       	ldi	r22, 0xC5	; 197
     480:	70 e0       	ldi	r23, 0x00	; 0
     482:	86 ea       	ldi	r24, 0xA6	; 166
     484:	91 e0       	ldi	r25, 0x01	; 1
     486:	0e 94 ee 03 	call	0x7dc	; 0x7dc <avrSerialxPrint_P>

}
     48a:	80 e0       	ldi	r24, 0x00	; 0
     48c:	90 e0       	ldi	r25, 0x00	; 0
     48e:	a2 96       	adiw	r28, 0x22	; 34
     490:	0f b6       	in	r0, 0x3f	; 63
     492:	f8 94       	cli
     494:	de bf       	out	0x3e, r29	; 62
     496:	0f be       	out	0x3f, r0	; 63
     498:	cd bf       	out	0x3d, r28	; 61
     49a:	08 95       	ret

0000049c <xSerialxPrint>:

		default:
			break;
	}
	return 0;
}
     49c:	ef 92       	push	r14
     49e:	ff 92       	push	r15
     4a0:	0f 93       	push	r16
     4a2:	1f 93       	push	r17
     4a4:	cf 93       	push	r28
     4a6:	df 93       	push	r29
     4a8:	ec 01       	movw	r28, r24
     4aa:	fb 01       	movw	r30, r22
     4ac:	01 90       	ld	r0, Z+
     4ae:	00 20       	and	r0, r0
     4b0:	e9 f7       	brne	.-6      	; 0x4ac <xSerialxPrint+0x10>
     4b2:	7b 01       	movw	r14, r22
     4b4:	cf 01       	movw	r24, r30
     4b6:	01 97       	sbiw	r24, 0x01	; 1
     4b8:	61 ec       	ldi	r22, 0xC1	; 193
     4ba:	70 e0       	ldi	r23, 0x00	; 0
     4bc:	ae 01       	movw	r20, r28
     4be:	43 5f       	subi	r20, 0xF3	; 243
     4c0:	5f 4f       	sbci	r21, 0xFF	; 255
     4c2:	67 c0       	rjmp	.+206    	; 0x592 <xSerialxPrint+0xf6>
     4c4:	d7 01       	movw	r26, r14
     4c6:	1d 91       	ld	r17, X+
     4c8:	7d 01       	movw	r14, r26
     4ca:	0f b6       	in	r0, 0x3f	; 63
     4cc:	f8 94       	cli
     4ce:	0f 92       	push	r0
     4d0:	ed 85       	ldd	r30, Y+13	; 0x0d
     4d2:	fe 85       	ldd	r31, Y+14	; 0x0e
     4d4:	0f 90       	pop	r0
     4d6:	0f be       	out	0x3f, r0	; 63
     4d8:	2f 89       	ldd	r18, Y+23	; 0x17
     4da:	38 8d       	ldd	r19, Y+24	; 0x18
     4dc:	e2 17       	cp	r30, r18
     4de:	f3 07       	cpc	r31, r19
     4e0:	01 f1       	breq	.+64     	; 0x522 <xSerialxPrint+0x86>
     4e2:	fa 01       	movw	r30, r20
     4e4:	22 81       	ldd	r18, Z+2	; 0x02
     4e6:	33 81       	ldd	r19, Z+3	; 0x03
     4e8:	d9 01       	movw	r26, r18
     4ea:	1c 93       	st	X, r17
     4ec:	22 81       	ldd	r18, Z+2	; 0x02
     4ee:	33 81       	ldd	r19, Z+3	; 0x03
     4f0:	2f 5f       	subi	r18, 0xFF	; 255
     4f2:	3f 4f       	sbci	r19, 0xFF	; 255
     4f4:	33 83       	std	Z+3, r19	; 0x03
     4f6:	22 83       	std	Z+2, r18	; 0x02
     4f8:	00 85       	ldd	r16, Z+8	; 0x08
     4fa:	11 85       	ldd	r17, Z+9	; 0x09
     4fc:	20 17       	cp	r18, r16
     4fe:	31 07       	cpc	r19, r17
     500:	21 f4       	brne	.+8      	; 0x50a <xSerialxPrint+0x6e>
     502:	26 81       	ldd	r18, Z+6	; 0x06
     504:	37 81       	ldd	r19, Z+7	; 0x07
     506:	33 83       	std	Z+3, r19	; 0x03
     508:	22 83       	std	Z+2, r18	; 0x02
     50a:	0f b6       	in	r0, 0x3f	; 63
     50c:	f8 94       	cli
     50e:	0f 92       	push	r0
     510:	20 81       	ld	r18, Z
     512:	31 81       	ldd	r19, Z+1	; 0x01
     514:	2f 5f       	subi	r18, 0xFF	; 255
     516:	3f 4f       	sbci	r19, 0xFF	; 255
     518:	31 83       	std	Z+1, r19	; 0x01
     51a:	20 83       	st	Z, r18
     51c:	0f 90       	pop	r0
     51e:	0f be       	out	0x3f, r0	; 63
     520:	31 c0       	rjmp	.+98     	; 0x584 <xSerialxPrint+0xe8>
     522:	ef ef       	ldi	r30, 0xFF	; 255
     524:	f9 ef       	ldi	r31, 0xF9	; 249
     526:	31 97       	sbiw	r30, 0x01	; 1
     528:	f1 f7       	brne	.-4      	; 0x526 <xSerialxPrint+0x8a>
     52a:	00 c0       	rjmp	.+0      	; 0x52c <xSerialxPrint+0x90>
     52c:	00 00       	nop
     52e:	0f b6       	in	r0, 0x3f	; 63
     530:	f8 94       	cli
     532:	0f 92       	push	r0
     534:	ed 85       	ldd	r30, Y+13	; 0x0d
     536:	fe 85       	ldd	r31, Y+14	; 0x0e
     538:	0f 90       	pop	r0
     53a:	0f be       	out	0x3f, r0	; 63
     53c:	2f 89       	ldd	r18, Y+23	; 0x17
     53e:	38 8d       	ldd	r19, Y+24	; 0x18
     540:	e2 17       	cp	r30, r18
     542:	f3 07       	cpc	r31, r19
     544:	31 f1       	breq	.+76     	; 0x592 <xSerialxPrint+0xf6>
     546:	fa 01       	movw	r30, r20
     548:	22 81       	ldd	r18, Z+2	; 0x02
     54a:	33 81       	ldd	r19, Z+3	; 0x03
     54c:	d9 01       	movw	r26, r18
     54e:	1c 93       	st	X, r17
     550:	22 81       	ldd	r18, Z+2	; 0x02
     552:	33 81       	ldd	r19, Z+3	; 0x03
     554:	2f 5f       	subi	r18, 0xFF	; 255
     556:	3f 4f       	sbci	r19, 0xFF	; 255
     558:	33 83       	std	Z+3, r19	; 0x03
     55a:	22 83       	std	Z+2, r18	; 0x02
     55c:	00 85       	ldd	r16, Z+8	; 0x08
     55e:	11 85       	ldd	r17, Z+9	; 0x09
     560:	20 17       	cp	r18, r16
     562:	31 07       	cpc	r19, r17
     564:	21 f4       	brne	.+8      	; 0x56e <xSerialxPrint+0xd2>
     566:	26 81       	ldd	r18, Z+6	; 0x06
     568:	37 81       	ldd	r19, Z+7	; 0x07
     56a:	33 83       	std	Z+3, r19	; 0x03
     56c:	22 83       	std	Z+2, r18	; 0x02
     56e:	0f b6       	in	r0, 0x3f	; 63
     570:	f8 94       	cli
     572:	0f 92       	push	r0
     574:	20 81       	ld	r18, Z
     576:	31 81       	ldd	r19, Z+1	; 0x01
     578:	2f 5f       	subi	r18, 0xFF	; 255
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	31 83       	std	Z+1, r19	; 0x01
     57e:	20 83       	st	Z, r18
     580:	0f 90       	pop	r0
     582:	0f be       	out	0x3f, r0	; 63
     584:	28 81       	ld	r18, Y
     586:	22 30       	cpi	r18, 0x02	; 2
     588:	20 f4       	brcc	.+8      	; 0x592 <xSerialxPrint+0xf6>
     58a:	fb 01       	movw	r30, r22
     58c:	20 81       	ld	r18, Z
     58e:	20 62       	ori	r18, 0x20	; 32
     590:	20 83       	st	Z, r18
     592:	e8 16       	cp	r14, r24
     594:	f9 06       	cpc	r15, r25
     596:	09 f0       	breq	.+2      	; 0x59a <xSerialxPrint+0xfe>
     598:	95 cf       	rjmp	.-214    	; 0x4c4 <xSerialxPrint+0x28>
     59a:	df 91       	pop	r29
     59c:	cf 91       	pop	r28
     59e:	1f 91       	pop	r17
     5a0:	0f 91       	pop	r16
     5a2:	ff 90       	pop	r15
     5a4:	ef 90       	pop	r14
     5a6:	08 95       	ret

000005a8 <xSerialxPrintf_P>:
     5a8:	0f 93       	push	r16
     5aa:	1f 93       	push	r17
     5ac:	cf 93       	push	r28
     5ae:	df 93       	push	r29
     5b0:	cd b7       	in	r28, 0x3d	; 61
     5b2:	de b7       	in	r29, 0x3e	; 62
     5b4:	0f 81       	ldd	r16, Y+7	; 0x07
     5b6:	18 85       	ldd	r17, Y+8	; 0x08
     5b8:	f8 01       	movw	r30, r16
     5ba:	85 8d       	ldd	r24, Z+29	; 0x1d
     5bc:	81 30       	cpi	r24, 0x01	; 1
     5be:	31 f4       	brne	.+12     	; 0x5cc <xSerialxPrintf_P+0x24>
     5c0:	0e 94 69 05 	call	0xad2	; 0xad2 <vPortYield>
     5c4:	f8 01       	movw	r30, r16
     5c6:	85 8d       	ldd	r24, Z+29	; 0x1d
     5c8:	81 30       	cpi	r24, 0x01	; 1
     5ca:	d1 f3       	breq	.-12     	; 0x5c0 <xSerialxPrintf_P+0x18>
     5cc:	81 e0       	ldi	r24, 0x01	; 1
     5ce:	f8 01       	movw	r30, r16
     5d0:	85 8f       	std	Z+29, r24	; 0x1d
     5d2:	63 8d       	ldd	r22, Z+27	; 0x1b
     5d4:	74 8d       	ldd	r23, Z+28	; 0x1c
     5d6:	9e 01       	movw	r18, r28
     5d8:	25 5f       	subi	r18, 0xF5	; 245
     5da:	3f 4f       	sbci	r19, 0xFF	; 255
     5dc:	49 85       	ldd	r20, Y+9	; 0x09
     5de:	5a 85       	ldd	r21, Y+10	; 0x0a
     5e0:	81 8d       	ldd	r24, Z+25	; 0x19
     5e2:	92 8d       	ldd	r25, Z+26	; 0x1a
     5e4:	0e 94 9c 11 	call	0x2338	; 0x2338 <vsnprintf_P>
     5e8:	f8 01       	movw	r30, r16
     5ea:	61 8d       	ldd	r22, Z+25	; 0x19
     5ec:	72 8d       	ldd	r23, Z+26	; 0x1a
     5ee:	c8 01       	movw	r24, r16
     5f0:	0e 94 4e 02 	call	0x49c	; 0x49c <xSerialxPrint>
     5f4:	f8 01       	movw	r30, r16
     5f6:	15 8e       	std	Z+29, r1	; 0x1d
     5f8:	df 91       	pop	r29
     5fa:	cf 91       	pop	r28
     5fc:	1f 91       	pop	r17
     5fe:	0f 91       	pop	r16
     600:	08 95       	ret

00000602 <xSerialPortInitMinimal>:
     602:	7f 92       	push	r7
     604:	8f 92       	push	r8
     606:	9f 92       	push	r9
     608:	af 92       	push	r10
     60a:	bf 92       	push	r11
     60c:	cf 92       	push	r12
     60e:	df 92       	push	r13
     610:	ef 92       	push	r14
     612:	ff 92       	push	r15
     614:	0f 93       	push	r16
     616:	1f 93       	push	r17
     618:	cf 93       	push	r28
     61a:	df 93       	push	r29
     61c:	cd b7       	in	r28, 0x3d	; 61
     61e:	de b7       	in	r29, 0x3e	; 62
     620:	a2 97       	sbiw	r28, 0x22	; 34
     622:	0f b6       	in	r0, 0x3f	; 63
     624:	f8 94       	cli
     626:	de bf       	out	0x3e, r29	; 62
     628:	0f be       	out	0x3f, r0	; 63
     62a:	cd bf       	out	0x3d, r28	; 61
     62c:	6c 01       	movw	r12, r24
     62e:	76 2e       	mov	r7, r22
     630:	49 01       	movw	r8, r18
     632:	5a 01       	movw	r10, r20
     634:	c7 01       	movw	r24, r14
     636:	0e 94 b3 00 	call	0x166	; 0x166 <pvPortMalloc>
     63a:	00 97       	sbiw	r24, 0x00	; 0
     63c:	a9 f0       	breq	.+42     	; 0x668 <xSerialPortInitMinimal+0x66>
     63e:	fe 01       	movw	r30, r28
     640:	32 96       	adiw	r30, 0x02	; 2
     642:	0f b6       	in	r0, 0x3f	; 63
     644:	f8 94       	cli
     646:	0f 92       	push	r0
     648:	11 82       	std	Z+1, r1	; 0x01
     64a:	10 82       	st	Z, r1
     64c:	93 83       	std	Z+3, r25	; 0x03
     64e:	82 83       	std	Z+2, r24	; 0x02
     650:	95 83       	std	Z+5, r25	; 0x05
     652:	84 83       	std	Z+4, r24	; 0x04
     654:	97 83       	std	Z+7, r25	; 0x07
     656:	86 83       	std	Z+6, r24	; 0x06
     658:	8e 0d       	add	r24, r14
     65a:	9f 1d       	adc	r25, r15
     65c:	91 87       	std	Z+9, r25	; 0x09
     65e:	80 87       	std	Z+8, r24	; 0x08
     660:	f3 86       	std	Z+11, r15	; 0x0b
     662:	e2 86       	std	Z+10, r14	; 0x0a
     664:	0f 90       	pop	r0
     666:	0f be       	out	0x3f, r0	; 63
     668:	c8 01       	movw	r24, r16
     66a:	0e 94 b3 00 	call	0x166	; 0x166 <pvPortMalloc>
     66e:	00 97       	sbiw	r24, 0x00	; 0
     670:	a9 f0       	breq	.+42     	; 0x69c <xSerialPortInitMinimal+0x9a>
     672:	fe 01       	movw	r30, r28
     674:	3e 96       	adiw	r30, 0x0e	; 14
     676:	0f b6       	in	r0, 0x3f	; 63
     678:	f8 94       	cli
     67a:	0f 92       	push	r0
     67c:	11 82       	std	Z+1, r1	; 0x01
     67e:	10 82       	st	Z, r1
     680:	93 83       	std	Z+3, r25	; 0x03
     682:	82 83       	std	Z+2, r24	; 0x02
     684:	95 83       	std	Z+5, r25	; 0x05
     686:	84 83       	std	Z+4, r24	; 0x04
     688:	97 83       	std	Z+7, r25	; 0x07
     68a:	86 83       	std	Z+6, r24	; 0x06
     68c:	80 0f       	add	r24, r16
     68e:	91 1f       	adc	r25, r17
     690:	91 87       	std	Z+9, r25	; 0x09
     692:	80 87       	std	Z+8, r24	; 0x08
     694:	13 87       	std	Z+11, r17	; 0x0b
     696:	02 87       	std	Z+10, r16	; 0x0a
     698:	0f 90       	pop	r0
     69a:	0f be       	out	0x3f, r0	; 63
     69c:	c8 01       	movw	r24, r16
     69e:	0e 94 b3 00 	call	0x166	; 0x166 <pvPortMalloc>
     6a2:	9b 8f       	std	Y+27, r25	; 0x1b
     6a4:	8a 8f       	std	Y+26, r24	; 0x1a
     6a6:	79 82       	std	Y+1, r7	; 0x01
     6a8:	1d 8f       	std	Y+29, r17	; 0x1d
     6aa:	0c 8f       	std	Y+28, r16	; 0x1c
     6ac:	1e 8e       	std	Y+30, r1	; 0x1e
     6ae:	8f 8e       	std	Y+31, r8	; 0x1f
     6b0:	98 a2       	std	Y+32, r9	; 0x20
     6b2:	a9 a2       	std	Y+33, r10	; 0x21
     6b4:	ba a2       	std	Y+34, r11	; 0x22
     6b6:	0f b6       	in	r0, 0x3f	; 63
     6b8:	f8 94       	cli
     6ba:	0f 92       	push	r0
     6bc:	89 81       	ldd	r24, Y+1	; 0x01
     6be:	88 23       	and	r24, r24
     6c0:	19 f0       	breq	.+6      	; 0x6c8 <xSerialPortInitMinimal+0xc6>
     6c2:	81 30       	cpi	r24, 0x01	; 1
     6c4:	99 f1       	breq	.+102    	; 0x72c <xSerialPortInitMinimal+0x12a>
     6c6:	6b c0       	rjmp	.+214    	; 0x79e <xSerialPortInitMinimal+0x19c>
     6c8:	d5 01       	movw	r26, r10
     6ca:	c4 01       	movw	r24, r8
     6cc:	80 58       	subi	r24, 0x80	; 128
     6ce:	9b 47       	sbci	r25, 0x7B	; 123
     6d0:	a1 4e       	sbci	r26, 0xE1	; 225
     6d2:	bf 4f       	sbci	r27, 0xFF	; 255
     6d4:	bc 01       	movw	r22, r24
     6d6:	cd 01       	movw	r24, r26
     6d8:	66 0f       	add	r22, r22
     6da:	77 1f       	adc	r23, r23
     6dc:	88 1f       	adc	r24, r24
     6de:	99 1f       	adc	r25, r25
     6e0:	66 0f       	add	r22, r22
     6e2:	77 1f       	adc	r23, r23
     6e4:	88 1f       	adc	r24, r24
     6e6:	99 1f       	adc	r25, r25
     6e8:	95 01       	movw	r18, r10
     6ea:	84 01       	movw	r16, r8
     6ec:	00 0f       	add	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	22 1f       	adc	r18, r18
     6f2:	33 1f       	adc	r19, r19
     6f4:	00 0f       	add	r16, r16
     6f6:	11 1f       	adc	r17, r17
     6f8:	22 1f       	adc	r18, r18
     6fa:	33 1f       	adc	r19, r19
     6fc:	a9 01       	movw	r20, r18
     6fe:	98 01       	movw	r18, r16
     700:	22 0f       	add	r18, r18
     702:	33 1f       	adc	r19, r19
     704:	44 1f       	adc	r20, r20
     706:	55 1f       	adc	r21, r21
     708:	0e 94 3a 10 	call	0x2074	; 0x2074 <__udivmodsi4>
     70c:	21 50       	subi	r18, 0x01	; 1
     70e:	31 09       	sbc	r19, r1
     710:	30 93 c5 00 	sts	0x00C5, r19	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
     714:	20 93 c4 00 	sts	0x00C4, r18	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
     718:	82 e0       	ldi	r24, 0x02	; 2
     71a:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     71e:	88 e9       	ldi	r24, 0x98	; 152
     720:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
     724:	8e e0       	ldi	r24, 0x0E	; 14
     726:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
     72a:	39 c0       	rjmp	.+114    	; 0x79e <xSerialPortInitMinimal+0x19c>
     72c:	04 ec       	ldi	r16, 0xC4	; 196
     72e:	10 e0       	ldi	r17, 0x00	; 0
     730:	f8 01       	movw	r30, r16
     732:	11 82       	std	Z+1, r1	; 0x01
     734:	10 82       	st	Z, r1
     736:	54 9a       	sbi	0x0a, 4	; 10
     738:	80 ec       	ldi	r24, 0xC0	; 192
     73a:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
     73e:	88 e9       	ldi	r24, 0x98	; 152
     740:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
     744:	d5 01       	movw	r26, r10
     746:	c4 01       	movw	r24, r8
     748:	80 5c       	subi	r24, 0xC0	; 192
     74a:	9d 4b       	sbci	r25, 0xBD	; 189
     74c:	a0 4f       	sbci	r26, 0xF0	; 240
     74e:	bf 4f       	sbci	r27, 0xFF	; 255
     750:	88 0f       	add	r24, r24
     752:	99 1f       	adc	r25, r25
     754:	aa 1f       	adc	r26, r26
     756:	bb 1f       	adc	r27, r27
     758:	88 0f       	add	r24, r24
     75a:	99 1f       	adc	r25, r25
     75c:	aa 1f       	adc	r26, r26
     75e:	bb 1f       	adc	r27, r27
     760:	bc 01       	movw	r22, r24
     762:	cd 01       	movw	r24, r26
     764:	66 0f       	add	r22, r22
     766:	77 1f       	adc	r23, r23
     768:	88 1f       	adc	r24, r24
     76a:	99 1f       	adc	r25, r25
     76c:	88 0c       	add	r8, r8
     76e:	99 1c       	adc	r9, r9
     770:	aa 1c       	adc	r10, r10
     772:	bb 1c       	adc	r11, r11
     774:	88 0c       	add	r8, r8
     776:	99 1c       	adc	r9, r9
     778:	aa 1c       	adc	r10, r10
     77a:	bb 1c       	adc	r11, r11
     77c:	a5 01       	movw	r20, r10
     77e:	94 01       	movw	r18, r8
     780:	22 0f       	add	r18, r18
     782:	33 1f       	adc	r19, r19
     784:	44 1f       	adc	r20, r20
     786:	55 1f       	adc	r21, r21
     788:	22 0f       	add	r18, r18
     78a:	33 1f       	adc	r19, r19
     78c:	44 1f       	adc	r20, r20
     78e:	55 1f       	adc	r21, r21
     790:	0e 94 3a 10 	call	0x2074	; 0x2074 <__udivmodsi4>
     794:	21 50       	subi	r18, 0x01	; 1
     796:	31 09       	sbc	r19, r1
     798:	f8 01       	movw	r30, r16
     79a:	31 83       	std	Z+1, r19	; 0x01
     79c:	20 83       	st	Z, r18
     79e:	0f 90       	pop	r0
     7a0:	0f be       	out	0x3f, r0	; 63
     7a2:	82 e2       	ldi	r24, 0x22	; 34
     7a4:	fe 01       	movw	r30, r28
     7a6:	31 96       	adiw	r30, 0x01	; 1
     7a8:	d6 01       	movw	r26, r12
     7aa:	01 90       	ld	r0, Z+
     7ac:	0d 92       	st	X+, r0
     7ae:	8a 95       	dec	r24
     7b0:	e1 f7       	brne	.-8      	; 0x7aa <xSerialPortInitMinimal+0x1a8>
     7b2:	c6 01       	movw	r24, r12
     7b4:	a2 96       	adiw	r28, 0x22	; 34
     7b6:	0f b6       	in	r0, 0x3f	; 63
     7b8:	f8 94       	cli
     7ba:	de bf       	out	0x3e, r29	; 62
     7bc:	0f be       	out	0x3f, r0	; 63
     7be:	cd bf       	out	0x3d, r28	; 61
     7c0:	df 91       	pop	r29
     7c2:	cf 91       	pop	r28
     7c4:	1f 91       	pop	r17
     7c6:	0f 91       	pop	r16
     7c8:	ff 90       	pop	r15
     7ca:	ef 90       	pop	r14
     7cc:	df 90       	pop	r13
     7ce:	cf 90       	pop	r12
     7d0:	bf 90       	pop	r11
     7d2:	af 90       	pop	r10
     7d4:	9f 90       	pop	r9
     7d6:	8f 90       	pop	r8
     7d8:	7f 90       	pop	r7
     7da:	08 95       	ret

000007dc <avrSerialxPrint_P>:
     7dc:	ef 92       	push	r14
     7de:	ff 92       	push	r15
     7e0:	0f 93       	push	r16
     7e2:	1f 93       	push	r17
     7e4:	cf 93       	push	r28
     7e6:	df 93       	push	r29
     7e8:	ec 01       	movw	r28, r24
     7ea:	8b 01       	movw	r16, r22
     7ec:	cb 01       	movw	r24, r22
     7ee:	0e 94 83 11 	call	0x2306	; 0x2306 <__strlen_P>
     7f2:	00 97       	sbiw	r24, 0x00	; 0
     7f4:	19 f1       	breq	.+70     	; 0x83c <avrSerialxPrint_P+0x60>
     7f6:	78 01       	movw	r14, r16
     7f8:	b8 01       	movw	r22, r16
     7fa:	68 0f       	add	r22, r24
     7fc:	79 1f       	adc	r23, r25
     7fe:	a0 ec       	ldi	r26, 0xC0	; 192
     800:	b0 e0       	ldi	r27, 0x00	; 0
     802:	30 e0       	ldi	r19, 0x00	; 0
     804:	06 ec       	ldi	r16, 0xC6	; 198
     806:	10 e0       	ldi	r17, 0x00	; 0
     808:	f7 01       	movw	r30, r14
     80a:	44 91       	lpm	r20, Z
     80c:	04 c0       	rjmp	.+8      	; 0x816 <avrSerialxPrint_P+0x3a>
     80e:	f2 e4       	ldi	r31, 0x42	; 66
     810:	fa 95       	dec	r31
     812:	f1 f7       	brne	.-4      	; 0x810 <avrSerialxPrint_P+0x34>
     814:	00 c0       	rjmp	.+0      	; 0x816 <avrSerialxPrint_P+0x3a>
     816:	28 81       	ld	r18, Y
     818:	22 30       	cpi	r18, 0x02	; 2
     81a:	18 f4       	brcc	.+6      	; 0x822 <avrSerialxPrint_P+0x46>
     81c:	9c 91       	ld	r25, X
     81e:	90 72       	andi	r25, 0x20	; 32
     820:	01 c0       	rjmp	.+2      	; 0x824 <avrSerialxPrint_P+0x48>
     822:	93 2f       	mov	r25, r19
     824:	99 23       	and	r25, r25
     826:	99 f3       	breq	.-26     	; 0x80e <avrSerialxPrint_P+0x32>
     828:	22 30       	cpi	r18, 0x02	; 2
     82a:	10 f4       	brcc	.+4      	; 0x830 <avrSerialxPrint_P+0x54>
     82c:	f8 01       	movw	r30, r16
     82e:	40 83       	st	Z, r20
     830:	ff ef       	ldi	r31, 0xFF	; 255
     832:	ef 1a       	sub	r14, r31
     834:	ff 0a       	sbc	r15, r31
     836:	e6 16       	cp	r14, r22
     838:	f7 06       	cpc	r15, r23
     83a:	31 f7       	brne	.-52     	; 0x808 <avrSerialxPrint_P+0x2c>
     83c:	df 91       	pop	r29
     83e:	cf 91       	pop	r28
     840:	1f 91       	pop	r17
     842:	0f 91       	pop	r16
     844:	ff 90       	pop	r15
     846:	ef 90       	pop	r14
     848:	08 95       	ret

0000084a <__vector_18>:
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART0_RX_vect )

#endif
{
     84a:	1f 92       	push	r1
     84c:	0f 92       	push	r0
     84e:	0f b6       	in	r0, 0x3f	; 63
     850:	0f 92       	push	r0
     852:	11 24       	eor	r1, r1
     854:	2f 93       	push	r18
     856:	3f 93       	push	r19
     858:	4f 93       	push	r20
     85a:	8f 93       	push	r24
     85c:	9f 93       	push	r25
     85e:	af 93       	push	r26
     860:	bf 93       	push	r27
     862:	ef 93       	push	r30
     864:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR0A & (_BV(FE0)|_BV(DOR0)|_BV(UPE0)) ) )
     866:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     86a:	8c 71       	andi	r24, 0x1C	; 28
     86c:	71 f0       	breq	.+28     	; 0x88a <__vector_18+0x40>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR0A & (1<<RXC0) ) erroredByte = UDR0;
     86e:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     872:	88 23       	and	r24, r24
     874:	0c f0       	brlt	.+2      	; 0x878 <__vector_18+0x2e>
     876:	36 c0       	rjmp	.+108    	; 0x8e4 <__vector_18+0x9a>
     878:	a6 ec       	ldi	r26, 0xC6	; 198
     87a:	b0 e0       	ldi	r27, 0x00	; 0
     87c:	e0 ec       	ldi	r30, 0xC0	; 192
     87e:	f0 e0       	ldi	r31, 0x00	; 0
     880:	8c 91       	ld	r24, X
     882:	80 81       	ld	r24, Z
     884:	88 23       	and	r24, r24
     886:	e4 f3       	brlt	.-8      	; 0x880 <__vector_18+0x36>
     888:	2d c0       	rjmp	.+90     	; 0x8e4 <__vector_18+0x9a>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR0;
     88a:	40 91 c6 00 	lds	r20, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
     88e:	0f b6       	in	r0, 0x3f	; 63
     890:	f8 94       	cli
     892:	0f 92       	push	r0
	{
	    count = buffer->count;
     894:	e6 ea       	ldi	r30, 0xA6	; 166
     896:	f1 e0       	ldi	r31, 0x01	; 1
     898:	21 81       	ldd	r18, Z+1	; 0x01
     89a:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
     89c:	0f 90       	pop	r0
     89e:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerialPort.xRxedChars) ) )
     8a0:	83 85       	ldd	r24, Z+11	; 0x0b
     8a2:	94 85       	ldd	r25, Z+12	; 0x0c
     8a4:	28 17       	cp	r18, r24
     8a6:	39 07       	cpc	r19, r25
     8a8:	e9 f0       	breq	.+58     	; 0x8e4 <__vector_18+0x9a>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
     8aa:	e7 ea       	ldi	r30, 0xA7	; 167
     8ac:	f1 e0       	ldi	r31, 0x01	; 1

	*buffer->in = data;
     8ae:	a2 81       	ldd	r26, Z+2	; 0x02
     8b0:	b3 81       	ldd	r27, Z+3	; 0x03
     8b2:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
     8b4:	82 81       	ldd	r24, Z+2	; 0x02
     8b6:	93 81       	ldd	r25, Z+3	; 0x03
     8b8:	01 96       	adiw	r24, 0x01	; 1
     8ba:	93 83       	std	Z+3, r25	; 0x03
     8bc:	82 83       	std	Z+2, r24	; 0x02
     8be:	20 85       	ldd	r18, Z+8	; 0x08
     8c0:	31 85       	ldd	r19, Z+9	; 0x09
     8c2:	82 17       	cp	r24, r18
     8c4:	93 07       	cpc	r25, r19
     8c6:	21 f4       	brne	.+8      	; 0x8d0 <__vector_18+0x86>
	  buffer->in = buffer->start;
     8c8:	86 81       	ldd	r24, Z+6	; 0x06
     8ca:	97 81       	ldd	r25, Z+7	; 0x07
     8cc:	93 83       	std	Z+3, r25	; 0x03
     8ce:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
     8d0:	0f b6       	in	r0, 0x3f	; 63
     8d2:	f8 94       	cli
     8d4:	0f 92       	push	r0
	{
	    buffer->count++;
     8d6:	80 81       	ld	r24, Z
     8d8:	91 81       	ldd	r25, Z+1	; 0x01
     8da:	01 96       	adiw	r24, 0x01	; 1
     8dc:	91 83       	std	Z+1, r25	; 0x01
     8de:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
     8e0:	0f 90       	pop	r0
     8e2:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerialPort.xRxedChars), cChar);
	}
}
     8e4:	ff 91       	pop	r31
     8e6:	ef 91       	pop	r30
     8e8:	bf 91       	pop	r27
     8ea:	af 91       	pop	r26
     8ec:	9f 91       	pop	r25
     8ee:	8f 91       	pop	r24
     8f0:	4f 91       	pop	r20
     8f2:	3f 91       	pop	r19
     8f4:	2f 91       	pop	r18
     8f6:	0f 90       	pop	r0
     8f8:	0f be       	out	0x3f, r0	; 63
     8fa:	0f 90       	pop	r0
     8fc:	1f 90       	pop	r1
     8fe:	18 95       	reti

00000900 <__vector_19>:
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART0_UDRE_vect )

#endif
{
     900:	1f 92       	push	r1
     902:	0f 92       	push	r0
     904:	0f b6       	in	r0, 0x3f	; 63
     906:	0f 92       	push	r0
     908:	11 24       	eor	r1, r1
     90a:	2f 93       	push	r18
     90c:	8f 93       	push	r24
     90e:	9f 93       	push	r25
     910:	af 93       	push	r26
     912:	bf 93       	push	r27
     914:	ef 93       	push	r30
     916:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
     918:	0f b6       	in	r0, 0x3f	; 63
     91a:	f8 94       	cli
     91c:	0f 92       	push	r0
	{
	    count = buffer->count;
     91e:	80 91 b3 01 	lds	r24, 0x01B3	; 0x8001b3 <xSerialPort+0xd>
     922:	90 91 b4 01 	lds	r25, 0x01B4	; 0x8001b4 <xSerialPort+0xe>
	}
	portEXIT_CRITICAL();
     926:	0f 90       	pop	r0
     928:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerialPort.xCharsForTx) ) )
     92a:	89 2b       	or	r24, r25
     92c:	31 f4       	brne	.+12     	; 0x93a <__vector_19+0x3a>
	{
		// Queue empty, nothing to send.
		vInterrupt0_Off();
     92e:	e1 ec       	ldi	r30, 0xC1	; 193
     930:	f0 e0       	ldi	r31, 0x00	; 0
     932:	80 81       	ld	r24, Z
     934:	8f 7d       	andi	r24, 0xDF	; 223
     936:	80 83       	st	Z, r24
     938:	1c c0       	rjmp	.+56     	; 0x972 <__vector_19+0x72>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
     93a:	e3 eb       	ldi	r30, 0xB3	; 179
     93c:	f1 e0       	ldi	r31, 0x01	; 1

	uint8_t data = *buffer->out;
     93e:	a4 81       	ldd	r26, Z+4	; 0x04
     940:	b5 81       	ldd	r27, Z+5	; 0x05
     942:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
     944:	b5 83       	std	Z+5, r27	; 0x05
     946:	a4 83       	std	Z+4, r26	; 0x04
     948:	80 85       	ldd	r24, Z+8	; 0x08
     94a:	91 85       	ldd	r25, Z+9	; 0x09
     94c:	a8 17       	cp	r26, r24
     94e:	b9 07       	cpc	r27, r25
     950:	21 f4       	brne	.+8      	; 0x95a <__vector_19+0x5a>
	  buffer->out = buffer->start;
     952:	86 81       	ldd	r24, Z+6	; 0x06
     954:	97 81       	ldd	r25, Z+7	; 0x07
     956:	95 83       	std	Z+5, r25	; 0x05
     958:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
     95a:	0f b6       	in	r0, 0x3f	; 63
     95c:	f8 94       	cli
     95e:	0f 92       	push	r0
	{
	    buffer->count--;
     960:	80 81       	ld	r24, Z
     962:	91 81       	ldd	r25, Z+1	; 0x01
     964:	01 97       	sbiw	r24, 0x01	; 1
     966:	91 83       	std	Z+1, r25	; 0x01
     968:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
     96a:	0f 90       	pop	r0
     96c:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR0 = ringBuffer_Pop( (ringBuffer_t*) &(xSerialPort.xCharsForTx) );
     96e:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	}
}
     972:	ff 91       	pop	r31
     974:	ef 91       	pop	r30
     976:	bf 91       	pop	r27
     978:	af 91       	pop	r26
     97a:	9f 91       	pop	r25
     97c:	8f 91       	pop	r24
     97e:	2f 91       	pop	r18
     980:	0f 90       	pop	r0
     982:	0f be       	out	0x3f, r0	; 63
     984:	0f 90       	pop	r0
     986:	1f 90       	pop	r1
     988:	18 95       	reti

0000098a <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
     98a:	31 e1       	ldi	r19, 0x11	; 17
     98c:	fc 01       	movw	r30, r24
     98e:	30 83       	st	Z, r19
     990:	31 97       	sbiw	r30, 0x01	; 1
     992:	22 e2       	ldi	r18, 0x22	; 34
     994:	20 83       	st	Z, r18
     996:	31 97       	sbiw	r30, 0x01	; 1
     998:	a3 e3       	ldi	r26, 0x33	; 51
     99a:	a0 83       	st	Z, r26
     99c:	31 97       	sbiw	r30, 0x01	; 1
     99e:	60 83       	st	Z, r22
     9a0:	31 97       	sbiw	r30, 0x01	; 1
     9a2:	70 83       	st	Z, r23
     9a4:	31 97       	sbiw	r30, 0x01	; 1
     9a6:	10 82       	st	Z, r1
     9a8:	31 97       	sbiw	r30, 0x01	; 1
     9aa:	60 e8       	ldi	r22, 0x80	; 128
     9ac:	60 83       	st	Z, r22
     9ae:	31 97       	sbiw	r30, 0x01	; 1
     9b0:	10 82       	st	Z, r1
     9b2:	31 97       	sbiw	r30, 0x01	; 1
     9b4:	62 e0       	ldi	r22, 0x02	; 2
     9b6:	60 83       	st	Z, r22
     9b8:	31 97       	sbiw	r30, 0x01	; 1
     9ba:	63 e0       	ldi	r22, 0x03	; 3
     9bc:	60 83       	st	Z, r22
     9be:	31 97       	sbiw	r30, 0x01	; 1
     9c0:	64 e0       	ldi	r22, 0x04	; 4
     9c2:	60 83       	st	Z, r22
     9c4:	31 97       	sbiw	r30, 0x01	; 1
     9c6:	65 e0       	ldi	r22, 0x05	; 5
     9c8:	60 83       	st	Z, r22
     9ca:	31 97       	sbiw	r30, 0x01	; 1
     9cc:	66 e0       	ldi	r22, 0x06	; 6
     9ce:	60 83       	st	Z, r22
     9d0:	31 97       	sbiw	r30, 0x01	; 1
     9d2:	67 e0       	ldi	r22, 0x07	; 7
     9d4:	60 83       	st	Z, r22
     9d6:	31 97       	sbiw	r30, 0x01	; 1
     9d8:	68 e0       	ldi	r22, 0x08	; 8
     9da:	60 83       	st	Z, r22
     9dc:	31 97       	sbiw	r30, 0x01	; 1
     9de:	69 e0       	ldi	r22, 0x09	; 9
     9e0:	60 83       	st	Z, r22
     9e2:	31 97       	sbiw	r30, 0x01	; 1
     9e4:	60 e1       	ldi	r22, 0x10	; 16
     9e6:	60 83       	st	Z, r22
     9e8:	31 97       	sbiw	r30, 0x01	; 1
     9ea:	30 83       	st	Z, r19
     9ec:	31 97       	sbiw	r30, 0x01	; 1
     9ee:	32 e1       	ldi	r19, 0x12	; 18
     9f0:	30 83       	st	Z, r19
     9f2:	31 97       	sbiw	r30, 0x01	; 1
     9f4:	33 e1       	ldi	r19, 0x13	; 19
     9f6:	30 83       	st	Z, r19
     9f8:	31 97       	sbiw	r30, 0x01	; 1
     9fa:	34 e1       	ldi	r19, 0x14	; 20
     9fc:	30 83       	st	Z, r19
     9fe:	31 97       	sbiw	r30, 0x01	; 1
     a00:	35 e1       	ldi	r19, 0x15	; 21
     a02:	30 83       	st	Z, r19
     a04:	31 97       	sbiw	r30, 0x01	; 1
     a06:	36 e1       	ldi	r19, 0x16	; 22
     a08:	30 83       	st	Z, r19
     a0a:	31 97       	sbiw	r30, 0x01	; 1
     a0c:	37 e1       	ldi	r19, 0x17	; 23
     a0e:	30 83       	st	Z, r19
     a10:	31 97       	sbiw	r30, 0x01	; 1
     a12:	38 e1       	ldi	r19, 0x18	; 24
     a14:	30 83       	st	Z, r19
     a16:	31 97       	sbiw	r30, 0x01	; 1
     a18:	39 e1       	ldi	r19, 0x19	; 25
     a1a:	30 83       	st	Z, r19
     a1c:	31 97       	sbiw	r30, 0x01	; 1
     a1e:	30 e2       	ldi	r19, 0x20	; 32
     a20:	30 83       	st	Z, r19
     a22:	31 97       	sbiw	r30, 0x01	; 1
     a24:	31 e2       	ldi	r19, 0x21	; 33
     a26:	30 83       	st	Z, r19
     a28:	31 97       	sbiw	r30, 0x01	; 1
     a2a:	20 83       	st	Z, r18
     a2c:	31 97       	sbiw	r30, 0x01	; 1
     a2e:	23 e2       	ldi	r18, 0x23	; 35
     a30:	20 83       	st	Z, r18
     a32:	31 97       	sbiw	r30, 0x01	; 1
     a34:	40 83       	st	Z, r20
     a36:	31 97       	sbiw	r30, 0x01	; 1
     a38:	50 83       	st	Z, r21
     a3a:	31 97       	sbiw	r30, 0x01	; 1
     a3c:	26 e2       	ldi	r18, 0x26	; 38
     a3e:	20 83       	st	Z, r18
     a40:	31 97       	sbiw	r30, 0x01	; 1
     a42:	27 e2       	ldi	r18, 0x27	; 39
     a44:	20 83       	st	Z, r18
     a46:	31 97       	sbiw	r30, 0x01	; 1
     a48:	28 e2       	ldi	r18, 0x28	; 40
     a4a:	20 83       	st	Z, r18
     a4c:	31 97       	sbiw	r30, 0x01	; 1
     a4e:	29 e2       	ldi	r18, 0x29	; 41
     a50:	20 83       	st	Z, r18
     a52:	31 97       	sbiw	r30, 0x01	; 1
     a54:	20 e3       	ldi	r18, 0x30	; 48
     a56:	20 83       	st	Z, r18
     a58:	31 97       	sbiw	r30, 0x01	; 1
     a5a:	21 e3       	ldi	r18, 0x31	; 49
     a5c:	20 83       	st	Z, r18
     a5e:	86 97       	sbiw	r24, 0x26	; 38
     a60:	08 95       	ret

00000a62 <xPortStartScheduler>:
     a62:	a8 95       	wdr
     a64:	90 ec       	ldi	r25, 0xC0	; 192
     a66:	88 e1       	ldi	r24, 0x18	; 24
     a68:	0f b6       	in	r0, 0x3f	; 63
     a6a:	f8 94       	cli
     a6c:	a8 95       	wdr
     a6e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     a72:	0f be       	out	0x3f, r0	; 63
     a74:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     a78:	a0 91 88 01 	lds	r26, 0x0188	; 0x800188 <pxCurrentTCB>
     a7c:	b0 91 89 01 	lds	r27, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
     a80:	cd 91       	ld	r28, X+
     a82:	cd bf       	out	0x3d, r28	; 61
     a84:	dd 91       	ld	r29, X+
     a86:	de bf       	out	0x3e, r29	; 62
     a88:	ff 91       	pop	r31
     a8a:	ef 91       	pop	r30
     a8c:	df 91       	pop	r29
     a8e:	cf 91       	pop	r28
     a90:	bf 91       	pop	r27
     a92:	af 91       	pop	r26
     a94:	9f 91       	pop	r25
     a96:	8f 91       	pop	r24
     a98:	7f 91       	pop	r23
     a9a:	6f 91       	pop	r22
     a9c:	5f 91       	pop	r21
     a9e:	4f 91       	pop	r20
     aa0:	3f 91       	pop	r19
     aa2:	2f 91       	pop	r18
     aa4:	1f 91       	pop	r17
     aa6:	0f 91       	pop	r16
     aa8:	ff 90       	pop	r15
     aaa:	ef 90       	pop	r14
     aac:	df 90       	pop	r13
     aae:	cf 90       	pop	r12
     ab0:	bf 90       	pop	r11
     ab2:	af 90       	pop	r10
     ab4:	9f 90       	pop	r9
     ab6:	8f 90       	pop	r8
     ab8:	7f 90       	pop	r7
     aba:	6f 90       	pop	r6
     abc:	5f 90       	pop	r5
     abe:	4f 90       	pop	r4
     ac0:	3f 90       	pop	r3
     ac2:	2f 90       	pop	r2
     ac4:	1f 90       	pop	r1
     ac6:	0f 90       	pop	r0
     ac8:	0f be       	out	0x3f, r0	; 63
     aca:	0f 90       	pop	r0
     acc:	08 95       	ret
     ace:	81 e0       	ldi	r24, 0x01	; 1
     ad0:	08 95       	ret

00000ad2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     ad2:	0f 92       	push	r0
     ad4:	0f b6       	in	r0, 0x3f	; 63
     ad6:	f8 94       	cli
     ad8:	0f 92       	push	r0
     ada:	1f 92       	push	r1
     adc:	11 24       	eor	r1, r1
     ade:	2f 92       	push	r2
     ae0:	3f 92       	push	r3
     ae2:	4f 92       	push	r4
     ae4:	5f 92       	push	r5
     ae6:	6f 92       	push	r6
     ae8:	7f 92       	push	r7
     aea:	8f 92       	push	r8
     aec:	9f 92       	push	r9
     aee:	af 92       	push	r10
     af0:	bf 92       	push	r11
     af2:	cf 92       	push	r12
     af4:	df 92       	push	r13
     af6:	ef 92       	push	r14
     af8:	ff 92       	push	r15
     afa:	0f 93       	push	r16
     afc:	1f 93       	push	r17
     afe:	2f 93       	push	r18
     b00:	3f 93       	push	r19
     b02:	4f 93       	push	r20
     b04:	5f 93       	push	r21
     b06:	6f 93       	push	r22
     b08:	7f 93       	push	r23
     b0a:	8f 93       	push	r24
     b0c:	9f 93       	push	r25
     b0e:	af 93       	push	r26
     b10:	bf 93       	push	r27
     b12:	cf 93       	push	r28
     b14:	df 93       	push	r29
     b16:	ef 93       	push	r30
     b18:	ff 93       	push	r31
     b1a:	a0 91 88 01 	lds	r26, 0x0188	; 0x800188 <pxCurrentTCB>
     b1e:	b0 91 89 01 	lds	r27, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
     b22:	0d b6       	in	r0, 0x3d	; 61
     b24:	0d 92       	st	X+, r0
     b26:	0e b6       	in	r0, 0x3e	; 62
     b28:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     b2a:	0e 94 75 0c 	call	0x18ea	; 0x18ea <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     b2e:	a0 91 88 01 	lds	r26, 0x0188	; 0x800188 <pxCurrentTCB>
     b32:	b0 91 89 01 	lds	r27, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
     b36:	cd 91       	ld	r28, X+
     b38:	cd bf       	out	0x3d, r28	; 61
     b3a:	dd 91       	ld	r29, X+
     b3c:	de bf       	out	0x3e, r29	; 62
     b3e:	ff 91       	pop	r31
     b40:	ef 91       	pop	r30
     b42:	df 91       	pop	r29
     b44:	cf 91       	pop	r28
     b46:	bf 91       	pop	r27
     b48:	af 91       	pop	r26
     b4a:	9f 91       	pop	r25
     b4c:	8f 91       	pop	r24
     b4e:	7f 91       	pop	r23
     b50:	6f 91       	pop	r22
     b52:	5f 91       	pop	r21
     b54:	4f 91       	pop	r20
     b56:	3f 91       	pop	r19
     b58:	2f 91       	pop	r18
     b5a:	1f 91       	pop	r17
     b5c:	0f 91       	pop	r16
     b5e:	ff 90       	pop	r15
     b60:	ef 90       	pop	r14
     b62:	df 90       	pop	r13
     b64:	cf 90       	pop	r12
     b66:	bf 90       	pop	r11
     b68:	af 90       	pop	r10
     b6a:	9f 90       	pop	r9
     b6c:	8f 90       	pop	r8
     b6e:	7f 90       	pop	r7
     b70:	6f 90       	pop	r6
     b72:	5f 90       	pop	r5
     b74:	4f 90       	pop	r4
     b76:	3f 90       	pop	r3
     b78:	2f 90       	pop	r2
     b7a:	1f 90       	pop	r1
     b7c:	0f 90       	pop	r0
     b7e:	0f be       	out	0x3f, r0	; 63
     b80:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     b82:	08 95       	ret

00000b84 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     b84:	0f 92       	push	r0
     b86:	0f b6       	in	r0, 0x3f	; 63
     b88:	f8 94       	cli
     b8a:	0f 92       	push	r0
     b8c:	1f 92       	push	r1
     b8e:	11 24       	eor	r1, r1
     b90:	2f 92       	push	r2
     b92:	3f 92       	push	r3
     b94:	4f 92       	push	r4
     b96:	5f 92       	push	r5
     b98:	6f 92       	push	r6
     b9a:	7f 92       	push	r7
     b9c:	8f 92       	push	r8
     b9e:	9f 92       	push	r9
     ba0:	af 92       	push	r10
     ba2:	bf 92       	push	r11
     ba4:	cf 92       	push	r12
     ba6:	df 92       	push	r13
     ba8:	ef 92       	push	r14
     baa:	ff 92       	push	r15
     bac:	0f 93       	push	r16
     bae:	1f 93       	push	r17
     bb0:	2f 93       	push	r18
     bb2:	3f 93       	push	r19
     bb4:	4f 93       	push	r20
     bb6:	5f 93       	push	r21
     bb8:	6f 93       	push	r22
     bba:	7f 93       	push	r23
     bbc:	8f 93       	push	r24
     bbe:	9f 93       	push	r25
     bc0:	af 93       	push	r26
     bc2:	bf 93       	push	r27
     bc4:	cf 93       	push	r28
     bc6:	df 93       	push	r29
     bc8:	ef 93       	push	r30
     bca:	ff 93       	push	r31
     bcc:	a0 91 88 01 	lds	r26, 0x0188	; 0x800188 <pxCurrentTCB>
     bd0:	b0 91 89 01 	lds	r27, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
     bd4:	0d b6       	in	r0, 0x3d	; 61
     bd6:	0d 92       	st	X+, r0
     bd8:	0e b6       	in	r0, 0x3e	; 62
     bda:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
     bdc:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
     bde:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <xTaskIncrementTick>
     be2:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     be4:	0e 94 75 0c 	call	0x18ea	; 0x18ea <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
     be8:	a0 91 88 01 	lds	r26, 0x0188	; 0x800188 <pxCurrentTCB>
     bec:	b0 91 89 01 	lds	r27, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
     bf0:	cd 91       	ld	r28, X+
     bf2:	cd bf       	out	0x3d, r28	; 61
     bf4:	dd 91       	ld	r29, X+
     bf6:	de bf       	out	0x3e, r29	; 62
     bf8:	ff 91       	pop	r31
     bfa:	ef 91       	pop	r30
     bfc:	df 91       	pop	r29
     bfe:	cf 91       	pop	r28
     c00:	bf 91       	pop	r27
     c02:	af 91       	pop	r26
     c04:	9f 91       	pop	r25
     c06:	8f 91       	pop	r24
     c08:	7f 91       	pop	r23
     c0a:	6f 91       	pop	r22
     c0c:	5f 91       	pop	r21
     c0e:	4f 91       	pop	r20
     c10:	3f 91       	pop	r19
     c12:	2f 91       	pop	r18
     c14:	1f 91       	pop	r17
     c16:	0f 91       	pop	r16
     c18:	ff 90       	pop	r15
     c1a:	ef 90       	pop	r14
     c1c:	df 90       	pop	r13
     c1e:	cf 90       	pop	r12
     c20:	bf 90       	pop	r11
     c22:	af 90       	pop	r10
     c24:	9f 90       	pop	r9
     c26:	8f 90       	pop	r8
     c28:	7f 90       	pop	r7
     c2a:	6f 90       	pop	r6
     c2c:	5f 90       	pop	r5
     c2e:	4f 90       	pop	r4
     c30:	3f 90       	pop	r3
     c32:	2f 90       	pop	r2
     c34:	1f 90       	pop	r1
     c36:	0f 90       	pop	r0
     c38:	0f be       	out	0x3f, r0	; 63
     c3a:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     c3c:	08 95       	ret

00000c3e <__vector_6>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
     c3e:	0e 94 c2 05 	call	0xb84	; 0xb84 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
     c42:	18 95       	reti

00000c44 <prvIsQueueEmpty>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     c44:	0f b6       	in	r0, 0x3f	; 63
     c46:	f8 94       	cli
     c48:	0f 92       	push	r0
     c4a:	fc 01       	movw	r30, r24
     c4c:	92 8d       	ldd	r25, Z+26	; 0x1a
     c4e:	0f 90       	pop	r0
     c50:	0f be       	out	0x3f, r0	; 63
     c52:	81 e0       	ldi	r24, 0x01	; 1
     c54:	91 11       	cpse	r25, r1
     c56:	80 e0       	ldi	r24, 0x00	; 0
     c58:	08 95       	ret

00000c5a <prvCopyDataToQueue>:
     c5a:	0f 93       	push	r16
     c5c:	1f 93       	push	r17
     c5e:	cf 93       	push	r28
     c60:	df 93       	push	r29
     c62:	ec 01       	movw	r28, r24
     c64:	04 2f       	mov	r16, r20
     c66:	1a 8d       	ldd	r17, Y+26	; 0x1a
     c68:	4c 8d       	ldd	r20, Y+28	; 0x1c
     c6a:	41 11       	cpse	r20, r1
     c6c:	0c c0       	rjmp	.+24     	; 0xc86 <prvCopyDataToQueue+0x2c>
     c6e:	88 81       	ld	r24, Y
     c70:	99 81       	ldd	r25, Y+1	; 0x01
     c72:	89 2b       	or	r24, r25
     c74:	09 f0       	breq	.+2      	; 0xc78 <prvCopyDataToQueue+0x1e>
     c76:	42 c0       	rjmp	.+132    	; 0xcfc <prvCopyDataToQueue+0xa2>
     c78:	8c 81       	ldd	r24, Y+4	; 0x04
     c7a:	9d 81       	ldd	r25, Y+5	; 0x05
     c7c:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <xTaskPriorityDisinherit>
     c80:	1d 82       	std	Y+5, r1	; 0x05
     c82:	1c 82       	std	Y+4, r1	; 0x04
     c84:	42 c0       	rjmp	.+132    	; 0xd0a <prvCopyDataToQueue+0xb0>
     c86:	01 11       	cpse	r16, r1
     c88:	17 c0       	rjmp	.+46     	; 0xcb8 <prvCopyDataToQueue+0x5e>
     c8a:	50 e0       	ldi	r21, 0x00	; 0
     c8c:	8a 81       	ldd	r24, Y+2	; 0x02
     c8e:	9b 81       	ldd	r25, Y+3	; 0x03
     c90:	0e 94 8c 11 	call	0x2318	; 0x2318 <memcpy>
     c94:	2c 8d       	ldd	r18, Y+28	; 0x1c
     c96:	8a 81       	ldd	r24, Y+2	; 0x02
     c98:	9b 81       	ldd	r25, Y+3	; 0x03
     c9a:	82 0f       	add	r24, r18
     c9c:	91 1d       	adc	r25, r1
     c9e:	9b 83       	std	Y+3, r25	; 0x03
     ca0:	8a 83       	std	Y+2, r24	; 0x02
     ca2:	2c 81       	ldd	r18, Y+4	; 0x04
     ca4:	3d 81       	ldd	r19, Y+5	; 0x05
     ca6:	82 17       	cp	r24, r18
     ca8:	93 07       	cpc	r25, r19
     caa:	50 f1       	brcs	.+84     	; 0xd00 <prvCopyDataToQueue+0xa6>
     cac:	88 81       	ld	r24, Y
     cae:	99 81       	ldd	r25, Y+1	; 0x01
     cb0:	9b 83       	std	Y+3, r25	; 0x03
     cb2:	8a 83       	std	Y+2, r24	; 0x02
     cb4:	80 e0       	ldi	r24, 0x00	; 0
     cb6:	29 c0       	rjmp	.+82     	; 0xd0a <prvCopyDataToQueue+0xb0>
     cb8:	50 e0       	ldi	r21, 0x00	; 0
     cba:	8e 81       	ldd	r24, Y+6	; 0x06
     cbc:	9f 81       	ldd	r25, Y+7	; 0x07
     cbe:	0e 94 8c 11 	call	0x2318	; 0x2318 <memcpy>
     cc2:	8c 8d       	ldd	r24, Y+28	; 0x1c
     cc4:	90 e0       	ldi	r25, 0x00	; 0
     cc6:	91 95       	neg	r25
     cc8:	81 95       	neg	r24
     cca:	91 09       	sbc	r25, r1
     ccc:	2e 81       	ldd	r18, Y+6	; 0x06
     cce:	3f 81       	ldd	r19, Y+7	; 0x07
     cd0:	28 0f       	add	r18, r24
     cd2:	39 1f       	adc	r19, r25
     cd4:	3f 83       	std	Y+7, r19	; 0x07
     cd6:	2e 83       	std	Y+6, r18	; 0x06
     cd8:	48 81       	ld	r20, Y
     cda:	59 81       	ldd	r21, Y+1	; 0x01
     cdc:	24 17       	cp	r18, r20
     cde:	35 07       	cpc	r19, r21
     ce0:	30 f4       	brcc	.+12     	; 0xcee <prvCopyDataToQueue+0x94>
     ce2:	2c 81       	ldd	r18, Y+4	; 0x04
     ce4:	3d 81       	ldd	r19, Y+5	; 0x05
     ce6:	82 0f       	add	r24, r18
     ce8:	93 1f       	adc	r25, r19
     cea:	9f 83       	std	Y+7, r25	; 0x07
     cec:	8e 83       	std	Y+6, r24	; 0x06
     cee:	02 30       	cpi	r16, 0x02	; 2
     cf0:	49 f4       	brne	.+18     	; 0xd04 <prvCopyDataToQueue+0xaa>
     cf2:	11 23       	and	r17, r17
     cf4:	49 f0       	breq	.+18     	; 0xd08 <prvCopyDataToQueue+0xae>
     cf6:	11 50       	subi	r17, 0x01	; 1
     cf8:	80 e0       	ldi	r24, 0x00	; 0
     cfa:	07 c0       	rjmp	.+14     	; 0xd0a <prvCopyDataToQueue+0xb0>
     cfc:	80 e0       	ldi	r24, 0x00	; 0
     cfe:	05 c0       	rjmp	.+10     	; 0xd0a <prvCopyDataToQueue+0xb0>
     d00:	80 e0       	ldi	r24, 0x00	; 0
     d02:	03 c0       	rjmp	.+6      	; 0xd0a <prvCopyDataToQueue+0xb0>
     d04:	80 e0       	ldi	r24, 0x00	; 0
     d06:	01 c0       	rjmp	.+2      	; 0xd0a <prvCopyDataToQueue+0xb0>
     d08:	80 e0       	ldi	r24, 0x00	; 0
     d0a:	1f 5f       	subi	r17, 0xFF	; 255
     d0c:	1a 8f       	std	Y+26, r17	; 0x1a
     d0e:	df 91       	pop	r29
     d10:	cf 91       	pop	r28
     d12:	1f 91       	pop	r17
     d14:	0f 91       	pop	r16
     d16:	08 95       	ret

00000d18 <prvCopyDataFromQueue>:
     d18:	fc 01       	movw	r30, r24
     d1a:	44 8d       	ldd	r20, Z+28	; 0x1c
     d1c:	44 23       	and	r20, r20
     d1e:	a9 f0       	breq	.+42     	; 0xd4a <prvCopyDataFromQueue+0x32>
     d20:	50 e0       	ldi	r21, 0x00	; 0
     d22:	26 81       	ldd	r18, Z+6	; 0x06
     d24:	37 81       	ldd	r19, Z+7	; 0x07
     d26:	24 0f       	add	r18, r20
     d28:	35 1f       	adc	r19, r21
     d2a:	37 83       	std	Z+7, r19	; 0x07
     d2c:	26 83       	std	Z+6, r18	; 0x06
     d2e:	84 81       	ldd	r24, Z+4	; 0x04
     d30:	95 81       	ldd	r25, Z+5	; 0x05
     d32:	28 17       	cp	r18, r24
     d34:	39 07       	cpc	r19, r25
     d36:	20 f0       	brcs	.+8      	; 0xd40 <prvCopyDataFromQueue+0x28>
     d38:	80 81       	ld	r24, Z
     d3a:	91 81       	ldd	r25, Z+1	; 0x01
     d3c:	97 83       	std	Z+7, r25	; 0x07
     d3e:	86 83       	std	Z+6, r24	; 0x06
     d40:	cb 01       	movw	r24, r22
     d42:	66 81       	ldd	r22, Z+6	; 0x06
     d44:	77 81       	ldd	r23, Z+7	; 0x07
     d46:	0e 94 8c 11 	call	0x2318	; 0x2318 <memcpy>
     d4a:	08 95       	ret

00000d4c <prvUnlockQueue>:
     d4c:	ef 92       	push	r14
     d4e:	ff 92       	push	r15
     d50:	0f 93       	push	r16
     d52:	1f 93       	push	r17
     d54:	cf 93       	push	r28
     d56:	8c 01       	movw	r16, r24
     d58:	0f b6       	in	r0, 0x3f	; 63
     d5a:	f8 94       	cli
     d5c:	0f 92       	push	r0
     d5e:	fc 01       	movw	r30, r24
     d60:	c6 8d       	ldd	r28, Z+30	; 0x1e
     d62:	1c 16       	cp	r1, r28
     d64:	ac f4       	brge	.+42     	; 0xd90 <prvUnlockQueue+0x44>
     d66:	81 89       	ldd	r24, Z+17	; 0x11
     d68:	81 11       	cpse	r24, r1
     d6a:	06 c0       	rjmp	.+12     	; 0xd78 <prvUnlockQueue+0x2c>
     d6c:	11 c0       	rjmp	.+34     	; 0xd90 <prvUnlockQueue+0x44>
     d6e:	f8 01       	movw	r30, r16
     d70:	81 89       	ldd	r24, Z+17	; 0x11
     d72:	81 11       	cpse	r24, r1
     d74:	05 c0       	rjmp	.+10     	; 0xd80 <prvUnlockQueue+0x34>
     d76:	0c c0       	rjmp	.+24     	; 0xd90 <prvUnlockQueue+0x44>
     d78:	78 01       	movw	r14, r16
     d7a:	f1 e1       	ldi	r31, 0x11	; 17
     d7c:	ef 0e       	add	r14, r31
     d7e:	f1 1c       	adc	r15, r1
     d80:	c7 01       	movw	r24, r14
     d82:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <xTaskRemoveFromEventList>
     d86:	81 11       	cpse	r24, r1
     d88:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vTaskMissedYield>
     d8c:	c1 50       	subi	r28, 0x01	; 1
     d8e:	79 f7       	brne	.-34     	; 0xd6e <prvUnlockQueue+0x22>
     d90:	8f ef       	ldi	r24, 0xFF	; 255
     d92:	f8 01       	movw	r30, r16
     d94:	86 8f       	std	Z+30, r24	; 0x1e
     d96:	0f 90       	pop	r0
     d98:	0f be       	out	0x3f, r0	; 63
     d9a:	0f b6       	in	r0, 0x3f	; 63
     d9c:	f8 94       	cli
     d9e:	0f 92       	push	r0
     da0:	c5 8d       	ldd	r28, Z+29	; 0x1d
     da2:	1c 16       	cp	r1, r28
     da4:	ac f4       	brge	.+42     	; 0xdd0 <prvUnlockQueue+0x84>
     da6:	80 85       	ldd	r24, Z+8	; 0x08
     da8:	81 11       	cpse	r24, r1
     daa:	06 c0       	rjmp	.+12     	; 0xdb8 <prvUnlockQueue+0x6c>
     dac:	11 c0       	rjmp	.+34     	; 0xdd0 <prvUnlockQueue+0x84>
     dae:	f8 01       	movw	r30, r16
     db0:	80 85       	ldd	r24, Z+8	; 0x08
     db2:	81 11       	cpse	r24, r1
     db4:	05 c0       	rjmp	.+10     	; 0xdc0 <prvUnlockQueue+0x74>
     db6:	0c c0       	rjmp	.+24     	; 0xdd0 <prvUnlockQueue+0x84>
     db8:	78 01       	movw	r14, r16
     dba:	f8 e0       	ldi	r31, 0x08	; 8
     dbc:	ef 0e       	add	r14, r31
     dbe:	f1 1c       	adc	r15, r1
     dc0:	c7 01       	movw	r24, r14
     dc2:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <xTaskRemoveFromEventList>
     dc6:	81 11       	cpse	r24, r1
     dc8:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vTaskMissedYield>
     dcc:	c1 50       	subi	r28, 0x01	; 1
     dce:	79 f7       	brne	.-34     	; 0xdae <prvUnlockQueue+0x62>
     dd0:	8f ef       	ldi	r24, 0xFF	; 255
     dd2:	f8 01       	movw	r30, r16
     dd4:	85 8f       	std	Z+29, r24	; 0x1d
     dd6:	0f 90       	pop	r0
     dd8:	0f be       	out	0x3f, r0	; 63
     dda:	cf 91       	pop	r28
     ddc:	1f 91       	pop	r17
     dde:	0f 91       	pop	r16
     de0:	ff 90       	pop	r15
     de2:	ef 90       	pop	r14
     de4:	08 95       	ret

00000de6 <xQueueGenericReset>:
     de6:	cf 93       	push	r28
     de8:	df 93       	push	r29
     dea:	ec 01       	movw	r28, r24
     dec:	0f b6       	in	r0, 0x3f	; 63
     dee:	f8 94       	cli
     df0:	0f 92       	push	r0
     df2:	e8 81       	ld	r30, Y
     df4:	f9 81       	ldd	r31, Y+1	; 0x01
     df6:	8b 8d       	ldd	r24, Y+27	; 0x1b
     df8:	2c 8d       	ldd	r18, Y+28	; 0x1c
     dfa:	90 e0       	ldi	r25, 0x00	; 0
     dfc:	30 e0       	ldi	r19, 0x00	; 0
     dfe:	82 9f       	mul	r24, r18
     e00:	a0 01       	movw	r20, r0
     e02:	83 9f       	mul	r24, r19
     e04:	50 0d       	add	r21, r0
     e06:	92 9f       	mul	r25, r18
     e08:	50 0d       	add	r21, r0
     e0a:	11 24       	eor	r1, r1
     e0c:	4e 0f       	add	r20, r30
     e0e:	5f 1f       	adc	r21, r31
     e10:	5d 83       	std	Y+5, r21	; 0x05
     e12:	4c 83       	std	Y+4, r20	; 0x04
     e14:	1a 8e       	std	Y+26, r1	; 0x1a
     e16:	fb 83       	std	Y+3, r31	; 0x03
     e18:	ea 83       	std	Y+2, r30	; 0x02
     e1a:	01 97       	sbiw	r24, 0x01	; 1
     e1c:	82 9f       	mul	r24, r18
     e1e:	a0 01       	movw	r20, r0
     e20:	83 9f       	mul	r24, r19
     e22:	50 0d       	add	r21, r0
     e24:	92 9f       	mul	r25, r18
     e26:	50 0d       	add	r21, r0
     e28:	11 24       	eor	r1, r1
     e2a:	cf 01       	movw	r24, r30
     e2c:	84 0f       	add	r24, r20
     e2e:	95 1f       	adc	r25, r21
     e30:	9f 83       	std	Y+7, r25	; 0x07
     e32:	8e 83       	std	Y+6, r24	; 0x06
     e34:	8f ef       	ldi	r24, 0xFF	; 255
     e36:	8d 8f       	std	Y+29, r24	; 0x1d
     e38:	8e 8f       	std	Y+30, r24	; 0x1e
     e3a:	61 11       	cpse	r22, r1
     e3c:	0c c0       	rjmp	.+24     	; 0xe56 <xQueueGenericReset+0x70>
     e3e:	88 85       	ldd	r24, Y+8	; 0x08
     e40:	88 23       	and	r24, r24
     e42:	89 f0       	breq	.+34     	; 0xe66 <xQueueGenericReset+0x80>
     e44:	ce 01       	movw	r24, r28
     e46:	08 96       	adiw	r24, 0x08	; 8
     e48:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <xTaskRemoveFromEventList>
     e4c:	88 23       	and	r24, r24
     e4e:	59 f0       	breq	.+22     	; 0xe66 <xQueueGenericReset+0x80>
     e50:	0e 94 69 05 	call	0xad2	; 0xad2 <vPortYield>
     e54:	08 c0       	rjmp	.+16     	; 0xe66 <xQueueGenericReset+0x80>
     e56:	ce 01       	movw	r24, r28
     e58:	08 96       	adiw	r24, 0x08	; 8
     e5a:	0e 94 0b 01 	call	0x216	; 0x216 <vListInitialise>
     e5e:	ce 01       	movw	r24, r28
     e60:	41 96       	adiw	r24, 0x11	; 17
     e62:	0e 94 0b 01 	call	0x216	; 0x216 <vListInitialise>
     e66:	0f 90       	pop	r0
     e68:	0f be       	out	0x3f, r0	; 63
     e6a:	81 e0       	ldi	r24, 0x01	; 1
     e6c:	df 91       	pop	r29
     e6e:	cf 91       	pop	r28
     e70:	08 95       	ret

00000e72 <xQueueGenericCreate>:
     e72:	0f 93       	push	r16
     e74:	1f 93       	push	r17
     e76:	cf 93       	push	r28
     e78:	df 93       	push	r29
     e7a:	08 2f       	mov	r16, r24
     e7c:	16 2f       	mov	r17, r22
     e7e:	66 23       	and	r22, r22
     e80:	c1 f0       	breq	.+48     	; 0xeb2 <xQueueGenericCreate+0x40>
     e82:	86 9f       	mul	r24, r22
     e84:	c0 01       	movw	r24, r0
     e86:	11 24       	eor	r1, r1
     e88:	4f 96       	adiw	r24, 0x1f	; 31
     e8a:	0e 94 b3 00 	call	0x166	; 0x166 <pvPortMalloc>
     e8e:	ec 01       	movw	r28, r24
     e90:	00 97       	sbiw	r24, 0x00	; 0
     e92:	41 f4       	brne	.+16     	; 0xea4 <xQueueGenericCreate+0x32>
     e94:	15 c0       	rjmp	.+42     	; 0xec0 <xQueueGenericCreate+0x4e>
     e96:	0b 8f       	std	Y+27, r16	; 0x1b
     e98:	1c 8f       	std	Y+28, r17	; 0x1c
     e9a:	61 e0       	ldi	r22, 0x01	; 1
     e9c:	ce 01       	movw	r24, r28
     e9e:	0e 94 f3 06 	call	0xde6	; 0xde6 <xQueueGenericReset>
     ea2:	0e c0       	rjmp	.+28     	; 0xec0 <xQueueGenericCreate+0x4e>
     ea4:	4f 96       	adiw	r24, 0x1f	; 31
     ea6:	99 83       	std	Y+1, r25	; 0x01
     ea8:	88 83       	st	Y, r24
     eaa:	f5 cf       	rjmp	.-22     	; 0xe96 <xQueueGenericCreate+0x24>
     eac:	d9 83       	std	Y+1, r29	; 0x01
     eae:	c8 83       	st	Y, r28
     eb0:	f2 cf       	rjmp	.-28     	; 0xe96 <xQueueGenericCreate+0x24>
     eb2:	8f e1       	ldi	r24, 0x1F	; 31
     eb4:	90 e0       	ldi	r25, 0x00	; 0
     eb6:	0e 94 b3 00 	call	0x166	; 0x166 <pvPortMalloc>
     eba:	ec 01       	movw	r28, r24
     ebc:	89 2b       	or	r24, r25
     ebe:	b1 f7       	brne	.-20     	; 0xeac <xQueueGenericCreate+0x3a>
     ec0:	ce 01       	movw	r24, r28
     ec2:	df 91       	pop	r29
     ec4:	cf 91       	pop	r28
     ec6:	1f 91       	pop	r17
     ec8:	0f 91       	pop	r16
     eca:	08 95       	ret

00000ecc <xQueueGenericSend>:
     ecc:	9f 92       	push	r9
     ece:	af 92       	push	r10
     ed0:	bf 92       	push	r11
     ed2:	cf 92       	push	r12
     ed4:	df 92       	push	r13
     ed6:	ef 92       	push	r14
     ed8:	ff 92       	push	r15
     eda:	0f 93       	push	r16
     edc:	1f 93       	push	r17
     ede:	cf 93       	push	r28
     ee0:	df 93       	push	r29
     ee2:	00 d0       	rcall	.+0      	; 0xee4 <xQueueGenericSend+0x18>
     ee4:	00 d0       	rcall	.+0      	; 0xee6 <xQueueGenericSend+0x1a>
     ee6:	1f 92       	push	r1
     ee8:	cd b7       	in	r28, 0x3d	; 61
     eea:	de b7       	in	r29, 0x3e	; 62
     eec:	8c 01       	movw	r16, r24
     eee:	6b 01       	movw	r12, r22
     ef0:	5d 83       	std	Y+5, r21	; 0x05
     ef2:	4c 83       	std	Y+4, r20	; 0x04
     ef4:	a2 2e       	mov	r10, r18
     ef6:	b1 2c       	mov	r11, r1
     ef8:	99 24       	eor	r9, r9
     efa:	93 94       	inc	r9
     efc:	7c 01       	movw	r14, r24
     efe:	88 e0       	ldi	r24, 0x08	; 8
     f00:	e8 0e       	add	r14, r24
     f02:	f1 1c       	adc	r15, r1
     f04:	0f b6       	in	r0, 0x3f	; 63
     f06:	f8 94       	cli
     f08:	0f 92       	push	r0
     f0a:	f8 01       	movw	r30, r16
     f0c:	92 8d       	ldd	r25, Z+26	; 0x1a
     f0e:	83 8d       	ldd	r24, Z+27	; 0x1b
     f10:	98 17       	cp	r25, r24
     f12:	18 f0       	brcs	.+6      	; 0xf1a <xQueueGenericSend+0x4e>
     f14:	f2 e0       	ldi	r31, 0x02	; 2
     f16:	af 12       	cpse	r10, r31
     f18:	19 c0       	rjmp	.+50     	; 0xf4c <xQueueGenericSend+0x80>
     f1a:	4a 2d       	mov	r20, r10
     f1c:	b6 01       	movw	r22, r12
     f1e:	c8 01       	movw	r24, r16
     f20:	0e 94 2d 06 	call	0xc5a	; 0xc5a <prvCopyDataToQueue>
     f24:	f8 01       	movw	r30, r16
     f26:	91 89       	ldd	r25, Z+17	; 0x11
     f28:	99 23       	and	r25, r25
     f2a:	49 f0       	breq	.+18     	; 0xf3e <xQueueGenericSend+0x72>
     f2c:	c8 01       	movw	r24, r16
     f2e:	41 96       	adiw	r24, 0x11	; 17
     f30:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <xTaskRemoveFromEventList>
     f34:	88 23       	and	r24, r24
     f36:	31 f0       	breq	.+12     	; 0xf44 <xQueueGenericSend+0x78>
     f38:	0e 94 69 05 	call	0xad2	; 0xad2 <vPortYield>
     f3c:	03 c0       	rjmp	.+6      	; 0xf44 <xQueueGenericSend+0x78>
     f3e:	81 11       	cpse	r24, r1
     f40:	0e 94 69 05 	call	0xad2	; 0xad2 <vPortYield>
     f44:	0f 90       	pop	r0
     f46:	0f be       	out	0x3f, r0	; 63
     f48:	81 e0       	ldi	r24, 0x01	; 1
     f4a:	50 c0       	rjmp	.+160    	; 0xfec <xQueueGenericSend+0x120>
     f4c:	8c 81       	ldd	r24, Y+4	; 0x04
     f4e:	9d 81       	ldd	r25, Y+5	; 0x05
     f50:	89 2b       	or	r24, r25
     f52:	21 f4       	brne	.+8      	; 0xf5c <xQueueGenericSend+0x90>
     f54:	0f 90       	pop	r0
     f56:	0f be       	out	0x3f, r0	; 63
     f58:	80 e0       	ldi	r24, 0x00	; 0
     f5a:	48 c0       	rjmp	.+144    	; 0xfec <xQueueGenericSend+0x120>
     f5c:	b1 10       	cpse	r11, r1
     f5e:	05 c0       	rjmp	.+10     	; 0xf6a <xQueueGenericSend+0x9e>
     f60:	ce 01       	movw	r24, r28
     f62:	01 96       	adiw	r24, 0x01	; 1
     f64:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <vTaskInternalSetTimeOutState>
     f68:	b9 2c       	mov	r11, r9
     f6a:	0f 90       	pop	r0
     f6c:	0f be       	out	0x3f, r0	; 63
     f6e:	0e 94 ed 0a 	call	0x15da	; 0x15da <vTaskSuspendAll>
     f72:	0f b6       	in	r0, 0x3f	; 63
     f74:	f8 94       	cli
     f76:	0f 92       	push	r0
     f78:	f8 01       	movw	r30, r16
     f7a:	85 8d       	ldd	r24, Z+29	; 0x1d
     f7c:	8f 3f       	cpi	r24, 0xFF	; 255
     f7e:	09 f4       	brne	.+2      	; 0xf82 <xQueueGenericSend+0xb6>
     f80:	15 8e       	std	Z+29, r1	; 0x1d
     f82:	f8 01       	movw	r30, r16
     f84:	86 8d       	ldd	r24, Z+30	; 0x1e
     f86:	8f 3f       	cpi	r24, 0xFF	; 255
     f88:	09 f4       	brne	.+2      	; 0xf8c <xQueueGenericSend+0xc0>
     f8a:	16 8e       	std	Z+30, r1	; 0x1e
     f8c:	0f 90       	pop	r0
     f8e:	0f be       	out	0x3f, r0	; 63
     f90:	be 01       	movw	r22, r28
     f92:	6c 5f       	subi	r22, 0xFC	; 252
     f94:	7f 4f       	sbci	r23, 0xFF	; 255
     f96:	ce 01       	movw	r24, r28
     f98:	01 96       	adiw	r24, 0x01	; 1
     f9a:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <xTaskCheckForTimeOut>
     f9e:	81 11       	cpse	r24, r1
     fa0:	1f c0       	rjmp	.+62     	; 0xfe0 <xQueueGenericSend+0x114>
     fa2:	0f b6       	in	r0, 0x3f	; 63
     fa4:	f8 94       	cli
     fa6:	0f 92       	push	r0
     fa8:	f8 01       	movw	r30, r16
     faa:	92 8d       	ldd	r25, Z+26	; 0x1a
     fac:	83 8d       	ldd	r24, Z+27	; 0x1b
     fae:	0f 90       	pop	r0
     fb0:	0f be       	out	0x3f, r0	; 63
     fb2:	98 13       	cpse	r25, r24
     fb4:	0f c0       	rjmp	.+30     	; 0xfd4 <xQueueGenericSend+0x108>
     fb6:	6c 81       	ldd	r22, Y+4	; 0x04
     fb8:	7d 81       	ldd	r23, Y+5	; 0x05
     fba:	c7 01       	movw	r24, r14
     fbc:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <vTaskPlaceOnEventList>
     fc0:	c8 01       	movw	r24, r16
     fc2:	0e 94 a6 06 	call	0xd4c	; 0xd4c <prvUnlockQueue>
     fc6:	0e 94 b8 0b 	call	0x1770	; 0x1770 <xTaskResumeAll>
     fca:	81 11       	cpse	r24, r1
     fcc:	9b cf       	rjmp	.-202    	; 0xf04 <xQueueGenericSend+0x38>
     fce:	0e 94 69 05 	call	0xad2	; 0xad2 <vPortYield>
     fd2:	98 cf       	rjmp	.-208    	; 0xf04 <xQueueGenericSend+0x38>
     fd4:	c8 01       	movw	r24, r16
     fd6:	0e 94 a6 06 	call	0xd4c	; 0xd4c <prvUnlockQueue>
     fda:	0e 94 b8 0b 	call	0x1770	; 0x1770 <xTaskResumeAll>
     fde:	92 cf       	rjmp	.-220    	; 0xf04 <xQueueGenericSend+0x38>
     fe0:	c8 01       	movw	r24, r16
     fe2:	0e 94 a6 06 	call	0xd4c	; 0xd4c <prvUnlockQueue>
     fe6:	0e 94 b8 0b 	call	0x1770	; 0x1770 <xTaskResumeAll>
     fea:	80 e0       	ldi	r24, 0x00	; 0
     fec:	0f 90       	pop	r0
     fee:	0f 90       	pop	r0
     ff0:	0f 90       	pop	r0
     ff2:	0f 90       	pop	r0
     ff4:	0f 90       	pop	r0
     ff6:	df 91       	pop	r29
     ff8:	cf 91       	pop	r28
     ffa:	1f 91       	pop	r17
     ffc:	0f 91       	pop	r16
     ffe:	ff 90       	pop	r15
    1000:	ef 90       	pop	r14
    1002:	df 90       	pop	r13
    1004:	cf 90       	pop	r12
    1006:	bf 90       	pop	r11
    1008:	af 90       	pop	r10
    100a:	9f 90       	pop	r9
    100c:	08 95       	ret

0000100e <xQueueGenericSendFromISR>:
    100e:	ef 92       	push	r14
    1010:	ff 92       	push	r15
    1012:	0f 93       	push	r16
    1014:	1f 93       	push	r17
    1016:	cf 93       	push	r28
    1018:	df 93       	push	r29
    101a:	8a 01       	movw	r16, r20
    101c:	fc 01       	movw	r30, r24
    101e:	52 8d       	ldd	r21, Z+26	; 0x1a
    1020:	33 8d       	ldd	r19, Z+27	; 0x1b
    1022:	53 17       	cp	r21, r19
    1024:	10 f0       	brcs	.+4      	; 0x102a <xQueueGenericSendFromISR+0x1c>
    1026:	22 30       	cpi	r18, 0x02	; 2
    1028:	f1 f4       	brne	.+60     	; 0x1066 <xQueueGenericSendFromISR+0x58>
    102a:	42 2f       	mov	r20, r18
    102c:	78 01       	movw	r14, r16
    102e:	ec 01       	movw	r28, r24
    1030:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1032:	0e 94 2d 06 	call	0xc5a	; 0xc5a <prvCopyDataToQueue>
    1036:	1f 3f       	cpi	r17, 0xFF	; 255
    1038:	81 f4       	brne	.+32     	; 0x105a <xQueueGenericSendFromISR+0x4c>
    103a:	89 89       	ldd	r24, Y+17	; 0x11
    103c:	88 23       	and	r24, r24
    103e:	a9 f0       	breq	.+42     	; 0x106a <xQueueGenericSendFromISR+0x5c>
    1040:	ce 01       	movw	r24, r28
    1042:	41 96       	adiw	r24, 0x11	; 17
    1044:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <xTaskRemoveFromEventList>
    1048:	88 23       	and	r24, r24
    104a:	89 f0       	breq	.+34     	; 0x106e <xQueueGenericSendFromISR+0x60>
    104c:	e1 14       	cp	r14, r1
    104e:	f1 04       	cpc	r15, r1
    1050:	81 f0       	breq	.+32     	; 0x1072 <xQueueGenericSendFromISR+0x64>
    1052:	81 e0       	ldi	r24, 0x01	; 1
    1054:	f7 01       	movw	r30, r14
    1056:	80 83       	st	Z, r24
    1058:	0d c0       	rjmp	.+26     	; 0x1074 <xQueueGenericSendFromISR+0x66>
    105a:	ff 24       	eor	r15, r15
    105c:	f3 94       	inc	r15
    105e:	f1 0e       	add	r15, r17
    1060:	fe 8e       	std	Y+30, r15	; 0x1e
    1062:	81 e0       	ldi	r24, 0x01	; 1
    1064:	07 c0       	rjmp	.+14     	; 0x1074 <xQueueGenericSendFromISR+0x66>
    1066:	80 e0       	ldi	r24, 0x00	; 0
    1068:	05 c0       	rjmp	.+10     	; 0x1074 <xQueueGenericSendFromISR+0x66>
    106a:	81 e0       	ldi	r24, 0x01	; 1
    106c:	03 c0       	rjmp	.+6      	; 0x1074 <xQueueGenericSendFromISR+0x66>
    106e:	81 e0       	ldi	r24, 0x01	; 1
    1070:	01 c0       	rjmp	.+2      	; 0x1074 <xQueueGenericSendFromISR+0x66>
    1072:	81 e0       	ldi	r24, 0x01	; 1
    1074:	df 91       	pop	r29
    1076:	cf 91       	pop	r28
    1078:	1f 91       	pop	r17
    107a:	0f 91       	pop	r16
    107c:	ff 90       	pop	r15
    107e:	ef 90       	pop	r14
    1080:	08 95       	ret

00001082 <xQueueReceive>:
    1082:	9f 92       	push	r9
    1084:	af 92       	push	r10
    1086:	bf 92       	push	r11
    1088:	cf 92       	push	r12
    108a:	df 92       	push	r13
    108c:	ef 92       	push	r14
    108e:	ff 92       	push	r15
    1090:	0f 93       	push	r16
    1092:	1f 93       	push	r17
    1094:	cf 93       	push	r28
    1096:	df 93       	push	r29
    1098:	00 d0       	rcall	.+0      	; 0x109a <xQueueReceive+0x18>
    109a:	00 d0       	rcall	.+0      	; 0x109c <xQueueReceive+0x1a>
    109c:	1f 92       	push	r1
    109e:	cd b7       	in	r28, 0x3d	; 61
    10a0:	de b7       	in	r29, 0x3e	; 62
    10a2:	8c 01       	movw	r16, r24
    10a4:	5b 01       	movw	r10, r22
    10a6:	5d 83       	std	Y+5, r21	; 0x05
    10a8:	4c 83       	std	Y+4, r20	; 0x04
    10aa:	e1 2c       	mov	r14, r1
    10ac:	99 24       	eor	r9, r9
    10ae:	93 94       	inc	r9
    10b0:	6c 01       	movw	r12, r24
    10b2:	81 e1       	ldi	r24, 0x11	; 17
    10b4:	c8 0e       	add	r12, r24
    10b6:	d1 1c       	adc	r13, r1
    10b8:	0f b6       	in	r0, 0x3f	; 63
    10ba:	f8 94       	cli
    10bc:	0f 92       	push	r0
    10be:	f8 01       	movw	r30, r16
    10c0:	f2 8c       	ldd	r15, Z+26	; 0x1a
    10c2:	ff 20       	and	r15, r15
    10c4:	a9 f0       	breq	.+42     	; 0x10f0 <xQueueReceive+0x6e>
    10c6:	b5 01       	movw	r22, r10
    10c8:	c8 01       	movw	r24, r16
    10ca:	0e 94 8c 06 	call	0xd18	; 0xd18 <prvCopyDataFromQueue>
    10ce:	fa 94       	dec	r15
    10d0:	f8 01       	movw	r30, r16
    10d2:	f2 8e       	std	Z+26, r15	; 0x1a
    10d4:	80 85       	ldd	r24, Z+8	; 0x08
    10d6:	88 23       	and	r24, r24
    10d8:	39 f0       	breq	.+14     	; 0x10e8 <xQueueReceive+0x66>
    10da:	c8 01       	movw	r24, r16
    10dc:	08 96       	adiw	r24, 0x08	; 8
    10de:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <xTaskRemoveFromEventList>
    10e2:	81 11       	cpse	r24, r1
    10e4:	0e 94 69 05 	call	0xad2	; 0xad2 <vPortYield>
    10e8:	0f 90       	pop	r0
    10ea:	0f be       	out	0x3f, r0	; 63
    10ec:	81 e0       	ldi	r24, 0x01	; 1
    10ee:	51 c0       	rjmp	.+162    	; 0x1192 <xQueueReceive+0x110>
    10f0:	8c 81       	ldd	r24, Y+4	; 0x04
    10f2:	9d 81       	ldd	r25, Y+5	; 0x05
    10f4:	89 2b       	or	r24, r25
    10f6:	21 f4       	brne	.+8      	; 0x1100 <xQueueReceive+0x7e>
    10f8:	0f 90       	pop	r0
    10fa:	0f be       	out	0x3f, r0	; 63
    10fc:	80 e0       	ldi	r24, 0x00	; 0
    10fe:	49 c0       	rjmp	.+146    	; 0x1192 <xQueueReceive+0x110>
    1100:	e1 10       	cpse	r14, r1
    1102:	05 c0       	rjmp	.+10     	; 0x110e <xQueueReceive+0x8c>
    1104:	ce 01       	movw	r24, r28
    1106:	01 96       	adiw	r24, 0x01	; 1
    1108:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <vTaskInternalSetTimeOutState>
    110c:	e9 2c       	mov	r14, r9
    110e:	0f 90       	pop	r0
    1110:	0f be       	out	0x3f, r0	; 63
    1112:	0e 94 ed 0a 	call	0x15da	; 0x15da <vTaskSuspendAll>
    1116:	0f b6       	in	r0, 0x3f	; 63
    1118:	f8 94       	cli
    111a:	0f 92       	push	r0
    111c:	f8 01       	movw	r30, r16
    111e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1120:	8f 3f       	cpi	r24, 0xFF	; 255
    1122:	09 f4       	brne	.+2      	; 0x1126 <xQueueReceive+0xa4>
    1124:	15 8e       	std	Z+29, r1	; 0x1d
    1126:	f8 01       	movw	r30, r16
    1128:	86 8d       	ldd	r24, Z+30	; 0x1e
    112a:	8f 3f       	cpi	r24, 0xFF	; 255
    112c:	09 f4       	brne	.+2      	; 0x1130 <xQueueReceive+0xae>
    112e:	16 8e       	std	Z+30, r1	; 0x1e
    1130:	0f 90       	pop	r0
    1132:	0f be       	out	0x3f, r0	; 63
    1134:	be 01       	movw	r22, r28
    1136:	6c 5f       	subi	r22, 0xFC	; 252
    1138:	7f 4f       	sbci	r23, 0xFF	; 255
    113a:	ce 01       	movw	r24, r28
    113c:	01 96       	adiw	r24, 0x01	; 1
    113e:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <xTaskCheckForTimeOut>
    1142:	81 11       	cpse	r24, r1
    1144:	1a c0       	rjmp	.+52     	; 0x117a <xQueueReceive+0xf8>
    1146:	c8 01       	movw	r24, r16
    1148:	0e 94 22 06 	call	0xc44	; 0xc44 <prvIsQueueEmpty>
    114c:	88 23       	and	r24, r24
    114e:	79 f0       	breq	.+30     	; 0x116e <xQueueReceive+0xec>
    1150:	6c 81       	ldd	r22, Y+4	; 0x04
    1152:	7d 81       	ldd	r23, Y+5	; 0x05
    1154:	c6 01       	movw	r24, r12
    1156:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <vTaskPlaceOnEventList>
    115a:	c8 01       	movw	r24, r16
    115c:	0e 94 a6 06 	call	0xd4c	; 0xd4c <prvUnlockQueue>
    1160:	0e 94 b8 0b 	call	0x1770	; 0x1770 <xTaskResumeAll>
    1164:	81 11       	cpse	r24, r1
    1166:	a8 cf       	rjmp	.-176    	; 0x10b8 <xQueueReceive+0x36>
    1168:	0e 94 69 05 	call	0xad2	; 0xad2 <vPortYield>
    116c:	a5 cf       	rjmp	.-182    	; 0x10b8 <xQueueReceive+0x36>
    116e:	c8 01       	movw	r24, r16
    1170:	0e 94 a6 06 	call	0xd4c	; 0xd4c <prvUnlockQueue>
    1174:	0e 94 b8 0b 	call	0x1770	; 0x1770 <xTaskResumeAll>
    1178:	9f cf       	rjmp	.-194    	; 0x10b8 <xQueueReceive+0x36>
    117a:	c8 01       	movw	r24, r16
    117c:	0e 94 a6 06 	call	0xd4c	; 0xd4c <prvUnlockQueue>
    1180:	0e 94 b8 0b 	call	0x1770	; 0x1770 <xTaskResumeAll>
    1184:	c8 01       	movw	r24, r16
    1186:	0e 94 22 06 	call	0xc44	; 0xc44 <prvIsQueueEmpty>
    118a:	88 23       	and	r24, r24
    118c:	09 f4       	brne	.+2      	; 0x1190 <xQueueReceive+0x10e>
    118e:	94 cf       	rjmp	.-216    	; 0x10b8 <xQueueReceive+0x36>
    1190:	80 e0       	ldi	r24, 0x00	; 0
    1192:	0f 90       	pop	r0
    1194:	0f 90       	pop	r0
    1196:	0f 90       	pop	r0
    1198:	0f 90       	pop	r0
    119a:	0f 90       	pop	r0
    119c:	df 91       	pop	r29
    119e:	cf 91       	pop	r28
    11a0:	1f 91       	pop	r17
    11a2:	0f 91       	pop	r16
    11a4:	ff 90       	pop	r15
    11a6:	ef 90       	pop	r14
    11a8:	df 90       	pop	r13
    11aa:	cf 90       	pop	r12
    11ac:	bf 90       	pop	r11
    11ae:	af 90       	pop	r10
    11b0:	9f 90       	pop	r9
    11b2:	08 95       	ret

000011b4 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    11b4:	cf 93       	push	r28
    11b6:	df 93       	push	r29
    11b8:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    11ba:	0f b6       	in	r0, 0x3f	; 63
    11bc:	f8 94       	cli
    11be:	0f 92       	push	r0
    11c0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    11c2:	8f 3f       	cpi	r24, 0xFF	; 255
    11c4:	09 f4       	brne	.+2      	; 0x11c8 <vQueueWaitForMessageRestricted+0x14>
    11c6:	1d 8e       	std	Y+29, r1	; 0x1d
    11c8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    11ca:	8f 3f       	cpi	r24, 0xFF	; 255
    11cc:	09 f4       	brne	.+2      	; 0x11d0 <vQueueWaitForMessageRestricted+0x1c>
    11ce:	1e 8e       	std	Y+30, r1	; 0x1e
    11d0:	0f 90       	pop	r0
    11d2:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    11d4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11d6:	81 11       	cpse	r24, r1
    11d8:	04 c0       	rjmp	.+8      	; 0x11e2 <vQueueWaitForMessageRestricted+0x2e>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    11da:	ce 01       	movw	r24, r28
    11dc:	41 96       	adiw	r24, 0x11	; 17
    11de:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    11e2:	ce 01       	movw	r24, r28
    11e4:	0e 94 a6 06 	call	0xd4c	; 0xd4c <prvUnlockQueue>
	}
    11e8:	df 91       	pop	r29
    11ea:	cf 91       	pop	r28
    11ec:	08 95       	ret

000011ee <prvResetNextTaskUnblockTime>:
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    11ee:	e0 91 62 01 	lds	r30, 0x0162	; 0x800162 <pxDelayedTaskList>
    11f2:	f0 91 63 01 	lds	r31, 0x0163	; 0x800163 <pxDelayedTaskList+0x1>
    11f6:	80 81       	ld	r24, Z
    11f8:	81 11       	cpse	r24, r1
    11fa:	07 c0       	rjmp	.+14     	; 0x120a <prvResetNextTaskUnblockTime+0x1c>
    11fc:	8f ef       	ldi	r24, 0xFF	; 255
    11fe:	9f ef       	ldi	r25, 0xFF	; 255
    1200:	90 93 3a 01 	sts	0x013A, r25	; 0x80013a <xNextTaskUnblockTime+0x1>
    1204:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <xNextTaskUnblockTime>
    1208:	08 95       	ret
    120a:	e0 91 62 01 	lds	r30, 0x0162	; 0x800162 <pxDelayedTaskList>
    120e:	f0 91 63 01 	lds	r31, 0x0163	; 0x800163 <pxDelayedTaskList+0x1>
    1212:	05 80       	ldd	r0, Z+5	; 0x05
    1214:	f6 81       	ldd	r31, Z+6	; 0x06
    1216:	e0 2d       	mov	r30, r0
    1218:	06 80       	ldd	r0, Z+6	; 0x06
    121a:	f7 81       	ldd	r31, Z+7	; 0x07
    121c:	e0 2d       	mov	r30, r0
    121e:	82 81       	ldd	r24, Z+2	; 0x02
    1220:	93 81       	ldd	r25, Z+3	; 0x03
    1222:	90 93 3a 01 	sts	0x013A, r25	; 0x80013a <xNextTaskUnblockTime+0x1>
    1226:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <xNextTaskUnblockTime>
    122a:	08 95       	ret

0000122c <prvAddCurrentTaskToDelayedList>:
    122c:	ff 92       	push	r15
    122e:	0f 93       	push	r16
    1230:	1f 93       	push	r17
    1232:	cf 93       	push	r28
    1234:	df 93       	push	r29
    1236:	ec 01       	movw	r28, r24
    1238:	f6 2e       	mov	r15, r22
    123a:	00 91 41 01 	lds	r16, 0x0141	; 0x800141 <xTickCount>
    123e:	10 91 42 01 	lds	r17, 0x0142	; 0x800142 <xTickCount+0x1>
    1242:	80 91 88 01 	lds	r24, 0x0188	; 0x800188 <pxCurrentTCB>
    1246:	90 91 89 01 	lds	r25, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    124a:	02 96       	adiw	r24, 0x02	; 2
    124c:	0e 94 6f 01 	call	0x2de	; 0x2de <uxListRemove>
    1250:	cf 3f       	cpi	r28, 0xFF	; 255
    1252:	8f ef       	ldi	r24, 0xFF	; 255
    1254:	d8 07       	cpc	r29, r24
    1256:	69 f4       	brne	.+26     	; 0x1272 <prvAddCurrentTaskToDelayedList+0x46>
    1258:	ff 20       	and	r15, r15
    125a:	59 f0       	breq	.+22     	; 0x1272 <prvAddCurrentTaskToDelayedList+0x46>
    125c:	60 91 88 01 	lds	r22, 0x0188	; 0x800188 <pxCurrentTCB>
    1260:	70 91 89 01 	lds	r23, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    1264:	6e 5f       	subi	r22, 0xFE	; 254
    1266:	7f 4f       	sbci	r23, 0xFF	; 255
    1268:	84 e4       	ldi	r24, 0x44	; 68
    126a:	91 e0       	ldi	r25, 0x01	; 1
    126c:	0e 94 1d 01 	call	0x23a	; 0x23a <vListInsertEnd>
    1270:	2f c0       	rjmp	.+94     	; 0x12d0 <prvAddCurrentTaskToDelayedList+0xa4>
    1272:	c0 0f       	add	r28, r16
    1274:	d1 1f       	adc	r29, r17
    1276:	e0 91 88 01 	lds	r30, 0x0188	; 0x800188 <pxCurrentTCB>
    127a:	f0 91 89 01 	lds	r31, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    127e:	d3 83       	std	Z+3, r29	; 0x03
    1280:	c2 83       	std	Z+2, r28	; 0x02
    1282:	c0 17       	cp	r28, r16
    1284:	d1 07       	cpc	r29, r17
    1286:	68 f4       	brcc	.+26     	; 0x12a2 <prvAddCurrentTaskToDelayedList+0x76>
    1288:	60 91 88 01 	lds	r22, 0x0188	; 0x800188 <pxCurrentTCB>
    128c:	70 91 89 01 	lds	r23, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    1290:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <pxOverflowDelayedTaskList>
    1294:	90 91 61 01 	lds	r25, 0x0161	; 0x800161 <pxOverflowDelayedTaskList+0x1>
    1298:	6e 5f       	subi	r22, 0xFE	; 254
    129a:	7f 4f       	sbci	r23, 0xFF	; 255
    129c:	0e 94 3e 01 	call	0x27c	; 0x27c <vListInsert>
    12a0:	17 c0       	rjmp	.+46     	; 0x12d0 <prvAddCurrentTaskToDelayedList+0xa4>
    12a2:	60 91 88 01 	lds	r22, 0x0188	; 0x800188 <pxCurrentTCB>
    12a6:	70 91 89 01 	lds	r23, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    12aa:	80 91 62 01 	lds	r24, 0x0162	; 0x800162 <pxDelayedTaskList>
    12ae:	90 91 63 01 	lds	r25, 0x0163	; 0x800163 <pxDelayedTaskList+0x1>
    12b2:	6e 5f       	subi	r22, 0xFE	; 254
    12b4:	7f 4f       	sbci	r23, 0xFF	; 255
    12b6:	0e 94 3e 01 	call	0x27c	; 0x27c <vListInsert>
    12ba:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <xNextTaskUnblockTime>
    12be:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <xNextTaskUnblockTime+0x1>
    12c2:	c8 17       	cp	r28, r24
    12c4:	d9 07       	cpc	r29, r25
    12c6:	20 f4       	brcc	.+8      	; 0x12d0 <prvAddCurrentTaskToDelayedList+0xa4>
    12c8:	d0 93 3a 01 	sts	0x013A, r29	; 0x80013a <xNextTaskUnblockTime+0x1>
    12cc:	c0 93 39 01 	sts	0x0139, r28	; 0x800139 <xNextTaskUnblockTime>
    12d0:	df 91       	pop	r29
    12d2:	cf 91       	pop	r28
    12d4:	1f 91       	pop	r17
    12d6:	0f 91       	pop	r16
    12d8:	ff 90       	pop	r15
    12da:	08 95       	ret

000012dc <prvIdleTask>:
    12dc:	0e e4       	ldi	r16, 0x4E	; 78
    12de:	11 e0       	ldi	r17, 0x01	; 1
    12e0:	0f 2e       	mov	r0, r31
    12e2:	f4 e6       	ldi	r31, 0x64	; 100
    12e4:	ef 2e       	mov	r14, r31
    12e6:	f1 e0       	ldi	r31, 0x01	; 1
    12e8:	ff 2e       	mov	r15, r31
    12ea:	f0 2d       	mov	r31, r0
    12ec:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxDeletedTasksWaitingCleanUp>
    12f0:	88 23       	and	r24, r24
    12f2:	29 f1       	breq	.+74     	; 0x133e <prvIdleTask+0x62>
    12f4:	0f b6       	in	r0, 0x3f	; 63
    12f6:	f8 94       	cli
    12f8:	0f 92       	push	r0
    12fa:	d8 01       	movw	r26, r16
    12fc:	15 96       	adiw	r26, 0x05	; 5
    12fe:	ed 91       	ld	r30, X+
    1300:	fc 91       	ld	r31, X
    1302:	16 97       	sbiw	r26, 0x06	; 6
    1304:	c6 81       	ldd	r28, Z+6	; 0x06
    1306:	d7 81       	ldd	r29, Z+7	; 0x07
    1308:	ce 01       	movw	r24, r28
    130a:	02 96       	adiw	r24, 0x02	; 2
    130c:	0e 94 6f 01 	call	0x2de	; 0x2de <uxListRemove>
    1310:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <uxCurrentNumberOfTasks>
    1314:	81 50       	subi	r24, 0x01	; 1
    1316:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <uxCurrentNumberOfTasks>
    131a:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxDeletedTasksWaitingCleanUp>
    131e:	81 50       	subi	r24, 0x01	; 1
    1320:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <uxDeletedTasksWaitingCleanUp>
    1324:	0f 90       	pop	r0
    1326:	0f be       	out	0x3f, r0	; 63
    1328:	8f 89       	ldd	r24, Y+23	; 0x17
    132a:	98 8d       	ldd	r25, Y+24	; 0x18
    132c:	0e 94 c6 00 	call	0x18c	; 0x18c <vPortFree>
    1330:	ce 01       	movw	r24, r28
    1332:	0e 94 c6 00 	call	0x18c	; 0x18c <vPortFree>
    1336:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxDeletedTasksWaitingCleanUp>
    133a:	81 11       	cpse	r24, r1
    133c:	db cf       	rjmp	.-74     	; 0x12f4 <prvIdleTask+0x18>
    133e:	f7 01       	movw	r30, r14
    1340:	80 81       	ld	r24, Z
    1342:	82 30       	cpi	r24, 0x02	; 2
    1344:	10 f0       	brcs	.+4      	; 0x134a <prvIdleTask+0x6e>
    1346:	0e 94 69 05 	call	0xad2	; 0xad2 <vPortYield>
    134a:	0e 94 d5 00 	call	0x1aa	; 0x1aa <vApplicationIdleHook>
    134e:	ce cf       	rjmp	.-100    	; 0x12ec <prvIdleTask+0x10>

00001350 <xTaskCreate>:
    1350:	4f 92       	push	r4
    1352:	5f 92       	push	r5
    1354:	6f 92       	push	r6
    1356:	7f 92       	push	r7
    1358:	8f 92       	push	r8
    135a:	9f 92       	push	r9
    135c:	af 92       	push	r10
    135e:	bf 92       	push	r11
    1360:	cf 92       	push	r12
    1362:	df 92       	push	r13
    1364:	ef 92       	push	r14
    1366:	ff 92       	push	r15
    1368:	0f 93       	push	r16
    136a:	cf 93       	push	r28
    136c:	df 93       	push	r29
    136e:	4c 01       	movw	r8, r24
    1370:	6b 01       	movw	r12, r22
    1372:	5a 01       	movw	r10, r20
    1374:	29 01       	movw	r4, r18
    1376:	ca 01       	movw	r24, r20
    1378:	0e 94 b3 00 	call	0x166	; 0x166 <pvPortMalloc>
    137c:	3c 01       	movw	r6, r24
    137e:	89 2b       	or	r24, r25
    1380:	09 f4       	brne	.+2      	; 0x1384 <xTaskCreate+0x34>
    1382:	ec c0       	rjmp	.+472    	; 0x155c <xTaskCreate+0x20c>
    1384:	88 e2       	ldi	r24, 0x28	; 40
    1386:	90 e0       	ldi	r25, 0x00	; 0
    1388:	0e 94 b3 00 	call	0x166	; 0x166 <pvPortMalloc>
    138c:	ec 01       	movw	r28, r24
    138e:	89 2b       	or	r24, r25
    1390:	b1 f0       	breq	.+44     	; 0x13be <xTaskCreate+0x6e>
    1392:	78 8e       	std	Y+24, r7	; 0x18
    1394:	6f 8a       	std	Y+23, r6	; 0x17
    1396:	a5 01       	movw	r20, r10
    1398:	65 ea       	ldi	r22, 0xA5	; 165
    139a:	70 e0       	ldi	r23, 0x00	; 0
    139c:	c3 01       	movw	r24, r6
    139e:	0e 94 95 11 	call	0x232a	; 0x232a <memset>
    13a2:	81 e0       	ldi	r24, 0x01	; 1
    13a4:	a8 1a       	sub	r10, r24
    13a6:	b1 08       	sbc	r11, r1
    13a8:	8f 89       	ldd	r24, Y+23	; 0x17
    13aa:	98 8d       	ldd	r25, Y+24	; 0x18
    13ac:	a8 0e       	add	r10, r24
    13ae:	b9 1e       	adc	r11, r25
    13b0:	d6 01       	movw	r26, r12
    13b2:	8c 91       	ld	r24, X
    13b4:	89 8f       	std	Y+25, r24	; 0x19
    13b6:	8c 91       	ld	r24, X
    13b8:	81 11       	cpse	r24, r1
    13ba:	05 c0       	rjmp	.+10     	; 0x13c6 <xTaskCreate+0x76>
    13bc:	18 c0       	rjmp	.+48     	; 0x13ee <xTaskCreate+0x9e>
    13be:	c3 01       	movw	r24, r6
    13c0:	0e 94 c6 00 	call	0x18c	; 0x18c <vPortFree>
    13c4:	cb c0       	rjmp	.+406    	; 0x155c <xTaskCreate+0x20c>
    13c6:	ae 01       	movw	r20, r28
    13c8:	46 5e       	subi	r20, 0xE6	; 230
    13ca:	5f 4f       	sbci	r21, 0xFF	; 255
    13cc:	f6 01       	movw	r30, r12
    13ce:	31 96       	adiw	r30, 0x01	; 1
    13d0:	b8 e0       	ldi	r27, 0x08	; 8
    13d2:	cb 0e       	add	r12, r27
    13d4:	d1 1c       	adc	r13, r1
    13d6:	cf 01       	movw	r24, r30
    13d8:	21 91       	ld	r18, Z+
    13da:	da 01       	movw	r26, r20
    13dc:	2d 93       	st	X+, r18
    13de:	ad 01       	movw	r20, r26
    13e0:	dc 01       	movw	r26, r24
    13e2:	8c 91       	ld	r24, X
    13e4:	88 23       	and	r24, r24
    13e6:	19 f0       	breq	.+6      	; 0x13ee <xTaskCreate+0x9e>
    13e8:	ec 15       	cp	r30, r12
    13ea:	fd 05       	cpc	r31, r13
    13ec:	a1 f7       	brne	.-24     	; 0x13d6 <xTaskCreate+0x86>
    13ee:	18 a2       	std	Y+32, r1	; 0x20
    13f0:	04 30       	cpi	r16, 0x04	; 4
    13f2:	08 f0       	brcs	.+2      	; 0x13f6 <xTaskCreate+0xa6>
    13f4:	03 e0       	ldi	r16, 0x03	; 3
    13f6:	0e 8b       	std	Y+22, r16	; 0x16
    13f8:	09 a3       	std	Y+33, r16	; 0x21
    13fa:	1a a2       	std	Y+34, r1	; 0x22
    13fc:	6e 01       	movw	r12, r28
    13fe:	b2 e0       	ldi	r27, 0x02	; 2
    1400:	cb 0e       	add	r12, r27
    1402:	d1 1c       	adc	r13, r1
    1404:	c6 01       	movw	r24, r12
    1406:	0e 94 19 01 	call	0x232	; 0x232 <vListInitialiseItem>
    140a:	ce 01       	movw	r24, r28
    140c:	0c 96       	adiw	r24, 0x0c	; 12
    140e:	0e 94 19 01 	call	0x232	; 0x232 <vListInitialiseItem>
    1412:	d9 87       	std	Y+9, r29	; 0x09
    1414:	c8 87       	std	Y+8, r28	; 0x08
    1416:	84 e0       	ldi	r24, 0x04	; 4
    1418:	90 e0       	ldi	r25, 0x00	; 0
    141a:	80 1b       	sub	r24, r16
    141c:	91 09       	sbc	r25, r1
    141e:	9d 87       	std	Y+13, r25	; 0x0d
    1420:	8c 87       	std	Y+12, r24	; 0x0c
    1422:	db 8b       	std	Y+19, r29	; 0x13
    1424:	ca 8b       	std	Y+18, r28	; 0x12
    1426:	1b a2       	std	Y+35, r1	; 0x23
    1428:	1c a2       	std	Y+36, r1	; 0x24
    142a:	1d a2       	std	Y+37, r1	; 0x25
    142c:	1e a2       	std	Y+38, r1	; 0x26
    142e:	1f a2       	std	Y+39, r1	; 0x27
    1430:	a2 01       	movw	r20, r4
    1432:	b4 01       	movw	r22, r8
    1434:	c5 01       	movw	r24, r10
    1436:	0e 94 c5 04 	call	0x98a	; 0x98a <pxPortInitialiseStack>
    143a:	99 83       	std	Y+1, r25	; 0x01
    143c:	88 83       	st	Y, r24
    143e:	e1 14       	cp	r14, r1
    1440:	f1 04       	cpc	r15, r1
    1442:	19 f0       	breq	.+6      	; 0x144a <xTaskCreate+0xfa>
    1444:	f7 01       	movw	r30, r14
    1446:	d1 83       	std	Z+1, r29	; 0x01
    1448:	c0 83       	st	Z, r28
    144a:	0f b6       	in	r0, 0x3f	; 63
    144c:	f8 94       	cli
    144e:	0f 92       	push	r0
    1450:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <uxCurrentNumberOfTasks>
    1454:	8f 5f       	subi	r24, 0xFF	; 255
    1456:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <uxCurrentNumberOfTasks>
    145a:	80 91 88 01 	lds	r24, 0x0188	; 0x800188 <pxCurrentTCB>
    145e:	90 91 89 01 	lds	r25, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    1462:	89 2b       	or	r24, r25
    1464:	d1 f5       	brne	.+116    	; 0x14da <xTaskCreate+0x18a>
    1466:	d0 93 89 01 	sts	0x0189, r29	; 0x800189 <pxCurrentTCB+0x1>
    146a:	c0 93 88 01 	sts	0x0188, r28	; 0x800188 <pxCurrentTCB>
    146e:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <uxCurrentNumberOfTasks>
    1472:	81 30       	cpi	r24, 0x01	; 1
    1474:	09 f0       	breq	.+2      	; 0x1478 <xTaskCreate+0x128>
    1476:	41 c0       	rjmp	.+130    	; 0x14fa <xTaskCreate+0x1aa>
    1478:	84 e6       	ldi	r24, 0x64	; 100
    147a:	91 e0       	ldi	r25, 0x01	; 1
    147c:	0e 94 0b 01 	call	0x216	; 0x216 <vListInitialise>
    1480:	8d e6       	ldi	r24, 0x6D	; 109
    1482:	91 e0       	ldi	r25, 0x01	; 1
    1484:	0e 94 0b 01 	call	0x216	; 0x216 <vListInitialise>
    1488:	86 e7       	ldi	r24, 0x76	; 118
    148a:	91 e0       	ldi	r25, 0x01	; 1
    148c:	0e 94 0b 01 	call	0x216	; 0x216 <vListInitialise>
    1490:	8f e7       	ldi	r24, 0x7F	; 127
    1492:	91 e0       	ldi	r25, 0x01	; 1
    1494:	0e 94 0b 01 	call	0x216	; 0x216 <vListInitialise>
    1498:	8d e2       	ldi	r24, 0x2D	; 45
    149a:	91 e0       	ldi	r25, 0x01	; 1
    149c:	0e 94 0b 01 	call	0x216	; 0x216 <vListInitialise>
    14a0:	84 e2       	ldi	r24, 0x24	; 36
    14a2:	91 e0       	ldi	r25, 0x01	; 1
    14a4:	0e 94 0b 01 	call	0x216	; 0x216 <vListInitialise>
    14a8:	87 e5       	ldi	r24, 0x57	; 87
    14aa:	91 e0       	ldi	r25, 0x01	; 1
    14ac:	0e 94 0b 01 	call	0x216	; 0x216 <vListInitialise>
    14b0:	8e e4       	ldi	r24, 0x4E	; 78
    14b2:	91 e0       	ldi	r25, 0x01	; 1
    14b4:	0e 94 0b 01 	call	0x216	; 0x216 <vListInitialise>
    14b8:	84 e4       	ldi	r24, 0x44	; 68
    14ba:	91 e0       	ldi	r25, 0x01	; 1
    14bc:	0e 94 0b 01 	call	0x216	; 0x216 <vListInitialise>
    14c0:	8d e2       	ldi	r24, 0x2D	; 45
    14c2:	91 e0       	ldi	r25, 0x01	; 1
    14c4:	90 93 63 01 	sts	0x0163, r25	; 0x800163 <pxDelayedTaskList+0x1>
    14c8:	80 93 62 01 	sts	0x0162, r24	; 0x800162 <pxDelayedTaskList>
    14cc:	84 e2       	ldi	r24, 0x24	; 36
    14ce:	91 e0       	ldi	r25, 0x01	; 1
    14d0:	90 93 61 01 	sts	0x0161, r25	; 0x800161 <pxOverflowDelayedTaskList+0x1>
    14d4:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <pxOverflowDelayedTaskList>
    14d8:	10 c0       	rjmp	.+32     	; 0x14fa <xTaskCreate+0x1aa>
    14da:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <xSchedulerRunning>
    14de:	81 11       	cpse	r24, r1
    14e0:	0c c0       	rjmp	.+24     	; 0x14fa <xTaskCreate+0x1aa>
    14e2:	e0 91 88 01 	lds	r30, 0x0188	; 0x800188 <pxCurrentTCB>
    14e6:	f0 91 89 01 	lds	r31, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    14ea:	96 89       	ldd	r25, Z+22	; 0x16
    14ec:	8e 89       	ldd	r24, Y+22	; 0x16
    14ee:	89 17       	cp	r24, r25
    14f0:	20 f0       	brcs	.+8      	; 0x14fa <xTaskCreate+0x1aa>
    14f2:	d0 93 89 01 	sts	0x0189, r29	; 0x800189 <pxCurrentTCB+0x1>
    14f6:	c0 93 88 01 	sts	0x0188, r28	; 0x800188 <pxCurrentTCB>
    14fa:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <uxTaskNumber>
    14fe:	8f 5f       	subi	r24, 0xFF	; 255
    1500:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <uxTaskNumber>
    1504:	8e 89       	ldd	r24, Y+22	; 0x16
    1506:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <uxTopReadyPriority>
    150a:	98 17       	cp	r25, r24
    150c:	10 f4       	brcc	.+4      	; 0x1512 <xTaskCreate+0x1c2>
    150e:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <uxTopReadyPriority>
    1512:	90 e0       	ldi	r25, 0x00	; 0
    1514:	9c 01       	movw	r18, r24
    1516:	22 0f       	add	r18, r18
    1518:	33 1f       	adc	r19, r19
    151a:	22 0f       	add	r18, r18
    151c:	33 1f       	adc	r19, r19
    151e:	22 0f       	add	r18, r18
    1520:	33 1f       	adc	r19, r19
    1522:	82 0f       	add	r24, r18
    1524:	93 1f       	adc	r25, r19
    1526:	b6 01       	movw	r22, r12
    1528:	8c 59       	subi	r24, 0x9C	; 156
    152a:	9e 4f       	sbci	r25, 0xFE	; 254
    152c:	0e 94 1d 01 	call	0x23a	; 0x23a <vListInsertEnd>
    1530:	0f 90       	pop	r0
    1532:	0f be       	out	0x3f, r0	; 63
    1534:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <xSchedulerRunning>
    1538:	88 23       	and	r24, r24
    153a:	61 f0       	breq	.+24     	; 0x1554 <xTaskCreate+0x204>
    153c:	e0 91 88 01 	lds	r30, 0x0188	; 0x800188 <pxCurrentTCB>
    1540:	f0 91 89 01 	lds	r31, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    1544:	96 89       	ldd	r25, Z+22	; 0x16
    1546:	8e 89       	ldd	r24, Y+22	; 0x16
    1548:	98 17       	cp	r25, r24
    154a:	30 f4       	brcc	.+12     	; 0x1558 <xTaskCreate+0x208>
    154c:	0e 94 69 05 	call	0xad2	; 0xad2 <vPortYield>
    1550:	81 e0       	ldi	r24, 0x01	; 1
    1552:	05 c0       	rjmp	.+10     	; 0x155e <xTaskCreate+0x20e>
    1554:	81 e0       	ldi	r24, 0x01	; 1
    1556:	03 c0       	rjmp	.+6      	; 0x155e <xTaskCreate+0x20e>
    1558:	81 e0       	ldi	r24, 0x01	; 1
    155a:	01 c0       	rjmp	.+2      	; 0x155e <xTaskCreate+0x20e>
    155c:	8f ef       	ldi	r24, 0xFF	; 255
    155e:	df 91       	pop	r29
    1560:	cf 91       	pop	r28
    1562:	0f 91       	pop	r16
    1564:	ff 90       	pop	r15
    1566:	ef 90       	pop	r14
    1568:	df 90       	pop	r13
    156a:	cf 90       	pop	r12
    156c:	bf 90       	pop	r11
    156e:	af 90       	pop	r10
    1570:	9f 90       	pop	r9
    1572:	8f 90       	pop	r8
    1574:	7f 90       	pop	r7
    1576:	6f 90       	pop	r6
    1578:	5f 90       	pop	r5
    157a:	4f 90       	pop	r4
    157c:	08 95       	ret

0000157e <vTaskStartScheduler>:
    157e:	ef 92       	push	r14
    1580:	ff 92       	push	r15
    1582:	0f 93       	push	r16
    1584:	0f 2e       	mov	r0, r31
    1586:	f7 e3       	ldi	r31, 0x37	; 55
    1588:	ef 2e       	mov	r14, r31
    158a:	f1 e0       	ldi	r31, 0x01	; 1
    158c:	ff 2e       	mov	r15, r31
    158e:	f0 2d       	mov	r31, r0
    1590:	00 e0       	ldi	r16, 0x00	; 0
    1592:	20 e0       	ldi	r18, 0x00	; 0
    1594:	30 e0       	ldi	r19, 0x00	; 0
    1596:	45 e5       	ldi	r20, 0x55	; 85
    1598:	50 e0       	ldi	r21, 0x00	; 0
    159a:	66 e1       	ldi	r22, 0x16	; 22
    159c:	71 e0       	ldi	r23, 0x01	; 1
    159e:	8e e6       	ldi	r24, 0x6E	; 110
    15a0:	99 e0       	ldi	r25, 0x09	; 9
    15a2:	0e 94 a8 09 	call	0x1350	; 0x1350 <xTaskCreate>
    15a6:	81 30       	cpi	r24, 0x01	; 1
    15a8:	a1 f4       	brne	.+40     	; 0x15d2 <vTaskStartScheduler+0x54>
    15aa:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <xTimerCreateTimerTask>
    15ae:	81 30       	cpi	r24, 0x01	; 1
    15b0:	81 f4       	brne	.+32     	; 0x15d2 <vTaskStartScheduler+0x54>
    15b2:	f8 94       	cli
    15b4:	8f ef       	ldi	r24, 0xFF	; 255
    15b6:	9f ef       	ldi	r25, 0xFF	; 255
    15b8:	90 93 3a 01 	sts	0x013A, r25	; 0x80013a <xNextTaskUnblockTime+0x1>
    15bc:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <xNextTaskUnblockTime>
    15c0:	81 e0       	ldi	r24, 0x01	; 1
    15c2:	80 93 3f 01 	sts	0x013F, r24	; 0x80013f <xSchedulerRunning>
    15c6:	10 92 42 01 	sts	0x0142, r1	; 0x800142 <xTickCount+0x1>
    15ca:	10 92 41 01 	sts	0x0141, r1	; 0x800141 <xTickCount>
    15ce:	0e 94 31 05 	call	0xa62	; 0xa62 <xPortStartScheduler>
    15d2:	0f 91       	pop	r16
    15d4:	ff 90       	pop	r15
    15d6:	ef 90       	pop	r14
    15d8:	08 95       	ret

000015da <vTaskSuspendAll>:
    15da:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uxSchedulerSuspended>
    15de:	8f 5f       	subi	r24, 0xFF	; 255
    15e0:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <uxSchedulerSuspended>
    15e4:	08 95       	ret

000015e6 <xTaskGetTickCount>:
    15e6:	0f b6       	in	r0, 0x3f	; 63
    15e8:	f8 94       	cli
    15ea:	0f 92       	push	r0
    15ec:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <xTickCount>
    15f0:	90 91 42 01 	lds	r25, 0x0142	; 0x800142 <xTickCount+0x1>
    15f4:	0f 90       	pop	r0
    15f6:	0f be       	out	0x3f, r0	; 63
    15f8:	08 95       	ret

000015fa <xTaskIncrementTick>:
    15fa:	cf 92       	push	r12
    15fc:	df 92       	push	r13
    15fe:	ef 92       	push	r14
    1600:	ff 92       	push	r15
    1602:	0f 93       	push	r16
    1604:	1f 93       	push	r17
    1606:	cf 93       	push	r28
    1608:	df 93       	push	r29
    160a:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uxSchedulerSuspended>
    160e:	81 11       	cpse	r24, r1
    1610:	99 c0       	rjmp	.+306    	; 0x1744 <xTaskIncrementTick+0x14a>
    1612:	e0 90 41 01 	lds	r14, 0x0141	; 0x800141 <xTickCount>
    1616:	f0 90 42 01 	lds	r15, 0x0142	; 0x800142 <xTickCount+0x1>
    161a:	8f ef       	ldi	r24, 0xFF	; 255
    161c:	e8 1a       	sub	r14, r24
    161e:	f8 0a       	sbc	r15, r24
    1620:	f0 92 42 01 	sts	0x0142, r15	; 0x800142 <xTickCount+0x1>
    1624:	e0 92 41 01 	sts	0x0141, r14	; 0x800141 <xTickCount>
    1628:	e1 14       	cp	r14, r1
    162a:	f1 04       	cpc	r15, r1
    162c:	b9 f4       	brne	.+46     	; 0x165c <xTaskIncrementTick+0x62>
    162e:	80 91 62 01 	lds	r24, 0x0162	; 0x800162 <pxDelayedTaskList>
    1632:	90 91 63 01 	lds	r25, 0x0163	; 0x800163 <pxDelayedTaskList+0x1>
    1636:	20 91 60 01 	lds	r18, 0x0160	; 0x800160 <pxOverflowDelayedTaskList>
    163a:	30 91 61 01 	lds	r19, 0x0161	; 0x800161 <pxOverflowDelayedTaskList+0x1>
    163e:	30 93 63 01 	sts	0x0163, r19	; 0x800163 <pxDelayedTaskList+0x1>
    1642:	20 93 62 01 	sts	0x0162, r18	; 0x800162 <pxDelayedTaskList>
    1646:	90 93 61 01 	sts	0x0161, r25	; 0x800161 <pxOverflowDelayedTaskList+0x1>
    164a:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <pxOverflowDelayedTaskList>
    164e:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <xNumOfOverflows>
    1652:	8f 5f       	subi	r24, 0xFF	; 255
    1654:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <xNumOfOverflows>
    1658:	0e 94 f7 08 	call	0x11ee	; 0x11ee <prvResetNextTaskUnblockTime>
    165c:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <xNextTaskUnblockTime>
    1660:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <xNextTaskUnblockTime+0x1>
    1664:	e8 16       	cp	r14, r24
    1666:	f9 06       	cpc	r15, r25
    1668:	10 f4       	brcc	.+4      	; 0x166e <xTaskIncrementTick+0x74>
    166a:	d1 2c       	mov	r13, r1
    166c:	53 c0       	rjmp	.+166    	; 0x1714 <xTaskIncrementTick+0x11a>
    166e:	d1 2c       	mov	r13, r1
    1670:	cc 24       	eor	r12, r12
    1672:	c3 94       	inc	r12
    1674:	e0 91 62 01 	lds	r30, 0x0162	; 0x800162 <pxDelayedTaskList>
    1678:	f0 91 63 01 	lds	r31, 0x0163	; 0x800163 <pxDelayedTaskList+0x1>
    167c:	80 81       	ld	r24, Z
    167e:	81 11       	cpse	r24, r1
    1680:	07 c0       	rjmp	.+14     	; 0x1690 <xTaskIncrementTick+0x96>
    1682:	8f ef       	ldi	r24, 0xFF	; 255
    1684:	9f ef       	ldi	r25, 0xFF	; 255
    1686:	90 93 3a 01 	sts	0x013A, r25	; 0x80013a <xNextTaskUnblockTime+0x1>
    168a:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <xNextTaskUnblockTime>
    168e:	42 c0       	rjmp	.+132    	; 0x1714 <xTaskIncrementTick+0x11a>
    1690:	e0 91 62 01 	lds	r30, 0x0162	; 0x800162 <pxDelayedTaskList>
    1694:	f0 91 63 01 	lds	r31, 0x0163	; 0x800163 <pxDelayedTaskList+0x1>
    1698:	05 80       	ldd	r0, Z+5	; 0x05
    169a:	f6 81       	ldd	r31, Z+6	; 0x06
    169c:	e0 2d       	mov	r30, r0
    169e:	c6 81       	ldd	r28, Z+6	; 0x06
    16a0:	d7 81       	ldd	r29, Z+7	; 0x07
    16a2:	8a 81       	ldd	r24, Y+2	; 0x02
    16a4:	9b 81       	ldd	r25, Y+3	; 0x03
    16a6:	e8 16       	cp	r14, r24
    16a8:	f9 06       	cpc	r15, r25
    16aa:	28 f4       	brcc	.+10     	; 0x16b6 <xTaskIncrementTick+0xbc>
    16ac:	90 93 3a 01 	sts	0x013A, r25	; 0x80013a <xNextTaskUnblockTime+0x1>
    16b0:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <xNextTaskUnblockTime>
    16b4:	2f c0       	rjmp	.+94     	; 0x1714 <xTaskIncrementTick+0x11a>
    16b6:	8e 01       	movw	r16, r28
    16b8:	0e 5f       	subi	r16, 0xFE	; 254
    16ba:	1f 4f       	sbci	r17, 0xFF	; 255
    16bc:	c8 01       	movw	r24, r16
    16be:	0e 94 6f 01 	call	0x2de	; 0x2de <uxListRemove>
    16c2:	8c 89       	ldd	r24, Y+20	; 0x14
    16c4:	9d 89       	ldd	r25, Y+21	; 0x15
    16c6:	89 2b       	or	r24, r25
    16c8:	21 f0       	breq	.+8      	; 0x16d2 <xTaskIncrementTick+0xd8>
    16ca:	ce 01       	movw	r24, r28
    16cc:	0c 96       	adiw	r24, 0x0c	; 12
    16ce:	0e 94 6f 01 	call	0x2de	; 0x2de <uxListRemove>
    16d2:	8e 89       	ldd	r24, Y+22	; 0x16
    16d4:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <uxTopReadyPriority>
    16d8:	98 17       	cp	r25, r24
    16da:	10 f4       	brcc	.+4      	; 0x16e0 <xTaskIncrementTick+0xe6>
    16dc:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <uxTopReadyPriority>
    16e0:	90 e0       	ldi	r25, 0x00	; 0
    16e2:	9c 01       	movw	r18, r24
    16e4:	22 0f       	add	r18, r18
    16e6:	33 1f       	adc	r19, r19
    16e8:	22 0f       	add	r18, r18
    16ea:	33 1f       	adc	r19, r19
    16ec:	22 0f       	add	r18, r18
    16ee:	33 1f       	adc	r19, r19
    16f0:	82 0f       	add	r24, r18
    16f2:	93 1f       	adc	r25, r19
    16f4:	b8 01       	movw	r22, r16
    16f6:	8c 59       	subi	r24, 0x9C	; 156
    16f8:	9e 4f       	sbci	r25, 0xFE	; 254
    16fa:	0e 94 1d 01 	call	0x23a	; 0x23a <vListInsertEnd>
    16fe:	e0 91 88 01 	lds	r30, 0x0188	; 0x800188 <pxCurrentTCB>
    1702:	f0 91 89 01 	lds	r31, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    1706:	9e 89       	ldd	r25, Y+22	; 0x16
    1708:	86 89       	ldd	r24, Z+22	; 0x16
    170a:	98 17       	cp	r25, r24
    170c:	08 f4       	brcc	.+2      	; 0x1710 <xTaskIncrementTick+0x116>
    170e:	b2 cf       	rjmp	.-156    	; 0x1674 <xTaskIncrementTick+0x7a>
    1710:	dc 2c       	mov	r13, r12
    1712:	b0 cf       	rjmp	.-160    	; 0x1674 <xTaskIncrementTick+0x7a>
    1714:	e0 91 88 01 	lds	r30, 0x0188	; 0x800188 <pxCurrentTCB>
    1718:	f0 91 89 01 	lds	r31, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    171c:	86 89       	ldd	r24, Z+22	; 0x16
    171e:	90 e0       	ldi	r25, 0x00	; 0
    1720:	fc 01       	movw	r30, r24
    1722:	ee 0f       	add	r30, r30
    1724:	ff 1f       	adc	r31, r31
    1726:	ee 0f       	add	r30, r30
    1728:	ff 1f       	adc	r31, r31
    172a:	ee 0f       	add	r30, r30
    172c:	ff 1f       	adc	r31, r31
    172e:	8e 0f       	add	r24, r30
    1730:	9f 1f       	adc	r25, r31
    1732:	fc 01       	movw	r30, r24
    1734:	ec 59       	subi	r30, 0x9C	; 156
    1736:	fe 4f       	sbci	r31, 0xFE	; 254
    1738:	80 81       	ld	r24, Z
    173a:	82 30       	cpi	r24, 0x02	; 2
    173c:	48 f0       	brcs	.+18     	; 0x1750 <xTaskIncrementTick+0x156>
    173e:	dd 24       	eor	r13, r13
    1740:	d3 94       	inc	r13
    1742:	06 c0       	rjmp	.+12     	; 0x1750 <xTaskIncrementTick+0x156>
    1744:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <uxPendedTicks>
    1748:	8f 5f       	subi	r24, 0xFF	; 255
    174a:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <uxPendedTicks>
    174e:	d1 2c       	mov	r13, r1
    1750:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <xYieldPending>
    1754:	88 23       	and	r24, r24
    1756:	11 f0       	breq	.+4      	; 0x175c <xTaskIncrementTick+0x162>
    1758:	dd 24       	eor	r13, r13
    175a:	d3 94       	inc	r13
    175c:	8d 2d       	mov	r24, r13
    175e:	df 91       	pop	r29
    1760:	cf 91       	pop	r28
    1762:	1f 91       	pop	r17
    1764:	0f 91       	pop	r16
    1766:	ff 90       	pop	r15
    1768:	ef 90       	pop	r14
    176a:	df 90       	pop	r13
    176c:	cf 90       	pop	r12
    176e:	08 95       	ret

00001770 <xTaskResumeAll>:
    1770:	df 92       	push	r13
    1772:	ef 92       	push	r14
    1774:	ff 92       	push	r15
    1776:	0f 93       	push	r16
    1778:	1f 93       	push	r17
    177a:	cf 93       	push	r28
    177c:	df 93       	push	r29
    177e:	0f b6       	in	r0, 0x3f	; 63
    1780:	f8 94       	cli
    1782:	0f 92       	push	r0
    1784:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uxSchedulerSuspended>
    1788:	81 50       	subi	r24, 0x01	; 1
    178a:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <uxSchedulerSuspended>
    178e:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uxSchedulerSuspended>
    1792:	81 11       	cpse	r24, r1
    1794:	5f c0       	rjmp	.+190    	; 0x1854 <xTaskResumeAll+0xe4>
    1796:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <uxCurrentNumberOfTasks>
    179a:	81 11       	cpse	r24, r1
    179c:	33 c0       	rjmp	.+102    	; 0x1804 <xTaskResumeAll+0x94>
    179e:	5d c0       	rjmp	.+186    	; 0x185a <xTaskResumeAll+0xea>
    17a0:	d7 01       	movw	r26, r14
    17a2:	15 96       	adiw	r26, 0x05	; 5
    17a4:	ed 91       	ld	r30, X+
    17a6:	fc 91       	ld	r31, X
    17a8:	16 97       	sbiw	r26, 0x06	; 6
    17aa:	c6 81       	ldd	r28, Z+6	; 0x06
    17ac:	d7 81       	ldd	r29, Z+7	; 0x07
    17ae:	ce 01       	movw	r24, r28
    17b0:	0c 96       	adiw	r24, 0x0c	; 12
    17b2:	0e 94 6f 01 	call	0x2de	; 0x2de <uxListRemove>
    17b6:	8e 01       	movw	r16, r28
    17b8:	0e 5f       	subi	r16, 0xFE	; 254
    17ba:	1f 4f       	sbci	r17, 0xFF	; 255
    17bc:	c8 01       	movw	r24, r16
    17be:	0e 94 6f 01 	call	0x2de	; 0x2de <uxListRemove>
    17c2:	8e 89       	ldd	r24, Y+22	; 0x16
    17c4:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <uxTopReadyPriority>
    17c8:	98 17       	cp	r25, r24
    17ca:	10 f4       	brcc	.+4      	; 0x17d0 <xTaskResumeAll+0x60>
    17cc:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <uxTopReadyPriority>
    17d0:	90 e0       	ldi	r25, 0x00	; 0
    17d2:	9c 01       	movw	r18, r24
    17d4:	22 0f       	add	r18, r18
    17d6:	33 1f       	adc	r19, r19
    17d8:	22 0f       	add	r18, r18
    17da:	33 1f       	adc	r19, r19
    17dc:	22 0f       	add	r18, r18
    17de:	33 1f       	adc	r19, r19
    17e0:	82 0f       	add	r24, r18
    17e2:	93 1f       	adc	r25, r19
    17e4:	b8 01       	movw	r22, r16
    17e6:	8c 59       	subi	r24, 0x9C	; 156
    17e8:	9e 4f       	sbci	r25, 0xFE	; 254
    17ea:	0e 94 1d 01 	call	0x23a	; 0x23a <vListInsertEnd>
    17ee:	e0 91 88 01 	lds	r30, 0x0188	; 0x800188 <pxCurrentTCB>
    17f2:	f0 91 89 01 	lds	r31, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    17f6:	9e 89       	ldd	r25, Y+22	; 0x16
    17f8:	86 89       	ldd	r24, Z+22	; 0x16
    17fa:	98 17       	cp	r25, r24
    17fc:	68 f0       	brcs	.+26     	; 0x1818 <xTaskResumeAll+0xa8>
    17fe:	d0 92 3d 01 	sts	0x013D, r13	; 0x80013d <xYieldPending>
    1802:	0a c0       	rjmp	.+20     	; 0x1818 <xTaskResumeAll+0xa8>
    1804:	c0 e0       	ldi	r28, 0x00	; 0
    1806:	d0 e0       	ldi	r29, 0x00	; 0
    1808:	0f 2e       	mov	r0, r31
    180a:	f7 e5       	ldi	r31, 0x57	; 87
    180c:	ef 2e       	mov	r14, r31
    180e:	f1 e0       	ldi	r31, 0x01	; 1
    1810:	ff 2e       	mov	r15, r31
    1812:	f0 2d       	mov	r31, r0
    1814:	dd 24       	eor	r13, r13
    1816:	d3 94       	inc	r13
    1818:	f7 01       	movw	r30, r14
    181a:	80 81       	ld	r24, Z
    181c:	81 11       	cpse	r24, r1
    181e:	c0 cf       	rjmp	.-128    	; 0x17a0 <xTaskResumeAll+0x30>
    1820:	cd 2b       	or	r28, r29
    1822:	11 f0       	breq	.+4      	; 0x1828 <xTaskResumeAll+0xb8>
    1824:	0e 94 f7 08 	call	0x11ee	; 0x11ee <prvResetNextTaskUnblockTime>
    1828:	c0 91 3e 01 	lds	r28, 0x013E	; 0x80013e <uxPendedTicks>
    182c:	cc 23       	and	r28, r28
    182e:	51 f0       	breq	.+20     	; 0x1844 <xTaskResumeAll+0xd4>
    1830:	d1 e0       	ldi	r29, 0x01	; 1
    1832:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <xTaskIncrementTick>
    1836:	81 11       	cpse	r24, r1
    1838:	d0 93 3d 01 	sts	0x013D, r29	; 0x80013d <xYieldPending>
    183c:	c1 50       	subi	r28, 0x01	; 1
    183e:	c9 f7       	brne	.-14     	; 0x1832 <xTaskResumeAll+0xc2>
    1840:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <uxPendedTicks>
    1844:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <xYieldPending>
    1848:	88 23       	and	r24, r24
    184a:	31 f0       	breq	.+12     	; 0x1858 <xTaskResumeAll+0xe8>
    184c:	0e 94 69 05 	call	0xad2	; 0xad2 <vPortYield>
    1850:	81 e0       	ldi	r24, 0x01	; 1
    1852:	03 c0       	rjmp	.+6      	; 0x185a <xTaskResumeAll+0xea>
    1854:	80 e0       	ldi	r24, 0x00	; 0
    1856:	01 c0       	rjmp	.+2      	; 0x185a <xTaskResumeAll+0xea>
    1858:	80 e0       	ldi	r24, 0x00	; 0
    185a:	0f 90       	pop	r0
    185c:	0f be       	out	0x3f, r0	; 63
    185e:	df 91       	pop	r29
    1860:	cf 91       	pop	r28
    1862:	1f 91       	pop	r17
    1864:	0f 91       	pop	r16
    1866:	ff 90       	pop	r15
    1868:	ef 90       	pop	r14
    186a:	df 90       	pop	r13
    186c:	08 95       	ret

0000186e <vTaskDelayUntil>:
    186e:	0f 93       	push	r16
    1870:	1f 93       	push	r17
    1872:	cf 93       	push	r28
    1874:	df 93       	push	r29
    1876:	8c 01       	movw	r16, r24
    1878:	eb 01       	movw	r28, r22
    187a:	0e 94 ed 0a 	call	0x15da	; 0x15da <vTaskSuspendAll>
    187e:	40 91 41 01 	lds	r20, 0x0141	; 0x800141 <xTickCount>
    1882:	50 91 42 01 	lds	r21, 0x0142	; 0x800142 <xTickCount+0x1>
    1886:	f8 01       	movw	r30, r16
    1888:	20 81       	ld	r18, Z
    188a:	31 81       	ldd	r19, Z+1	; 0x01
    188c:	c9 01       	movw	r24, r18
    188e:	8c 0f       	add	r24, r28
    1890:	9d 1f       	adc	r25, r29
    1892:	42 17       	cp	r20, r18
    1894:	53 07       	cpc	r21, r19
    1896:	48 f4       	brcc	.+18     	; 0x18aa <vTaskDelayUntil+0x3c>
    1898:	82 17       	cp	r24, r18
    189a:	93 07       	cpc	r25, r19
    189c:	e8 f4       	brcc	.+58     	; 0x18d8 <vTaskDelayUntil+0x6a>
    189e:	91 83       	std	Z+1, r25	; 0x01
    18a0:	80 83       	st	Z, r24
    18a2:	48 17       	cp	r20, r24
    18a4:	59 07       	cpc	r21, r25
    18a6:	68 f4       	brcc	.+26     	; 0x18c2 <vTaskDelayUntil+0x54>
    18a8:	07 c0       	rjmp	.+14     	; 0x18b8 <vTaskDelayUntil+0x4a>
    18aa:	82 17       	cp	r24, r18
    18ac:	93 07       	cpc	r25, r19
    18ae:	80 f0       	brcs	.+32     	; 0x18d0 <vTaskDelayUntil+0x62>
    18b0:	48 17       	cp	r20, r24
    18b2:	59 07       	cpc	r21, r25
    18b4:	68 f0       	brcs	.+26     	; 0x18d0 <vTaskDelayUntil+0x62>
    18b6:	10 c0       	rjmp	.+32     	; 0x18d8 <vTaskDelayUntil+0x6a>
    18b8:	60 e0       	ldi	r22, 0x00	; 0
    18ba:	84 1b       	sub	r24, r20
    18bc:	95 0b       	sbc	r25, r21
    18be:	0e 94 16 09 	call	0x122c	; 0x122c <prvAddCurrentTaskToDelayedList>
    18c2:	0e 94 b8 0b 	call	0x1770	; 0x1770 <xTaskResumeAll>
    18c6:	81 11       	cpse	r24, r1
    18c8:	0b c0       	rjmp	.+22     	; 0x18e0 <vTaskDelayUntil+0x72>
    18ca:	0e 94 69 05 	call	0xad2	; 0xad2 <vPortYield>
    18ce:	08 c0       	rjmp	.+16     	; 0x18e0 <vTaskDelayUntil+0x72>
    18d0:	f8 01       	movw	r30, r16
    18d2:	91 83       	std	Z+1, r25	; 0x01
    18d4:	80 83       	st	Z, r24
    18d6:	f0 cf       	rjmp	.-32     	; 0x18b8 <vTaskDelayUntil+0x4a>
    18d8:	f8 01       	movw	r30, r16
    18da:	91 83       	std	Z+1, r25	; 0x01
    18dc:	80 83       	st	Z, r24
    18de:	f1 cf       	rjmp	.-30     	; 0x18c2 <vTaskDelayUntil+0x54>
    18e0:	df 91       	pop	r29
    18e2:	cf 91       	pop	r28
    18e4:	1f 91       	pop	r17
    18e6:	0f 91       	pop	r16
    18e8:	08 95       	ret

000018ea <vTaskSwitchContext>:
    18ea:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uxSchedulerSuspended>
    18ee:	88 23       	and	r24, r24
    18f0:	21 f0       	breq	.+8      	; 0x18fa <vTaskSwitchContext+0x10>
    18f2:	81 e0       	ldi	r24, 0x01	; 1
    18f4:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <xYieldPending>
    18f8:	08 95       	ret
    18fa:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <xYieldPending>
    18fe:	a0 91 88 01 	lds	r26, 0x0188	; 0x800188 <pxCurrentTCB>
    1902:	b0 91 89 01 	lds	r27, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    1906:	e0 91 88 01 	lds	r30, 0x0188	; 0x800188 <pxCurrentTCB>
    190a:	f0 91 89 01 	lds	r31, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    190e:	2d 91       	ld	r18, X+
    1910:	3c 91       	ld	r19, X
    1912:	87 89       	ldd	r24, Z+23	; 0x17
    1914:	90 8d       	ldd	r25, Z+24	; 0x18
    1916:	82 17       	cp	r24, r18
    1918:	93 07       	cpc	r25, r19
    191a:	60 f0       	brcs	.+24     	; 0x1934 <vTaskSwitchContext+0x4a>
    191c:	60 91 88 01 	lds	r22, 0x0188	; 0x800188 <pxCurrentTCB>
    1920:	70 91 89 01 	lds	r23, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    1924:	80 91 88 01 	lds	r24, 0x0188	; 0x800188 <pxCurrentTCB>
    1928:	90 91 89 01 	lds	r25, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    192c:	67 5e       	subi	r22, 0xE7	; 231
    192e:	7f 4f       	sbci	r23, 0xFF	; 255
    1930:	0e 94 fe 00 	call	0x1fc	; 0x1fc <vApplicationStackOverflowHook>
    1934:	20 91 40 01 	lds	r18, 0x0140	; 0x800140 <uxTopReadyPriority>
    1938:	82 2f       	mov	r24, r18
    193a:	90 e0       	ldi	r25, 0x00	; 0
    193c:	fc 01       	movw	r30, r24
    193e:	ee 0f       	add	r30, r30
    1940:	ff 1f       	adc	r31, r31
    1942:	ee 0f       	add	r30, r30
    1944:	ff 1f       	adc	r31, r31
    1946:	ee 0f       	add	r30, r30
    1948:	ff 1f       	adc	r31, r31
    194a:	e8 0f       	add	r30, r24
    194c:	f9 1f       	adc	r31, r25
    194e:	ec 59       	subi	r30, 0x9C	; 156
    1950:	fe 4f       	sbci	r31, 0xFE	; 254
    1952:	30 81       	ld	r19, Z
    1954:	31 11       	cpse	r19, r1
    1956:	11 c0       	rjmp	.+34     	; 0x197a <vTaskSwitchContext+0x90>
    1958:	21 50       	subi	r18, 0x01	; 1
    195a:	82 2f       	mov	r24, r18
    195c:	90 e0       	ldi	r25, 0x00	; 0
    195e:	fc 01       	movw	r30, r24
    1960:	ee 0f       	add	r30, r30
    1962:	ff 1f       	adc	r31, r31
    1964:	ee 0f       	add	r30, r30
    1966:	ff 1f       	adc	r31, r31
    1968:	ee 0f       	add	r30, r30
    196a:	ff 1f       	adc	r31, r31
    196c:	e8 0f       	add	r30, r24
    196e:	f9 1f       	adc	r31, r25
    1970:	ec 59       	subi	r30, 0x9C	; 156
    1972:	fe 4f       	sbci	r31, 0xFE	; 254
    1974:	30 81       	ld	r19, Z
    1976:	33 23       	and	r19, r19
    1978:	79 f3       	breq	.-34     	; 0x1958 <vTaskSwitchContext+0x6e>
    197a:	ac 01       	movw	r20, r24
    197c:	44 0f       	add	r20, r20
    197e:	55 1f       	adc	r21, r21
    1980:	44 0f       	add	r20, r20
    1982:	55 1f       	adc	r21, r21
    1984:	44 0f       	add	r20, r20
    1986:	55 1f       	adc	r21, r21
    1988:	48 0f       	add	r20, r24
    198a:	59 1f       	adc	r21, r25
    198c:	da 01       	movw	r26, r20
    198e:	ac 59       	subi	r26, 0x9C	; 156
    1990:	be 4f       	sbci	r27, 0xFE	; 254
    1992:	11 96       	adiw	r26, 0x01	; 1
    1994:	ed 91       	ld	r30, X+
    1996:	fc 91       	ld	r31, X
    1998:	12 97       	sbiw	r26, 0x02	; 2
    199a:	02 80       	ldd	r0, Z+2	; 0x02
    199c:	f3 81       	ldd	r31, Z+3	; 0x03
    199e:	e0 2d       	mov	r30, r0
    19a0:	12 96       	adiw	r26, 0x02	; 2
    19a2:	fc 93       	st	X, r31
    19a4:	ee 93       	st	-X, r30
    19a6:	11 97       	sbiw	r26, 0x01	; 1
    19a8:	49 59       	subi	r20, 0x99	; 153
    19aa:	5e 4f       	sbci	r21, 0xFE	; 254
    19ac:	e4 17       	cp	r30, r20
    19ae:	f5 07       	cpc	r31, r21
    19b0:	29 f4       	brne	.+10     	; 0x19bc <vTaskSwitchContext+0xd2>
    19b2:	42 81       	ldd	r20, Z+2	; 0x02
    19b4:	53 81       	ldd	r21, Z+3	; 0x03
    19b6:	fd 01       	movw	r30, r26
    19b8:	52 83       	std	Z+2, r21	; 0x02
    19ba:	41 83       	std	Z+1, r20	; 0x01
    19bc:	fc 01       	movw	r30, r24
    19be:	ee 0f       	add	r30, r30
    19c0:	ff 1f       	adc	r31, r31
    19c2:	ee 0f       	add	r30, r30
    19c4:	ff 1f       	adc	r31, r31
    19c6:	ee 0f       	add	r30, r30
    19c8:	ff 1f       	adc	r31, r31
    19ca:	8e 0f       	add	r24, r30
    19cc:	9f 1f       	adc	r25, r31
    19ce:	fc 01       	movw	r30, r24
    19d0:	ec 59       	subi	r30, 0x9C	; 156
    19d2:	fe 4f       	sbci	r31, 0xFE	; 254
    19d4:	01 80       	ldd	r0, Z+1	; 0x01
    19d6:	f2 81       	ldd	r31, Z+2	; 0x02
    19d8:	e0 2d       	mov	r30, r0
    19da:	86 81       	ldd	r24, Z+6	; 0x06
    19dc:	97 81       	ldd	r25, Z+7	; 0x07
    19de:	90 93 89 01 	sts	0x0189, r25	; 0x800189 <pxCurrentTCB+0x1>
    19e2:	80 93 88 01 	sts	0x0188, r24	; 0x800188 <pxCurrentTCB>
    19e6:	20 93 40 01 	sts	0x0140, r18	; 0x800140 <uxTopReadyPriority>
    19ea:	08 95       	ret

000019ec <vTaskPlaceOnEventList>:
    19ec:	cf 93       	push	r28
    19ee:	df 93       	push	r29
    19f0:	eb 01       	movw	r28, r22
    19f2:	60 91 88 01 	lds	r22, 0x0188	; 0x800188 <pxCurrentTCB>
    19f6:	70 91 89 01 	lds	r23, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    19fa:	64 5f       	subi	r22, 0xF4	; 244
    19fc:	7f 4f       	sbci	r23, 0xFF	; 255
    19fe:	0e 94 3e 01 	call	0x27c	; 0x27c <vListInsert>
    1a02:	61 e0       	ldi	r22, 0x01	; 1
    1a04:	ce 01       	movw	r24, r28
    1a06:	0e 94 16 09 	call	0x122c	; 0x122c <prvAddCurrentTaskToDelayedList>
    1a0a:	df 91       	pop	r29
    1a0c:	cf 91       	pop	r28
    1a0e:	08 95       	ret

00001a10 <vTaskPlaceOnEventListRestricted>:
    1a10:	0f 93       	push	r16
    1a12:	1f 93       	push	r17
    1a14:	cf 93       	push	r28
    1a16:	8b 01       	movw	r16, r22
    1a18:	c4 2f       	mov	r28, r20
    1a1a:	60 91 88 01 	lds	r22, 0x0188	; 0x800188 <pxCurrentTCB>
    1a1e:	70 91 89 01 	lds	r23, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    1a22:	64 5f       	subi	r22, 0xF4	; 244
    1a24:	7f 4f       	sbci	r23, 0xFF	; 255
    1a26:	0e 94 1d 01 	call	0x23a	; 0x23a <vListInsertEnd>
    1a2a:	cc 23       	and	r28, r28
    1a2c:	11 f0       	breq	.+4      	; 0x1a32 <vTaskPlaceOnEventListRestricted+0x22>
    1a2e:	0f ef       	ldi	r16, 0xFF	; 255
    1a30:	1f ef       	ldi	r17, 0xFF	; 255
    1a32:	6c 2f       	mov	r22, r28
    1a34:	c8 01       	movw	r24, r16
    1a36:	0e 94 16 09 	call	0x122c	; 0x122c <prvAddCurrentTaskToDelayedList>
    1a3a:	cf 91       	pop	r28
    1a3c:	1f 91       	pop	r17
    1a3e:	0f 91       	pop	r16
    1a40:	08 95       	ret

00001a42 <xTaskRemoveFromEventList>:
    1a42:	0f 93       	push	r16
    1a44:	1f 93       	push	r17
    1a46:	cf 93       	push	r28
    1a48:	df 93       	push	r29
    1a4a:	dc 01       	movw	r26, r24
    1a4c:	15 96       	adiw	r26, 0x05	; 5
    1a4e:	ed 91       	ld	r30, X+
    1a50:	fc 91       	ld	r31, X
    1a52:	16 97       	sbiw	r26, 0x06	; 6
    1a54:	c6 81       	ldd	r28, Z+6	; 0x06
    1a56:	d7 81       	ldd	r29, Z+7	; 0x07
    1a58:	8e 01       	movw	r16, r28
    1a5a:	04 5f       	subi	r16, 0xF4	; 244
    1a5c:	1f 4f       	sbci	r17, 0xFF	; 255
    1a5e:	c8 01       	movw	r24, r16
    1a60:	0e 94 6f 01 	call	0x2de	; 0x2de <uxListRemove>
    1a64:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uxSchedulerSuspended>
    1a68:	81 11       	cpse	r24, r1
    1a6a:	1c c0       	rjmp	.+56     	; 0x1aa4 <xTaskRemoveFromEventList+0x62>
    1a6c:	0a 50       	subi	r16, 0x0A	; 10
    1a6e:	11 09       	sbc	r17, r1
    1a70:	c8 01       	movw	r24, r16
    1a72:	0e 94 6f 01 	call	0x2de	; 0x2de <uxListRemove>
    1a76:	8e 89       	ldd	r24, Y+22	; 0x16
    1a78:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <uxTopReadyPriority>
    1a7c:	98 17       	cp	r25, r24
    1a7e:	10 f4       	brcc	.+4      	; 0x1a84 <xTaskRemoveFromEventList+0x42>
    1a80:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <uxTopReadyPriority>
    1a84:	90 e0       	ldi	r25, 0x00	; 0
    1a86:	9c 01       	movw	r18, r24
    1a88:	22 0f       	add	r18, r18
    1a8a:	33 1f       	adc	r19, r19
    1a8c:	22 0f       	add	r18, r18
    1a8e:	33 1f       	adc	r19, r19
    1a90:	22 0f       	add	r18, r18
    1a92:	33 1f       	adc	r19, r19
    1a94:	82 0f       	add	r24, r18
    1a96:	93 1f       	adc	r25, r19
    1a98:	b8 01       	movw	r22, r16
    1a9a:	8c 59       	subi	r24, 0x9C	; 156
    1a9c:	9e 4f       	sbci	r25, 0xFE	; 254
    1a9e:	0e 94 1d 01 	call	0x23a	; 0x23a <vListInsertEnd>
    1aa2:	05 c0       	rjmp	.+10     	; 0x1aae <xTaskRemoveFromEventList+0x6c>
    1aa4:	b8 01       	movw	r22, r16
    1aa6:	87 e5       	ldi	r24, 0x57	; 87
    1aa8:	91 e0       	ldi	r25, 0x01	; 1
    1aaa:	0e 94 1d 01 	call	0x23a	; 0x23a <vListInsertEnd>
    1aae:	e0 91 88 01 	lds	r30, 0x0188	; 0x800188 <pxCurrentTCB>
    1ab2:	f0 91 89 01 	lds	r31, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    1ab6:	9e 89       	ldd	r25, Y+22	; 0x16
    1ab8:	86 89       	ldd	r24, Z+22	; 0x16
    1aba:	89 17       	cp	r24, r25
    1abc:	20 f4       	brcc	.+8      	; 0x1ac6 <xTaskRemoveFromEventList+0x84>
    1abe:	81 e0       	ldi	r24, 0x01	; 1
    1ac0:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <xYieldPending>
    1ac4:	01 c0       	rjmp	.+2      	; 0x1ac8 <xTaskRemoveFromEventList+0x86>
    1ac6:	80 e0       	ldi	r24, 0x00	; 0
    1ac8:	df 91       	pop	r29
    1aca:	cf 91       	pop	r28
    1acc:	1f 91       	pop	r17
    1ace:	0f 91       	pop	r16
    1ad0:	08 95       	ret

00001ad2 <vTaskInternalSetTimeOutState>:
    1ad2:	20 91 3c 01 	lds	r18, 0x013C	; 0x80013c <xNumOfOverflows>
    1ad6:	fc 01       	movw	r30, r24
    1ad8:	20 83       	st	Z, r18
    1ada:	20 91 41 01 	lds	r18, 0x0141	; 0x800141 <xTickCount>
    1ade:	30 91 42 01 	lds	r19, 0x0142	; 0x800142 <xTickCount+0x1>
    1ae2:	32 83       	std	Z+2, r19	; 0x02
    1ae4:	21 83       	std	Z+1, r18	; 0x01
    1ae6:	08 95       	ret

00001ae8 <xTaskCheckForTimeOut>:
    1ae8:	cf 93       	push	r28
    1aea:	df 93       	push	r29
    1aec:	0f b6       	in	r0, 0x3f	; 63
    1aee:	f8 94       	cli
    1af0:	0f 92       	push	r0
    1af2:	20 91 41 01 	lds	r18, 0x0141	; 0x800141 <xTickCount>
    1af6:	30 91 42 01 	lds	r19, 0x0142	; 0x800142 <xTickCount+0x1>
    1afa:	db 01       	movw	r26, r22
    1afc:	4d 91       	ld	r20, X+
    1afe:	5c 91       	ld	r21, X
    1b00:	4f 3f       	cpi	r20, 0xFF	; 255
    1b02:	bf ef       	ldi	r27, 0xFF	; 255
    1b04:	5b 07       	cpc	r21, r27
    1b06:	f1 f0       	breq	.+60     	; 0x1b44 <xTaskCheckForTimeOut+0x5c>
    1b08:	ec 01       	movw	r28, r24
    1b0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1b0c:	fa 81       	ldd	r31, Y+2	; 0x02
    1b0e:	a0 91 3c 01 	lds	r26, 0x013C	; 0x80013c <xNumOfOverflows>
    1b12:	b8 81       	ld	r27, Y
    1b14:	ba 17       	cp	r27, r26
    1b16:	19 f0       	breq	.+6      	; 0x1b1e <xTaskCheckForTimeOut+0x36>
    1b18:	2e 17       	cp	r18, r30
    1b1a:	3f 07       	cpc	r19, r31
    1b1c:	a8 f4       	brcc	.+42     	; 0x1b48 <xTaskCheckForTimeOut+0x60>
    1b1e:	2e 1b       	sub	r18, r30
    1b20:	3f 0b       	sbc	r19, r31
    1b22:	24 17       	cp	r18, r20
    1b24:	35 07       	cpc	r19, r21
    1b26:	48 f4       	brcc	.+18     	; 0x1b3a <xTaskCheckForTimeOut+0x52>
    1b28:	fb 01       	movw	r30, r22
    1b2a:	42 1b       	sub	r20, r18
    1b2c:	53 0b       	sbc	r21, r19
    1b2e:	51 83       	std	Z+1, r21	; 0x01
    1b30:	40 83       	st	Z, r20
    1b32:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <vTaskInternalSetTimeOutState>
    1b36:	80 e0       	ldi	r24, 0x00	; 0
    1b38:	08 c0       	rjmp	.+16     	; 0x1b4a <xTaskCheckForTimeOut+0x62>
    1b3a:	fb 01       	movw	r30, r22
    1b3c:	11 82       	std	Z+1, r1	; 0x01
    1b3e:	10 82       	st	Z, r1
    1b40:	81 e0       	ldi	r24, 0x01	; 1
    1b42:	03 c0       	rjmp	.+6      	; 0x1b4a <xTaskCheckForTimeOut+0x62>
    1b44:	80 e0       	ldi	r24, 0x00	; 0
    1b46:	01 c0       	rjmp	.+2      	; 0x1b4a <xTaskCheckForTimeOut+0x62>
    1b48:	81 e0       	ldi	r24, 0x01	; 1
    1b4a:	0f 90       	pop	r0
    1b4c:	0f be       	out	0x3f, r0	; 63
    1b4e:	df 91       	pop	r29
    1b50:	cf 91       	pop	r28
    1b52:	08 95       	ret

00001b54 <vTaskMissedYield>:
    1b54:	81 e0       	ldi	r24, 0x01	; 1
    1b56:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <xYieldPending>
    1b5a:	08 95       	ret

00001b5c <uxTaskGetStackHighWaterMark>:
    1b5c:	00 97       	sbiw	r24, 0x00	; 0
    1b5e:	21 f4       	brne	.+8      	; 0x1b68 <uxTaskGetStackHighWaterMark+0xc>
    1b60:	80 91 88 01 	lds	r24, 0x0188	; 0x800188 <pxCurrentTCB>
    1b64:	90 91 89 01 	lds	r25, 0x0189	; 0x800189 <pxCurrentTCB+0x1>
    1b68:	dc 01       	movw	r26, r24
    1b6a:	57 96       	adiw	r26, 0x17	; 23
    1b6c:	ed 91       	ld	r30, X+
    1b6e:	fc 91       	ld	r31, X
    1b70:	58 97       	sbiw	r26, 0x18	; 24
    1b72:	80 81       	ld	r24, Z
    1b74:	85 3a       	cpi	r24, 0xA5	; 165
    1b76:	59 f4       	brne	.+22     	; 0x1b8e <uxTaskGetStackHighWaterMark+0x32>
    1b78:	31 96       	adiw	r30, 0x01	; 1
    1b7a:	80 e0       	ldi	r24, 0x00	; 0
    1b7c:	90 e0       	ldi	r25, 0x00	; 0
    1b7e:	dc 01       	movw	r26, r24
    1b80:	01 96       	adiw	r24, 0x01	; 1
    1b82:	a1 1d       	adc	r26, r1
    1b84:	b1 1d       	adc	r27, r1
    1b86:	21 91       	ld	r18, Z+
    1b88:	25 3a       	cpi	r18, 0xA5	; 165
    1b8a:	d1 f3       	breq	.-12     	; 0x1b80 <uxTaskGetStackHighWaterMark+0x24>
    1b8c:	08 95       	ret
    1b8e:	80 e0       	ldi	r24, 0x00	; 0
    1b90:	90 e0       	ldi	r25, 0x00	; 0
    1b92:	dc 01       	movw	r26, r24
    1b94:	08 95       	ret

00001b96 <xTaskGetSchedulerState>:
    1b96:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <xSchedulerRunning>
    1b9a:	88 23       	and	r24, r24
    1b9c:	31 f0       	breq	.+12     	; 0x1baa <xTaskGetSchedulerState+0x14>
    1b9e:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uxSchedulerSuspended>
    1ba2:	88 23       	and	r24, r24
    1ba4:	21 f0       	breq	.+8      	; 0x1bae <xTaskGetSchedulerState+0x18>
    1ba6:	80 e0       	ldi	r24, 0x00	; 0
    1ba8:	08 95       	ret
    1baa:	81 e0       	ldi	r24, 0x01	; 1
    1bac:	08 95       	ret
    1bae:	82 e0       	ldi	r24, 0x02	; 2
    1bb0:	08 95       	ret

00001bb2 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    1bb2:	0f 93       	push	r16
    1bb4:	1f 93       	push	r17
    1bb6:	cf 93       	push	r28
    1bb8:	df 93       	push	r29
    1bba:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    1bbc:	89 2b       	or	r24, r25
    1bbe:	79 f1       	breq	.+94     	; 0x1c1e <xTaskPriorityDisinherit+0x6c>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    1bc0:	82 a1       	ldd	r24, Z+34	; 0x22
    1bc2:	81 50       	subi	r24, 0x01	; 1
    1bc4:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1bc6:	26 89       	ldd	r18, Z+22	; 0x16
    1bc8:	91 a1       	ldd	r25, Z+33	; 0x21
    1bca:	29 17       	cp	r18, r25
    1bcc:	51 f1       	breq	.+84     	; 0x1c22 <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    1bce:	81 11       	cpse	r24, r1
    1bd0:	2a c0       	rjmp	.+84     	; 0x1c26 <xTaskPriorityDisinherit+0x74>
    1bd2:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1bd4:	8f 01       	movw	r16, r30
    1bd6:	0e 5f       	subi	r16, 0xFE	; 254
    1bd8:	1f 4f       	sbci	r17, 0xFF	; 255
    1bda:	c8 01       	movw	r24, r16
    1bdc:	0e 94 6f 01 	call	0x2de	; 0x2de <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    1be0:	89 a1       	ldd	r24, Y+33	; 0x21
    1be2:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority );
    1be4:	24 e0       	ldi	r18, 0x04	; 4
    1be6:	30 e0       	ldi	r19, 0x00	; 0
    1be8:	28 1b       	sub	r18, r24
    1bea:	31 09       	sbc	r19, r1
    1bec:	3d 87       	std	Y+13, r19	; 0x0d
    1bee:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    1bf0:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <uxTopReadyPriority>
    1bf4:	98 17       	cp	r25, r24
    1bf6:	10 f4       	brcc	.+4      	; 0x1bfc <xTaskPriorityDisinherit+0x4a>
    1bf8:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <uxTopReadyPriority>
    1bfc:	90 e0       	ldi	r25, 0x00	; 0
    1bfe:	9c 01       	movw	r18, r24
    1c00:	22 0f       	add	r18, r18
    1c02:	33 1f       	adc	r19, r19
    1c04:	22 0f       	add	r18, r18
    1c06:	33 1f       	adc	r19, r19
    1c08:	22 0f       	add	r18, r18
    1c0a:	33 1f       	adc	r19, r19
    1c0c:	82 0f       	add	r24, r18
    1c0e:	93 1f       	adc	r25, r19
    1c10:	b8 01       	movw	r22, r16
    1c12:	8c 59       	subi	r24, 0x9C	; 156
    1c14:	9e 4f       	sbci	r25, 0xFE	; 254
    1c16:	0e 94 1d 01 	call	0x23a	; 0x23a <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    1c1a:	81 e0       	ldi	r24, 0x01	; 1
    1c1c:	05 c0       	rjmp	.+10     	; 0x1c28 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    TCB_t * const pxTCB = pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    1c1e:	80 e0       	ldi	r24, 0x00	; 0
    1c20:	03 c0       	rjmp	.+6      	; 0x1c28 <xTaskPriorityDisinherit+0x76>
    1c22:	80 e0       	ldi	r24, 0x00	; 0
    1c24:	01 c0       	rjmp	.+2      	; 0x1c28 <xTaskPriorityDisinherit+0x76>
    1c26:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    1c28:	df 91       	pop	r29
    1c2a:	cf 91       	pop	r28
    1c2c:	1f 91       	pop	r17
    1c2e:	0f 91       	pop	r16
    1c30:	08 95       	ret

00001c32 <prvInsertTimerInActiveList>:
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */
		}

		return pxNewTimer;
	}
    1c32:	fc 01       	movw	r30, r24
    1c34:	73 83       	std	Z+3, r23	; 0x03
    1c36:	62 83       	std	Z+2, r22	; 0x02
    1c38:	91 87       	std	Z+9, r25	; 0x09
    1c3a:	80 87       	std	Z+8, r24	; 0x08
    1c3c:	46 17       	cp	r20, r22
    1c3e:	57 07       	cpc	r21, r23
    1c40:	90 f0       	brcs	.+36     	; 0x1c66 <prvInsertTimerInActiveList+0x34>
    1c42:	42 1b       	sub	r20, r18
    1c44:	53 0b       	sbc	r21, r19
    1c46:	84 85       	ldd	r24, Z+12	; 0x0c
    1c48:	95 85       	ldd	r25, Z+13	; 0x0d
    1c4a:	48 17       	cp	r20, r24
    1c4c:	59 07       	cpc	r21, r25
    1c4e:	e0 f4       	brcc	.+56     	; 0x1c88 <prvInsertTimerInActiveList+0x56>
    1c50:	bf 01       	movw	r22, r30
    1c52:	6e 5f       	subi	r22, 0xFE	; 254
    1c54:	7f 4f       	sbci	r23, 0xFF	; 255
    1c56:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <pxOverflowTimerList>
    1c5a:	90 91 a3 01 	lds	r25, 0x01A3	; 0x8001a3 <pxOverflowTimerList+0x1>
    1c5e:	0e 94 3e 01 	call	0x27c	; 0x27c <vListInsert>
    1c62:	80 e0       	ldi	r24, 0x00	; 0
    1c64:	08 95       	ret
    1c66:	42 17       	cp	r20, r18
    1c68:	53 07       	cpc	r21, r19
    1c6a:	18 f4       	brcc	.+6      	; 0x1c72 <prvInsertTimerInActiveList+0x40>
    1c6c:	62 17       	cp	r22, r18
    1c6e:	73 07       	cpc	r23, r19
    1c70:	68 f4       	brcc	.+26     	; 0x1c8c <prvInsertTimerInActiveList+0x5a>
    1c72:	bf 01       	movw	r22, r30
    1c74:	6e 5f       	subi	r22, 0xFE	; 254
    1c76:	7f 4f       	sbci	r23, 0xFF	; 255
    1c78:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <pxCurrentTimerList>
    1c7c:	90 91 a5 01 	lds	r25, 0x01A5	; 0x8001a5 <pxCurrentTimerList+0x1>
    1c80:	0e 94 3e 01 	call	0x27c	; 0x27c <vListInsert>
    1c84:	80 e0       	ldi	r24, 0x00	; 0
    1c86:	08 95       	ret
    1c88:	81 e0       	ldi	r24, 0x01	; 1
    1c8a:	08 95       	ret
    1c8c:	81 e0       	ldi	r24, 0x01	; 1
    1c8e:	08 95       	ret

00001c90 <prvCheckForValidListAndQueue>:
    1c90:	0f b6       	in	r0, 0x3f	; 63
    1c92:	f8 94       	cli
    1c94:	0f 92       	push	r0
    1c96:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <xTimerQueue>
    1c9a:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <xTimerQueue+0x1>
    1c9e:	89 2b       	or	r24, r25
    1ca0:	e9 f4       	brne	.+58     	; 0x1cdc <prvCheckForValidListAndQueue+0x4c>
    1ca2:	83 e9       	ldi	r24, 0x93	; 147
    1ca4:	91 e0       	ldi	r25, 0x01	; 1
    1ca6:	0e 94 0b 01 	call	0x216	; 0x216 <vListInitialise>
    1caa:	8a e8       	ldi	r24, 0x8A	; 138
    1cac:	91 e0       	ldi	r25, 0x01	; 1
    1cae:	0e 94 0b 01 	call	0x216	; 0x216 <vListInitialise>
    1cb2:	83 e9       	ldi	r24, 0x93	; 147
    1cb4:	91 e0       	ldi	r25, 0x01	; 1
    1cb6:	90 93 a5 01 	sts	0x01A5, r25	; 0x8001a5 <pxCurrentTimerList+0x1>
    1cba:	80 93 a4 01 	sts	0x01A4, r24	; 0x8001a4 <pxCurrentTimerList>
    1cbe:	8a e8       	ldi	r24, 0x8A	; 138
    1cc0:	91 e0       	ldi	r25, 0x01	; 1
    1cc2:	90 93 a3 01 	sts	0x01A3, r25	; 0x8001a3 <pxOverflowTimerList+0x1>
    1cc6:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <pxOverflowTimerList>
    1cca:	40 e0       	ldi	r20, 0x00	; 0
    1ccc:	65 e0       	ldi	r22, 0x05	; 5
    1cce:	8a e0       	ldi	r24, 0x0A	; 10
    1cd0:	0e 94 39 07 	call	0xe72	; 0xe72 <xQueueGenericCreate>
    1cd4:	90 93 a1 01 	sts	0x01A1, r25	; 0x8001a1 <xTimerQueue+0x1>
    1cd8:	80 93 a0 01 	sts	0x01A0, r24	; 0x8001a0 <xTimerQueue>
    1cdc:	0f 90       	pop	r0
    1cde:	0f be       	out	0x3f, r0	; 63
    1ce0:	08 95       	ret

00001ce2 <xTimerCreateTimerTask>:
    1ce2:	ef 92       	push	r14
    1ce4:	ff 92       	push	r15
    1ce6:	0f 93       	push	r16
    1ce8:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <prvCheckForValidListAndQueue>
    1cec:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <xTimerQueue>
    1cf0:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <xTimerQueue+0x1>
    1cf4:	89 2b       	or	r24, r25
    1cf6:	91 f0       	breq	.+36     	; 0x1d1c <xTimerCreateTimerTask+0x3a>
    1cf8:	0f 2e       	mov	r0, r31
    1cfa:	fe e9       	ldi	r31, 0x9E	; 158
    1cfc:	ef 2e       	mov	r14, r31
    1cfe:	f1 e0       	ldi	r31, 0x01	; 1
    1d00:	ff 2e       	mov	r15, r31
    1d02:	f0 2d       	mov	r31, r0
    1d04:	03 e0       	ldi	r16, 0x03	; 3
    1d06:	20 e0       	ldi	r18, 0x00	; 0
    1d08:	30 e0       	ldi	r19, 0x00	; 0
    1d0a:	45 e5       	ldi	r20, 0x55	; 85
    1d0c:	50 e0       	ldi	r21, 0x00	; 0
    1d0e:	6b e1       	ldi	r22, 0x1B	; 27
    1d10:	71 e0       	ldi	r23, 0x01	; 1
    1d12:	8b e4       	ldi	r24, 0x4B	; 75
    1d14:	9f e0       	ldi	r25, 0x0F	; 15
    1d16:	0e 94 a8 09 	call	0x1350	; 0x1350 <xTaskCreate>
    1d1a:	01 c0       	rjmp	.+2      	; 0x1d1e <xTimerCreateTimerTask+0x3c>
    1d1c:	80 e0       	ldi	r24, 0x00	; 0
    1d1e:	0f 91       	pop	r16
    1d20:	ff 90       	pop	r15
    1d22:	ef 90       	pop	r14
    1d24:	08 95       	ret

00001d26 <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    1d26:	0f 93       	push	r16
    1d28:	1f 93       	push	r17
    1d2a:	cf 93       	push	r28
    1d2c:	df 93       	push	r29
    1d2e:	00 d0       	rcall	.+0      	; 0x1d30 <xTimerGenericCommand+0xa>
    1d30:	00 d0       	rcall	.+0      	; 0x1d32 <xTimerGenericCommand+0xc>
    1d32:	1f 92       	push	r1
    1d34:	cd b7       	in	r28, 0x3d	; 61
    1d36:	de b7       	in	r29, 0x3e	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    1d38:	e0 91 a0 01 	lds	r30, 0x01A0	; 0x8001a0 <xTimerQueue>
    1d3c:	f0 91 a1 01 	lds	r31, 0x01A1	; 0x8001a1 <xTimerQueue+0x1>
    1d40:	30 97       	sbiw	r30, 0x00	; 0
    1d42:	71 f1       	breq	.+92     	; 0x1da0 <xTimerGenericCommand+0x7a>
    1d44:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    1d46:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    1d48:	5b 83       	std	Y+3, r21	; 0x03
    1d4a:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    1d4c:	9d 83       	std	Y+5, r25	; 0x05
    1d4e:	8c 83       	std	Y+4, r24	; 0x04

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    1d50:	66 30       	cpi	r22, 0x06	; 6
    1d52:	ec f4       	brge	.+58     	; 0x1d8e <xTimerGenericCommand+0x68>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    1d54:	0e 94 cb 0d 	call	0x1b96	; 0x1b96 <xTaskGetSchedulerState>
    1d58:	82 30       	cpi	r24, 0x02	; 2
    1d5a:	61 f4       	brne	.+24     	; 0x1d74 <xTimerGenericCommand+0x4e>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    1d5c:	20 e0       	ldi	r18, 0x00	; 0
    1d5e:	a8 01       	movw	r20, r16
    1d60:	be 01       	movw	r22, r28
    1d62:	6f 5f       	subi	r22, 0xFF	; 255
    1d64:	7f 4f       	sbci	r23, 0xFF	; 255
    1d66:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <xTimerQueue>
    1d6a:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <xTimerQueue+0x1>
    1d6e:	0e 94 66 07 	call	0xecc	; 0xecc <xQueueGenericSend>
    1d72:	17 c0       	rjmp	.+46     	; 0x1da2 <xTimerGenericCommand+0x7c>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    1d74:	20 e0       	ldi	r18, 0x00	; 0
    1d76:	40 e0       	ldi	r20, 0x00	; 0
    1d78:	50 e0       	ldi	r21, 0x00	; 0
    1d7a:	be 01       	movw	r22, r28
    1d7c:	6f 5f       	subi	r22, 0xFF	; 255
    1d7e:	7f 4f       	sbci	r23, 0xFF	; 255
    1d80:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <xTimerQueue>
    1d84:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <xTimerQueue+0x1>
    1d88:	0e 94 66 07 	call	0xecc	; 0xecc <xQueueGenericSend>
    1d8c:	0a c0       	rjmp	.+20     	; 0x1da2 <xTimerGenericCommand+0x7c>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    1d8e:	20 e0       	ldi	r18, 0x00	; 0
    1d90:	ad 01       	movw	r20, r26
    1d92:	be 01       	movw	r22, r28
    1d94:	6f 5f       	subi	r22, 0xFF	; 255
    1d96:	7f 4f       	sbci	r23, 0xFF	; 255
    1d98:	cf 01       	movw	r24, r30
    1d9a:	0e 94 07 08 	call	0x100e	; 0x100e <xQueueGenericSendFromISR>
    1d9e:	01 c0       	rjmp	.+2      	; 0x1da2 <xTimerGenericCommand+0x7c>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    1da0:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    1da2:	0f 90       	pop	r0
    1da4:	0f 90       	pop	r0
    1da6:	0f 90       	pop	r0
    1da8:	0f 90       	pop	r0
    1daa:	0f 90       	pop	r0
    1dac:	df 91       	pop	r29
    1dae:	cf 91       	pop	r28
    1db0:	1f 91       	pop	r17
    1db2:	0f 91       	pop	r16
    1db4:	08 95       	ret

00001db6 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    1db6:	af 92       	push	r10
    1db8:	bf 92       	push	r11
    1dba:	cf 92       	push	r12
    1dbc:	df 92       	push	r13
    1dbe:	ef 92       	push	r14
    1dc0:	ff 92       	push	r15
    1dc2:	0f 93       	push	r16
    1dc4:	1f 93       	push	r17
    1dc6:	cf 93       	push	r28
    1dc8:	df 93       	push	r29
    1dca:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U;

	xTimeNow = xTaskGetTickCount();
    1dcc:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <xTaskGetTickCount>
    1dd0:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    1dd2:	80 91 9c 01 	lds	r24, 0x019C	; 0x80019c <xLastTime.2379>
    1dd6:	90 91 9d 01 	lds	r25, 0x019D	; 0x80019d <xLastTime.2379+0x1>
    1dda:	e8 16       	cp	r14, r24
    1ddc:	f9 06       	cpc	r15, r25
    1dde:	08 f0       	brcs	.+2      	; 0x1de2 <prvSampleTimeNow+0x2c>
    1de0:	48 c0       	rjmp	.+144    	; 0x1e72 <prvSampleTimeNow+0xbc>
    1de2:	30 c0       	rjmp	.+96     	; 0x1e44 <prvSampleTimeNow+0x8e>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1de4:	05 80       	ldd	r0, Z+5	; 0x05
    1de6:	f6 81       	ldd	r31, Z+6	; 0x06
    1de8:	e0 2d       	mov	r30, r0
    1dea:	a0 80       	ld	r10, Z
    1dec:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    1dee:	c6 81       	ldd	r28, Z+6	; 0x06
    1df0:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1df2:	8e 01       	movw	r16, r28
    1df4:	0e 5f       	subi	r16, 0xFE	; 254
    1df6:	1f 4f       	sbci	r17, 0xFF	; 255
    1df8:	c8 01       	movw	r24, r16
    1dfa:	0e 94 6f 01 	call	0x2de	; 0x2de <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1dfe:	e9 89       	ldd	r30, Y+17	; 0x11
    1e00:	fa 89       	ldd	r31, Y+18	; 0x12
    1e02:	ce 01       	movw	r24, r28
    1e04:	09 95       	icall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1e06:	8e 85       	ldd	r24, Y+14	; 0x0e
    1e08:	81 30       	cpi	r24, 0x01	; 1
    1e0a:	e1 f4       	brne	.+56     	; 0x1e44 <prvSampleTimeNow+0x8e>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    1e0c:	8c 85       	ldd	r24, Y+12	; 0x0c
    1e0e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1e10:	8a 0d       	add	r24, r10
    1e12:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    1e14:	a8 16       	cp	r10, r24
    1e16:	b9 06       	cpc	r11, r25
    1e18:	60 f4       	brcc	.+24     	; 0x1e32 <prvSampleTimeNow+0x7c>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    1e1a:	9b 83       	std	Y+3, r25	; 0x03
    1e1c:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1e1e:	d9 87       	std	Y+9, r29	; 0x09
    1e20:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1e22:	b8 01       	movw	r22, r16
    1e24:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <pxCurrentTimerList>
    1e28:	90 91 a5 01 	lds	r25, 0x01A5	; 0x8001a5 <pxCurrentTimerList+0x1>
    1e2c:	0e 94 3e 01 	call	0x27c	; 0x27c <vListInsert>
    1e30:	09 c0       	rjmp	.+18     	; 0x1e44 <prvSampleTimeNow+0x8e>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1e32:	00 e0       	ldi	r16, 0x00	; 0
    1e34:	10 e0       	ldi	r17, 0x00	; 0
    1e36:	20 e0       	ldi	r18, 0x00	; 0
    1e38:	30 e0       	ldi	r19, 0x00	; 0
    1e3a:	a5 01       	movw	r20, r10
    1e3c:	60 e0       	ldi	r22, 0x00	; 0
    1e3e:	ce 01       	movw	r24, r28
    1e40:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1e44:	e0 91 a4 01 	lds	r30, 0x01A4	; 0x8001a4 <pxCurrentTimerList>
    1e48:	f0 91 a5 01 	lds	r31, 0x01A5	; 0x8001a5 <pxCurrentTimerList+0x1>
    1e4c:	80 81       	ld	r24, Z
    1e4e:	81 11       	cpse	r24, r1
    1e50:	c9 cf       	rjmp	.-110    	; 0x1de4 <prvSampleTimeNow+0x2e>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    1e52:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <pxOverflowTimerList>
    1e56:	90 91 a3 01 	lds	r25, 0x01A3	; 0x8001a3 <pxOverflowTimerList+0x1>
    1e5a:	90 93 a5 01 	sts	0x01A5, r25	; 0x8001a5 <pxCurrentTimerList+0x1>
    1e5e:	80 93 a4 01 	sts	0x01A4, r24	; 0x8001a4 <pxCurrentTimerList>
	pxOverflowTimerList = pxTemp;
    1e62:	f0 93 a3 01 	sts	0x01A3, r31	; 0x8001a3 <pxOverflowTimerList+0x1>
    1e66:	e0 93 a2 01 	sts	0x01A2, r30	; 0x8001a2 <pxOverflowTimerList>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    1e6a:	81 e0       	ldi	r24, 0x01	; 1
    1e6c:	f6 01       	movw	r30, r12
    1e6e:	80 83       	st	Z, r24
    1e70:	02 c0       	rjmp	.+4      	; 0x1e76 <prvSampleTimeNow+0xc0>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    1e72:	f6 01       	movw	r30, r12
    1e74:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    1e76:	f0 92 9d 01 	sts	0x019D, r15	; 0x80019d <xLastTime.2379+0x1>
    1e7a:	e0 92 9c 01 	sts	0x019C, r14	; 0x80019c <xLastTime.2379>

	return xTimeNow;
}
    1e7e:	c7 01       	movw	r24, r14
    1e80:	df 91       	pop	r29
    1e82:	cf 91       	pop	r28
    1e84:	1f 91       	pop	r17
    1e86:	0f 91       	pop	r16
    1e88:	ff 90       	pop	r15
    1e8a:	ef 90       	pop	r14
    1e8c:	df 90       	pop	r13
    1e8e:	cf 90       	pop	r12
    1e90:	bf 90       	pop	r11
    1e92:	af 90       	pop	r10
    1e94:	08 95       	ret

00001e96 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    1e96:	cf 93       	push	r28
    1e98:	df 93       	push	r29
    1e9a:	00 d0       	rcall	.+0      	; 0x1e9c <prvTimerTask+0x6>
    1e9c:	00 d0       	rcall	.+0      	; 0x1e9e <prvTimerTask+0x8>
    1e9e:	00 d0       	rcall	.+0      	; 0x1ea0 <prvTimerTask+0xa>
    1ea0:	cd b7       	in	r28, 0x3d	; 61
    1ea2:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1ea4:	ce 01       	movw	r24, r28
    1ea6:	01 96       	adiw	r24, 0x01	; 1
    1ea8:	4c 01       	movw	r8, r24
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1eaa:	44 24       	eor	r4, r4
    1eac:	43 94       	inc	r4
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    1eae:	e1 2c       	mov	r14, r1
    1eb0:	f1 2c       	mov	r15, r1
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1eb2:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
    1eb4:	c8 2e       	mov	r12, r24
    1eb6:	d9 2c       	mov	r13, r9
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    1eb8:	e0 91 a4 01 	lds	r30, 0x01A4	; 0x8001a4 <pxCurrentTimerList>
    1ebc:	f0 91 a5 01 	lds	r31, 0x01A5	; 0x8001a5 <pxCurrentTimerList+0x1>
    1ec0:	80 81       	ld	r24, Z
	if( *pxListWasEmpty == pdFALSE )
    1ec2:	88 23       	and	r24, r24
    1ec4:	09 f4       	brne	.+2      	; 0x1ec8 <prvTimerTask+0x32>
    1ec6:	c2 c0       	rjmp	.+388    	; 0x204c <prvTimerTask+0x1b6>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1ec8:	05 80       	ldd	r0, Z+5	; 0x05
    1eca:	f6 81       	ldd	r31, Z+6	; 0x06
    1ecc:	e0 2d       	mov	r30, r0
    1ece:	a0 80       	ld	r10, Z
    1ed0:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    1ed2:	0e 94 ed 0a 	call	0x15da	; 0x15da <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1ed6:	c4 01       	movw	r24, r8
    1ed8:	0e 94 db 0e 	call	0x1db6	; 0x1db6 <prvSampleTimeNow>
    1edc:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    1ede:	89 81       	ldd	r24, Y+1	; 0x01
    1ee0:	81 11       	cpse	r24, r1
    1ee2:	47 c0       	rjmp	.+142    	; 0x1f72 <prvTimerTask+0xdc>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1ee4:	0a 15       	cp	r16, r10
    1ee6:	1b 05       	cpc	r17, r11
    1ee8:	98 f1       	brcs	.+102    	; 0x1f50 <prvTimerTask+0xba>
			{
				( void ) xTaskResumeAll();
    1eea:	0e 94 b8 0b 	call	0x1770	; 0x1770 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    1eee:	e0 91 a4 01 	lds	r30, 0x01A4	; 0x8001a4 <pxCurrentTimerList>
    1ef2:	f0 91 a5 01 	lds	r31, 0x01A5	; 0x8001a5 <pxCurrentTimerList+0x1>
    1ef6:	05 80       	ldd	r0, Z+5	; 0x05
    1ef8:	f6 81       	ldd	r31, Z+6	; 0x06
    1efa:	e0 2d       	mov	r30, r0
    1efc:	66 80       	ldd	r6, Z+6	; 0x06
    1efe:	77 80       	ldd	r7, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1f00:	c3 01       	movw	r24, r6
    1f02:	02 96       	adiw	r24, 0x02	; 2
    1f04:	0e 94 6f 01 	call	0x2de	; 0x2de <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1f08:	d3 01       	movw	r26, r6
    1f0a:	1e 96       	adiw	r26, 0x0e	; 14
    1f0c:	8c 91       	ld	r24, X
    1f0e:	1e 97       	sbiw	r26, 0x0e	; 14
    1f10:	81 30       	cpi	r24, 0x01	; 1
    1f12:	b1 f4       	brne	.+44     	; 0x1f40 <prvTimerTask+0xaa>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    1f14:	1c 96       	adiw	r26, 0x0c	; 12
    1f16:	6d 91       	ld	r22, X+
    1f18:	7c 91       	ld	r23, X
    1f1a:	1d 97       	sbiw	r26, 0x0d	; 13
    1f1c:	6a 0d       	add	r22, r10
    1f1e:	7b 1d       	adc	r23, r11
    1f20:	95 01       	movw	r18, r10
    1f22:	a8 01       	movw	r20, r16
    1f24:	c3 01       	movw	r24, r6
    1f26:	0e 94 19 0e 	call	0x1c32	; 0x1c32 <prvInsertTimerInActiveList>
    1f2a:	88 23       	and	r24, r24
    1f2c:	49 f0       	breq	.+18     	; 0x1f40 <prvTimerTask+0xaa>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1f2e:	0e 2d       	mov	r16, r14
    1f30:	1f 2d       	mov	r17, r15
    1f32:	2e 2d       	mov	r18, r14
    1f34:	3f 2d       	mov	r19, r15
    1f36:	a5 01       	movw	r20, r10
    1f38:	65 2d       	mov	r22, r5
    1f3a:	c3 01       	movw	r24, r6
    1f3c:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1f40:	d3 01       	movw	r26, r6
    1f42:	51 96       	adiw	r26, 0x11	; 17
    1f44:	ed 91       	ld	r30, X+
    1f46:	fc 91       	ld	r31, X
    1f48:	52 97       	sbiw	r26, 0x12	; 18
    1f4a:	c3 01       	movw	r24, r6
    1f4c:	09 95       	icall
    1f4e:	71 c0       	rjmp	.+226    	; 0x2032 <prvTimerTask+0x19c>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1f50:	45 2d       	mov	r20, r5
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    1f52:	b5 01       	movw	r22, r10
    1f54:	60 1b       	sub	r22, r16
    1f56:	71 0b       	sbc	r23, r17
    1f58:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <xTimerQueue>
    1f5c:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <xTimerQueue+0x1>
    1f60:	0e 94 da 08 	call	0x11b4	; 0x11b4 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    1f64:	0e 94 b8 0b 	call	0x1770	; 0x1770 <xTaskResumeAll>
    1f68:	81 11       	cpse	r24, r1
    1f6a:	63 c0       	rjmp	.+198    	; 0x2032 <prvTimerTask+0x19c>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    1f6c:	0e 94 69 05 	call	0xad2	; 0xad2 <vPortYield>
    1f70:	60 c0       	rjmp	.+192    	; 0x2032 <prvTimerTask+0x19c>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    1f72:	0e 94 b8 0b 	call	0x1770	; 0x1770 <xTaskResumeAll>
    1f76:	5d c0       	rjmp	.+186    	; 0x2032 <prvTimerTask+0x19c>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    1f78:	89 81       	ldd	r24, Y+1	; 0x01
    1f7a:	88 23       	and	r24, r24
    1f7c:	0c f4       	brge	.+2      	; 0x1f80 <prvTimerTask+0xea>
    1f7e:	59 c0       	rjmp	.+178    	; 0x2032 <prvTimerTask+0x19c>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    1f80:	ac 80       	ldd	r10, Y+4	; 0x04
    1f82:	bd 80       	ldd	r11, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    1f84:	f5 01       	movw	r30, r10
    1f86:	82 85       	ldd	r24, Z+10	; 0x0a
    1f88:	93 85       	ldd	r25, Z+11	; 0x0b
    1f8a:	89 2b       	or	r24, r25
    1f8c:	21 f0       	breq	.+8      	; 0x1f96 <prvTimerTask+0x100>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1f8e:	c5 01       	movw	r24, r10
    1f90:	02 96       	adiw	r24, 0x02	; 2
    1f92:	0e 94 6f 01 	call	0x2de	; 0x2de <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1f96:	ce 01       	movw	r24, r28
    1f98:	06 96       	adiw	r24, 0x06	; 6
    1f9a:	0e 94 db 0e 	call	0x1db6	; 0x1db6 <prvSampleTimeNow>

			switch( xMessage.xMessageID )
    1f9e:	e9 81       	ldd	r30, Y+1	; 0x01
    1fa0:	0e 2f       	mov	r16, r30
    1fa2:	ee 0f       	add	r30, r30
    1fa4:	11 0b       	sbc	r17, r17
    1fa6:	22 0b       	sbc	r18, r18
    1fa8:	33 0b       	sbc	r19, r19
    1faa:	0a 30       	cpi	r16, 0x0A	; 10
    1fac:	11 05       	cpc	r17, r1
    1fae:	08 f0       	brcs	.+2      	; 0x1fb2 <prvTimerTask+0x11c>
    1fb0:	40 c0       	rjmp	.+128    	; 0x2032 <prvTimerTask+0x19c>
    1fb2:	f8 01       	movw	r30, r16
    1fb4:	ec 5c       	subi	r30, 0xCC	; 204
    1fb6:	ff 4f       	sbci	r31, 0xFF	; 255
    1fb8:	0c 94 5c 10 	jmp	0x20b8	; 0x20b8 <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    1fbc:	2a 81       	ldd	r18, Y+2	; 0x02
    1fbe:	3b 81       	ldd	r19, Y+3	; 0x03
    1fc0:	d5 01       	movw	r26, r10
    1fc2:	1c 96       	adiw	r26, 0x0c	; 12
    1fc4:	6d 91       	ld	r22, X+
    1fc6:	7c 91       	ld	r23, X
    1fc8:	1d 97       	sbiw	r26, 0x0d	; 13
    1fca:	62 0f       	add	r22, r18
    1fcc:	73 1f       	adc	r23, r19
    1fce:	ac 01       	movw	r20, r24
    1fd0:	c5 01       	movw	r24, r10
    1fd2:	0e 94 19 0e 	call	0x1c32	; 0x1c32 <prvInsertTimerInActiveList>
    1fd6:	88 23       	and	r24, r24
    1fd8:	61 f1       	breq	.+88     	; 0x2032 <prvTimerTask+0x19c>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1fda:	d5 01       	movw	r26, r10
    1fdc:	51 96       	adiw	r26, 0x11	; 17
    1fde:	ed 91       	ld	r30, X+
    1fe0:	fc 91       	ld	r31, X
    1fe2:	52 97       	sbiw	r26, 0x12	; 18
    1fe4:	c5 01       	movw	r24, r10
    1fe6:	09 95       	icall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1fe8:	f5 01       	movw	r30, r10
    1fea:	86 85       	ldd	r24, Z+14	; 0x0e
    1fec:	81 30       	cpi	r24, 0x01	; 1
    1fee:	09 f5       	brne	.+66     	; 0x2032 <prvTimerTask+0x19c>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    1ff0:	4a 81       	ldd	r20, Y+2	; 0x02
    1ff2:	5b 81       	ldd	r21, Y+3	; 0x03
    1ff4:	84 85       	ldd	r24, Z+12	; 0x0c
    1ff6:	95 85       	ldd	r25, Z+13	; 0x0d
    1ff8:	48 0f       	add	r20, r24
    1ffa:	59 1f       	adc	r21, r25
    1ffc:	0e 2d       	mov	r16, r14
    1ffe:	1f 2d       	mov	r17, r15
    2000:	2e 2d       	mov	r18, r14
    2002:	3f 2d       	mov	r19, r15
    2004:	65 2d       	mov	r22, r5
    2006:	c5 01       	movw	r24, r10
    2008:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <xTimerGenericCommand>
    200c:	12 c0       	rjmp	.+36     	; 0x2032 <prvTimerTask+0x19c>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    200e:	6a 81       	ldd	r22, Y+2	; 0x02
    2010:	7b 81       	ldd	r23, Y+3	; 0x03
    2012:	d5 01       	movw	r26, r10
    2014:	1d 96       	adiw	r26, 0x0d	; 13
    2016:	7c 93       	st	X, r23
    2018:	6e 93       	st	-X, r22
    201a:	1c 97       	sbiw	r26, 0x0c	; 12
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    201c:	68 0f       	add	r22, r24
    201e:	79 1f       	adc	r23, r25
    2020:	9c 01       	movw	r18, r24
    2022:	ac 01       	movw	r20, r24
    2024:	c5 01       	movw	r24, r10
    2026:	0e 94 19 0e 	call	0x1c32	; 0x1c32 <prvInsertTimerInActiveList>
    202a:	03 c0       	rjmp	.+6      	; 0x2032 <prvTimerTask+0x19c>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
    202c:	c5 01       	movw	r24, r10
    202e:	0e 94 c6 00 	call	0x18c	; 0x18c <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
    2032:	4e 2d       	mov	r20, r14
    2034:	5f 2d       	mov	r21, r15
    2036:	6c 2d       	mov	r22, r12
    2038:	7d 2d       	mov	r23, r13
    203a:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <xTimerQueue>
    203e:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <xTimerQueue+0x1>
    2042:	0e 94 41 08 	call	0x1082	; 0x1082 <xQueueReceive>
    2046:	81 11       	cpse	r24, r1
    2048:	97 cf       	rjmp	.-210    	; 0x1f78 <prvTimerTask+0xe2>
    204a:	36 cf       	rjmp	.-404    	; 0x1eb8 <prvTimerTask+0x22>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    204c:	0e 94 ed 0a 	call	0x15da	; 0x15da <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2050:	c4 01       	movw	r24, r8
    2052:	0e 94 db 0e 	call	0x1db6	; 0x1db6 <prvSampleTimeNow>
    2056:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    2058:	89 81       	ldd	r24, Y+1	; 0x01
    205a:	81 11       	cpse	r24, r1
    205c:	8a cf       	rjmp	.-236    	; 0x1f72 <prvTimerTask+0xdc>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    205e:	e0 91 a2 01 	lds	r30, 0x01A2	; 0x8001a2 <pxOverflowTimerList>
    2062:	f0 91 a3 01 	lds	r31, 0x01A3	; 0x8001a3 <pxOverflowTimerList+0x1>
    2066:	80 81       	ld	r24, Z
    2068:	44 2d       	mov	r20, r4
    206a:	81 11       	cpse	r24, r1
    206c:	45 2d       	mov	r20, r5
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    206e:	ae 2c       	mov	r10, r14
    2070:	bf 2c       	mov	r11, r15
    2072:	6f cf       	rjmp	.-290    	; 0x1f52 <prvTimerTask+0xbc>

00002074 <__udivmodsi4>:
    2074:	a1 e2       	ldi	r26, 0x21	; 33
    2076:	1a 2e       	mov	r1, r26
    2078:	aa 1b       	sub	r26, r26
    207a:	bb 1b       	sub	r27, r27
    207c:	fd 01       	movw	r30, r26
    207e:	0d c0       	rjmp	.+26     	; 0x209a <__udivmodsi4_ep>

00002080 <__udivmodsi4_loop>:
    2080:	aa 1f       	adc	r26, r26
    2082:	bb 1f       	adc	r27, r27
    2084:	ee 1f       	adc	r30, r30
    2086:	ff 1f       	adc	r31, r31
    2088:	a2 17       	cp	r26, r18
    208a:	b3 07       	cpc	r27, r19
    208c:	e4 07       	cpc	r30, r20
    208e:	f5 07       	cpc	r31, r21
    2090:	20 f0       	brcs	.+8      	; 0x209a <__udivmodsi4_ep>
    2092:	a2 1b       	sub	r26, r18
    2094:	b3 0b       	sbc	r27, r19
    2096:	e4 0b       	sbc	r30, r20
    2098:	f5 0b       	sbc	r31, r21

0000209a <__udivmodsi4_ep>:
    209a:	66 1f       	adc	r22, r22
    209c:	77 1f       	adc	r23, r23
    209e:	88 1f       	adc	r24, r24
    20a0:	99 1f       	adc	r25, r25
    20a2:	1a 94       	dec	r1
    20a4:	69 f7       	brne	.-38     	; 0x2080 <__udivmodsi4_loop>
    20a6:	60 95       	com	r22
    20a8:	70 95       	com	r23
    20aa:	80 95       	com	r24
    20ac:	90 95       	com	r25
    20ae:	9b 01       	movw	r18, r22
    20b0:	ac 01       	movw	r20, r24
    20b2:	bd 01       	movw	r22, r26
    20b4:	cf 01       	movw	r24, r30
    20b6:	08 95       	ret

000020b8 <__tablejump2__>:
    20b8:	ee 0f       	add	r30, r30
    20ba:	ff 1f       	adc	r31, r31
    20bc:	05 90       	lpm	r0, Z+
    20be:	f4 91       	lpm	r31, Z
    20c0:	e0 2d       	mov	r30, r0
    20c2:	09 94       	ijmp

000020c4 <malloc>:
    20c4:	0f 93       	push	r16
    20c6:	1f 93       	push	r17
    20c8:	cf 93       	push	r28
    20ca:	df 93       	push	r29
    20cc:	82 30       	cpi	r24, 0x02	; 2
    20ce:	91 05       	cpc	r25, r1
    20d0:	10 f4       	brcc	.+4      	; 0x20d6 <malloc+0x12>
    20d2:	82 e0       	ldi	r24, 0x02	; 2
    20d4:	90 e0       	ldi	r25, 0x00	; 0
    20d6:	e0 91 ca 01 	lds	r30, 0x01CA	; 0x8001ca <__flp>
    20da:	f0 91 cb 01 	lds	r31, 0x01CB	; 0x8001cb <__flp+0x1>
    20de:	20 e0       	ldi	r18, 0x00	; 0
    20e0:	30 e0       	ldi	r19, 0x00	; 0
    20e2:	a0 e0       	ldi	r26, 0x00	; 0
    20e4:	b0 e0       	ldi	r27, 0x00	; 0
    20e6:	30 97       	sbiw	r30, 0x00	; 0
    20e8:	19 f1       	breq	.+70     	; 0x2130 <malloc+0x6c>
    20ea:	40 81       	ld	r20, Z
    20ec:	51 81       	ldd	r21, Z+1	; 0x01
    20ee:	02 81       	ldd	r16, Z+2	; 0x02
    20f0:	13 81       	ldd	r17, Z+3	; 0x03
    20f2:	48 17       	cp	r20, r24
    20f4:	59 07       	cpc	r21, r25
    20f6:	c8 f0       	brcs	.+50     	; 0x212a <malloc+0x66>
    20f8:	84 17       	cp	r24, r20
    20fa:	95 07       	cpc	r25, r21
    20fc:	69 f4       	brne	.+26     	; 0x2118 <malloc+0x54>
    20fe:	10 97       	sbiw	r26, 0x00	; 0
    2100:	31 f0       	breq	.+12     	; 0x210e <malloc+0x4a>
    2102:	12 96       	adiw	r26, 0x02	; 2
    2104:	0c 93       	st	X, r16
    2106:	12 97       	sbiw	r26, 0x02	; 2
    2108:	13 96       	adiw	r26, 0x03	; 3
    210a:	1c 93       	st	X, r17
    210c:	27 c0       	rjmp	.+78     	; 0x215c <malloc+0x98>
    210e:	00 93 ca 01 	sts	0x01CA, r16	; 0x8001ca <__flp>
    2112:	10 93 cb 01 	sts	0x01CB, r17	; 0x8001cb <__flp+0x1>
    2116:	22 c0       	rjmp	.+68     	; 0x215c <malloc+0x98>
    2118:	21 15       	cp	r18, r1
    211a:	31 05       	cpc	r19, r1
    211c:	19 f0       	breq	.+6      	; 0x2124 <malloc+0x60>
    211e:	42 17       	cp	r20, r18
    2120:	53 07       	cpc	r21, r19
    2122:	18 f4       	brcc	.+6      	; 0x212a <malloc+0x66>
    2124:	9a 01       	movw	r18, r20
    2126:	bd 01       	movw	r22, r26
    2128:	ef 01       	movw	r28, r30
    212a:	df 01       	movw	r26, r30
    212c:	f8 01       	movw	r30, r16
    212e:	db cf       	rjmp	.-74     	; 0x20e6 <malloc+0x22>
    2130:	21 15       	cp	r18, r1
    2132:	31 05       	cpc	r19, r1
    2134:	f9 f0       	breq	.+62     	; 0x2174 <malloc+0xb0>
    2136:	28 1b       	sub	r18, r24
    2138:	39 0b       	sbc	r19, r25
    213a:	24 30       	cpi	r18, 0x04	; 4
    213c:	31 05       	cpc	r19, r1
    213e:	80 f4       	brcc	.+32     	; 0x2160 <malloc+0x9c>
    2140:	8a 81       	ldd	r24, Y+2	; 0x02
    2142:	9b 81       	ldd	r25, Y+3	; 0x03
    2144:	61 15       	cp	r22, r1
    2146:	71 05       	cpc	r23, r1
    2148:	21 f0       	breq	.+8      	; 0x2152 <malloc+0x8e>
    214a:	fb 01       	movw	r30, r22
    214c:	93 83       	std	Z+3, r25	; 0x03
    214e:	82 83       	std	Z+2, r24	; 0x02
    2150:	04 c0       	rjmp	.+8      	; 0x215a <malloc+0x96>
    2152:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__flp+0x1>
    2156:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__flp>
    215a:	fe 01       	movw	r30, r28
    215c:	32 96       	adiw	r30, 0x02	; 2
    215e:	44 c0       	rjmp	.+136    	; 0x21e8 <malloc+0x124>
    2160:	fe 01       	movw	r30, r28
    2162:	e2 0f       	add	r30, r18
    2164:	f3 1f       	adc	r31, r19
    2166:	81 93       	st	Z+, r24
    2168:	91 93       	st	Z+, r25
    216a:	22 50       	subi	r18, 0x02	; 2
    216c:	31 09       	sbc	r19, r1
    216e:	39 83       	std	Y+1, r19	; 0x01
    2170:	28 83       	st	Y, r18
    2172:	3a c0       	rjmp	.+116    	; 0x21e8 <malloc+0x124>
    2174:	20 91 c8 01 	lds	r18, 0x01C8	; 0x8001c8 <__brkval>
    2178:	30 91 c9 01 	lds	r19, 0x01C9	; 0x8001c9 <__brkval+0x1>
    217c:	23 2b       	or	r18, r19
    217e:	41 f4       	brne	.+16     	; 0x2190 <malloc+0xcc>
    2180:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    2184:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    2188:	30 93 c9 01 	sts	0x01C9, r19	; 0x8001c9 <__brkval+0x1>
    218c:	20 93 c8 01 	sts	0x01C8, r18	; 0x8001c8 <__brkval>
    2190:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    2194:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    2198:	21 15       	cp	r18, r1
    219a:	31 05       	cpc	r19, r1
    219c:	41 f4       	brne	.+16     	; 0x21ae <malloc+0xea>
    219e:	2d b7       	in	r18, 0x3d	; 61
    21a0:	3e b7       	in	r19, 0x3e	; 62
    21a2:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    21a6:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    21aa:	24 1b       	sub	r18, r20
    21ac:	35 0b       	sbc	r19, r21
    21ae:	e0 91 c8 01 	lds	r30, 0x01C8	; 0x8001c8 <__brkval>
    21b2:	f0 91 c9 01 	lds	r31, 0x01C9	; 0x8001c9 <__brkval+0x1>
    21b6:	e2 17       	cp	r30, r18
    21b8:	f3 07       	cpc	r31, r19
    21ba:	a0 f4       	brcc	.+40     	; 0x21e4 <malloc+0x120>
    21bc:	2e 1b       	sub	r18, r30
    21be:	3f 0b       	sbc	r19, r31
    21c0:	28 17       	cp	r18, r24
    21c2:	39 07       	cpc	r19, r25
    21c4:	78 f0       	brcs	.+30     	; 0x21e4 <malloc+0x120>
    21c6:	ac 01       	movw	r20, r24
    21c8:	4e 5f       	subi	r20, 0xFE	; 254
    21ca:	5f 4f       	sbci	r21, 0xFF	; 255
    21cc:	24 17       	cp	r18, r20
    21ce:	35 07       	cpc	r19, r21
    21d0:	48 f0       	brcs	.+18     	; 0x21e4 <malloc+0x120>
    21d2:	4e 0f       	add	r20, r30
    21d4:	5f 1f       	adc	r21, r31
    21d6:	50 93 c9 01 	sts	0x01C9, r21	; 0x8001c9 <__brkval+0x1>
    21da:	40 93 c8 01 	sts	0x01C8, r20	; 0x8001c8 <__brkval>
    21de:	81 93       	st	Z+, r24
    21e0:	91 93       	st	Z+, r25
    21e2:	02 c0       	rjmp	.+4      	; 0x21e8 <malloc+0x124>
    21e4:	e0 e0       	ldi	r30, 0x00	; 0
    21e6:	f0 e0       	ldi	r31, 0x00	; 0
    21e8:	cf 01       	movw	r24, r30
    21ea:	df 91       	pop	r29
    21ec:	cf 91       	pop	r28
    21ee:	1f 91       	pop	r17
    21f0:	0f 91       	pop	r16
    21f2:	08 95       	ret

000021f4 <free>:
    21f4:	cf 93       	push	r28
    21f6:	df 93       	push	r29
    21f8:	00 97       	sbiw	r24, 0x00	; 0
    21fa:	09 f4       	brne	.+2      	; 0x21fe <free+0xa>
    21fc:	81 c0       	rjmp	.+258    	; 0x2300 <free+0x10c>
    21fe:	fc 01       	movw	r30, r24
    2200:	32 97       	sbiw	r30, 0x02	; 2
    2202:	13 82       	std	Z+3, r1	; 0x03
    2204:	12 82       	std	Z+2, r1	; 0x02
    2206:	a0 91 ca 01 	lds	r26, 0x01CA	; 0x8001ca <__flp>
    220a:	b0 91 cb 01 	lds	r27, 0x01CB	; 0x8001cb <__flp+0x1>
    220e:	10 97       	sbiw	r26, 0x00	; 0
    2210:	81 f4       	brne	.+32     	; 0x2232 <free+0x3e>
    2212:	20 81       	ld	r18, Z
    2214:	31 81       	ldd	r19, Z+1	; 0x01
    2216:	82 0f       	add	r24, r18
    2218:	93 1f       	adc	r25, r19
    221a:	20 91 c8 01 	lds	r18, 0x01C8	; 0x8001c8 <__brkval>
    221e:	30 91 c9 01 	lds	r19, 0x01C9	; 0x8001c9 <__brkval+0x1>
    2222:	28 17       	cp	r18, r24
    2224:	39 07       	cpc	r19, r25
    2226:	51 f5       	brne	.+84     	; 0x227c <free+0x88>
    2228:	f0 93 c9 01 	sts	0x01C9, r31	; 0x8001c9 <__brkval+0x1>
    222c:	e0 93 c8 01 	sts	0x01C8, r30	; 0x8001c8 <__brkval>
    2230:	67 c0       	rjmp	.+206    	; 0x2300 <free+0x10c>
    2232:	ed 01       	movw	r28, r26
    2234:	20 e0       	ldi	r18, 0x00	; 0
    2236:	30 e0       	ldi	r19, 0x00	; 0
    2238:	ce 17       	cp	r28, r30
    223a:	df 07       	cpc	r29, r31
    223c:	40 f4       	brcc	.+16     	; 0x224e <free+0x5a>
    223e:	4a 81       	ldd	r20, Y+2	; 0x02
    2240:	5b 81       	ldd	r21, Y+3	; 0x03
    2242:	9e 01       	movw	r18, r28
    2244:	41 15       	cp	r20, r1
    2246:	51 05       	cpc	r21, r1
    2248:	f1 f0       	breq	.+60     	; 0x2286 <free+0x92>
    224a:	ea 01       	movw	r28, r20
    224c:	f5 cf       	rjmp	.-22     	; 0x2238 <free+0x44>
    224e:	d3 83       	std	Z+3, r29	; 0x03
    2250:	c2 83       	std	Z+2, r28	; 0x02
    2252:	40 81       	ld	r20, Z
    2254:	51 81       	ldd	r21, Z+1	; 0x01
    2256:	84 0f       	add	r24, r20
    2258:	95 1f       	adc	r25, r21
    225a:	c8 17       	cp	r28, r24
    225c:	d9 07       	cpc	r29, r25
    225e:	59 f4       	brne	.+22     	; 0x2276 <free+0x82>
    2260:	88 81       	ld	r24, Y
    2262:	99 81       	ldd	r25, Y+1	; 0x01
    2264:	84 0f       	add	r24, r20
    2266:	95 1f       	adc	r25, r21
    2268:	02 96       	adiw	r24, 0x02	; 2
    226a:	91 83       	std	Z+1, r25	; 0x01
    226c:	80 83       	st	Z, r24
    226e:	8a 81       	ldd	r24, Y+2	; 0x02
    2270:	9b 81       	ldd	r25, Y+3	; 0x03
    2272:	93 83       	std	Z+3, r25	; 0x03
    2274:	82 83       	std	Z+2, r24	; 0x02
    2276:	21 15       	cp	r18, r1
    2278:	31 05       	cpc	r19, r1
    227a:	29 f4       	brne	.+10     	; 0x2286 <free+0x92>
    227c:	f0 93 cb 01 	sts	0x01CB, r31	; 0x8001cb <__flp+0x1>
    2280:	e0 93 ca 01 	sts	0x01CA, r30	; 0x8001ca <__flp>
    2284:	3d c0       	rjmp	.+122    	; 0x2300 <free+0x10c>
    2286:	e9 01       	movw	r28, r18
    2288:	fb 83       	std	Y+3, r31	; 0x03
    228a:	ea 83       	std	Y+2, r30	; 0x02
    228c:	49 91       	ld	r20, Y+
    228e:	59 91       	ld	r21, Y+
    2290:	c4 0f       	add	r28, r20
    2292:	d5 1f       	adc	r29, r21
    2294:	ec 17       	cp	r30, r28
    2296:	fd 07       	cpc	r31, r29
    2298:	61 f4       	brne	.+24     	; 0x22b2 <free+0xbe>
    229a:	80 81       	ld	r24, Z
    229c:	91 81       	ldd	r25, Z+1	; 0x01
    229e:	84 0f       	add	r24, r20
    22a0:	95 1f       	adc	r25, r21
    22a2:	02 96       	adiw	r24, 0x02	; 2
    22a4:	e9 01       	movw	r28, r18
    22a6:	99 83       	std	Y+1, r25	; 0x01
    22a8:	88 83       	st	Y, r24
    22aa:	82 81       	ldd	r24, Z+2	; 0x02
    22ac:	93 81       	ldd	r25, Z+3	; 0x03
    22ae:	9b 83       	std	Y+3, r25	; 0x03
    22b0:	8a 83       	std	Y+2, r24	; 0x02
    22b2:	e0 e0       	ldi	r30, 0x00	; 0
    22b4:	f0 e0       	ldi	r31, 0x00	; 0
    22b6:	12 96       	adiw	r26, 0x02	; 2
    22b8:	8d 91       	ld	r24, X+
    22ba:	9c 91       	ld	r25, X
    22bc:	13 97       	sbiw	r26, 0x03	; 3
    22be:	00 97       	sbiw	r24, 0x00	; 0
    22c0:	19 f0       	breq	.+6      	; 0x22c8 <free+0xd4>
    22c2:	fd 01       	movw	r30, r26
    22c4:	dc 01       	movw	r26, r24
    22c6:	f7 cf       	rjmp	.-18     	; 0x22b6 <free+0xc2>
    22c8:	8d 91       	ld	r24, X+
    22ca:	9c 91       	ld	r25, X
    22cc:	11 97       	sbiw	r26, 0x01	; 1
    22ce:	9d 01       	movw	r18, r26
    22d0:	2e 5f       	subi	r18, 0xFE	; 254
    22d2:	3f 4f       	sbci	r19, 0xFF	; 255
    22d4:	82 0f       	add	r24, r18
    22d6:	93 1f       	adc	r25, r19
    22d8:	20 91 c8 01 	lds	r18, 0x01C8	; 0x8001c8 <__brkval>
    22dc:	30 91 c9 01 	lds	r19, 0x01C9	; 0x8001c9 <__brkval+0x1>
    22e0:	28 17       	cp	r18, r24
    22e2:	39 07       	cpc	r19, r25
    22e4:	69 f4       	brne	.+26     	; 0x2300 <free+0x10c>
    22e6:	30 97       	sbiw	r30, 0x00	; 0
    22e8:	29 f4       	brne	.+10     	; 0x22f4 <free+0x100>
    22ea:	10 92 cb 01 	sts	0x01CB, r1	; 0x8001cb <__flp+0x1>
    22ee:	10 92 ca 01 	sts	0x01CA, r1	; 0x8001ca <__flp>
    22f2:	02 c0       	rjmp	.+4      	; 0x22f8 <free+0x104>
    22f4:	13 82       	std	Z+3, r1	; 0x03
    22f6:	12 82       	std	Z+2, r1	; 0x02
    22f8:	b0 93 c9 01 	sts	0x01C9, r27	; 0x8001c9 <__brkval+0x1>
    22fc:	a0 93 c8 01 	sts	0x01C8, r26	; 0x8001c8 <__brkval>
    2300:	df 91       	pop	r29
    2302:	cf 91       	pop	r28
    2304:	08 95       	ret

00002306 <__strlen_P>:
    2306:	fc 01       	movw	r30, r24
    2308:	05 90       	lpm	r0, Z+
    230a:	00 20       	and	r0, r0
    230c:	e9 f7       	brne	.-6      	; 0x2308 <__strlen_P+0x2>
    230e:	80 95       	com	r24
    2310:	90 95       	com	r25
    2312:	8e 0f       	add	r24, r30
    2314:	9f 1f       	adc	r25, r31
    2316:	08 95       	ret

00002318 <memcpy>:
    2318:	fb 01       	movw	r30, r22
    231a:	dc 01       	movw	r26, r24
    231c:	02 c0       	rjmp	.+4      	; 0x2322 <memcpy+0xa>
    231e:	01 90       	ld	r0, Z+
    2320:	0d 92       	st	X+, r0
    2322:	41 50       	subi	r20, 0x01	; 1
    2324:	50 40       	sbci	r21, 0x00	; 0
    2326:	d8 f7       	brcc	.-10     	; 0x231e <memcpy+0x6>
    2328:	08 95       	ret

0000232a <memset>:
    232a:	dc 01       	movw	r26, r24
    232c:	01 c0       	rjmp	.+2      	; 0x2330 <memset+0x6>
    232e:	6d 93       	st	X+, r22
    2330:	41 50       	subi	r20, 0x01	; 1
    2332:	50 40       	sbci	r21, 0x00	; 0
    2334:	e0 f7       	brcc	.-8      	; 0x232e <memset+0x4>
    2336:	08 95       	ret

00002338 <vsnprintf_P>:
    2338:	ae e0       	ldi	r26, 0x0E	; 14
    233a:	b0 e0       	ldi	r27, 0x00	; 0
    233c:	e2 ea       	ldi	r30, 0xA2	; 162
    233e:	f1 e1       	ldi	r31, 0x11	; 17
    2340:	0c 94 67 14 	jmp	0x28ce	; 0x28ce <__prologue_saves__+0x1c>
    2344:	8c 01       	movw	r16, r24
    2346:	fa 01       	movw	r30, r20
    2348:	8e e0       	ldi	r24, 0x0E	; 14
    234a:	8c 83       	std	Y+4, r24	; 0x04
    234c:	1a 83       	std	Y+2, r17	; 0x02
    234e:	09 83       	std	Y+1, r16	; 0x01
    2350:	77 ff       	sbrs	r23, 7
    2352:	02 c0       	rjmp	.+4      	; 0x2358 <vsnprintf_P+0x20>
    2354:	60 e0       	ldi	r22, 0x00	; 0
    2356:	70 e8       	ldi	r23, 0x80	; 128
    2358:	cb 01       	movw	r24, r22
    235a:	01 97       	sbiw	r24, 0x01	; 1
    235c:	9e 83       	std	Y+6, r25	; 0x06
    235e:	8d 83       	std	Y+5, r24	; 0x05
    2360:	a9 01       	movw	r20, r18
    2362:	bf 01       	movw	r22, r30
    2364:	ce 01       	movw	r24, r28
    2366:	01 96       	adiw	r24, 0x01	; 1
    2368:	0e 94 c8 11 	call	0x2390	; 0x2390 <vfprintf>
    236c:	4d 81       	ldd	r20, Y+5	; 0x05
    236e:	5e 81       	ldd	r21, Y+6	; 0x06
    2370:	57 fd       	sbrc	r21, 7
    2372:	0a c0       	rjmp	.+20     	; 0x2388 <vsnprintf_P+0x50>
    2374:	2f 81       	ldd	r18, Y+7	; 0x07
    2376:	38 85       	ldd	r19, Y+8	; 0x08
    2378:	42 17       	cp	r20, r18
    237a:	53 07       	cpc	r21, r19
    237c:	0c f4       	brge	.+2      	; 0x2380 <vsnprintf_P+0x48>
    237e:	9a 01       	movw	r18, r20
    2380:	f8 01       	movw	r30, r16
    2382:	e2 0f       	add	r30, r18
    2384:	f3 1f       	adc	r31, r19
    2386:	10 82       	st	Z, r1
    2388:	2e 96       	adiw	r28, 0x0e	; 14
    238a:	e4 e0       	ldi	r30, 0x04	; 4
    238c:	0c 94 83 14 	jmp	0x2906	; 0x2906 <__epilogue_restores__+0x1c>

00002390 <vfprintf>:
    2390:	ab e0       	ldi	r26, 0x0B	; 11
    2392:	b0 e0       	ldi	r27, 0x00	; 0
    2394:	ee ec       	ldi	r30, 0xCE	; 206
    2396:	f1 e1       	ldi	r31, 0x11	; 17
    2398:	0c 94 59 14 	jmp	0x28b2	; 0x28b2 <__prologue_saves__>
    239c:	6c 01       	movw	r12, r24
    239e:	7b 01       	movw	r14, r22
    23a0:	8a 01       	movw	r16, r20
    23a2:	fc 01       	movw	r30, r24
    23a4:	17 82       	std	Z+7, r1	; 0x07
    23a6:	16 82       	std	Z+6, r1	; 0x06
    23a8:	83 81       	ldd	r24, Z+3	; 0x03
    23aa:	81 ff       	sbrs	r24, 1
    23ac:	cc c1       	rjmp	.+920    	; 0x2746 <vfprintf+0x3b6>
    23ae:	ce 01       	movw	r24, r28
    23b0:	01 96       	adiw	r24, 0x01	; 1
    23b2:	3c 01       	movw	r6, r24
    23b4:	f6 01       	movw	r30, r12
    23b6:	93 81       	ldd	r25, Z+3	; 0x03
    23b8:	f7 01       	movw	r30, r14
    23ba:	93 fd       	sbrc	r25, 3
    23bc:	85 91       	lpm	r24, Z+
    23be:	93 ff       	sbrs	r25, 3
    23c0:	81 91       	ld	r24, Z+
    23c2:	7f 01       	movw	r14, r30
    23c4:	88 23       	and	r24, r24
    23c6:	09 f4       	brne	.+2      	; 0x23ca <vfprintf+0x3a>
    23c8:	ba c1       	rjmp	.+884    	; 0x273e <vfprintf+0x3ae>
    23ca:	85 32       	cpi	r24, 0x25	; 37
    23cc:	39 f4       	brne	.+14     	; 0x23dc <vfprintf+0x4c>
    23ce:	93 fd       	sbrc	r25, 3
    23d0:	85 91       	lpm	r24, Z+
    23d2:	93 ff       	sbrs	r25, 3
    23d4:	81 91       	ld	r24, Z+
    23d6:	7f 01       	movw	r14, r30
    23d8:	85 32       	cpi	r24, 0x25	; 37
    23da:	29 f4       	brne	.+10     	; 0x23e6 <vfprintf+0x56>
    23dc:	b6 01       	movw	r22, r12
    23de:	90 e0       	ldi	r25, 0x00	; 0
    23e0:	0e 94 bf 13 	call	0x277e	; 0x277e <fputc>
    23e4:	e7 cf       	rjmp	.-50     	; 0x23b4 <vfprintf+0x24>
    23e6:	91 2c       	mov	r9, r1
    23e8:	21 2c       	mov	r2, r1
    23ea:	31 2c       	mov	r3, r1
    23ec:	ff e1       	ldi	r31, 0x1F	; 31
    23ee:	f3 15       	cp	r31, r3
    23f0:	d8 f0       	brcs	.+54     	; 0x2428 <vfprintf+0x98>
    23f2:	8b 32       	cpi	r24, 0x2B	; 43
    23f4:	79 f0       	breq	.+30     	; 0x2414 <vfprintf+0x84>
    23f6:	38 f4       	brcc	.+14     	; 0x2406 <vfprintf+0x76>
    23f8:	80 32       	cpi	r24, 0x20	; 32
    23fa:	79 f0       	breq	.+30     	; 0x241a <vfprintf+0x8a>
    23fc:	83 32       	cpi	r24, 0x23	; 35
    23fe:	a1 f4       	brne	.+40     	; 0x2428 <vfprintf+0x98>
    2400:	23 2d       	mov	r18, r3
    2402:	20 61       	ori	r18, 0x10	; 16
    2404:	1d c0       	rjmp	.+58     	; 0x2440 <vfprintf+0xb0>
    2406:	8d 32       	cpi	r24, 0x2D	; 45
    2408:	61 f0       	breq	.+24     	; 0x2422 <vfprintf+0x92>
    240a:	80 33       	cpi	r24, 0x30	; 48
    240c:	69 f4       	brne	.+26     	; 0x2428 <vfprintf+0x98>
    240e:	23 2d       	mov	r18, r3
    2410:	21 60       	ori	r18, 0x01	; 1
    2412:	16 c0       	rjmp	.+44     	; 0x2440 <vfprintf+0xb0>
    2414:	83 2d       	mov	r24, r3
    2416:	82 60       	ori	r24, 0x02	; 2
    2418:	38 2e       	mov	r3, r24
    241a:	e3 2d       	mov	r30, r3
    241c:	e4 60       	ori	r30, 0x04	; 4
    241e:	3e 2e       	mov	r3, r30
    2420:	2a c0       	rjmp	.+84     	; 0x2476 <vfprintf+0xe6>
    2422:	f3 2d       	mov	r31, r3
    2424:	f8 60       	ori	r31, 0x08	; 8
    2426:	1d c0       	rjmp	.+58     	; 0x2462 <vfprintf+0xd2>
    2428:	37 fc       	sbrc	r3, 7
    242a:	2d c0       	rjmp	.+90     	; 0x2486 <vfprintf+0xf6>
    242c:	20 ed       	ldi	r18, 0xD0	; 208
    242e:	28 0f       	add	r18, r24
    2430:	2a 30       	cpi	r18, 0x0A	; 10
    2432:	40 f0       	brcs	.+16     	; 0x2444 <vfprintf+0xb4>
    2434:	8e 32       	cpi	r24, 0x2E	; 46
    2436:	b9 f4       	brne	.+46     	; 0x2466 <vfprintf+0xd6>
    2438:	36 fc       	sbrc	r3, 6
    243a:	81 c1       	rjmp	.+770    	; 0x273e <vfprintf+0x3ae>
    243c:	23 2d       	mov	r18, r3
    243e:	20 64       	ori	r18, 0x40	; 64
    2440:	32 2e       	mov	r3, r18
    2442:	19 c0       	rjmp	.+50     	; 0x2476 <vfprintf+0xe6>
    2444:	36 fe       	sbrs	r3, 6
    2446:	06 c0       	rjmp	.+12     	; 0x2454 <vfprintf+0xc4>
    2448:	8a e0       	ldi	r24, 0x0A	; 10
    244a:	98 9e       	mul	r9, r24
    244c:	20 0d       	add	r18, r0
    244e:	11 24       	eor	r1, r1
    2450:	92 2e       	mov	r9, r18
    2452:	11 c0       	rjmp	.+34     	; 0x2476 <vfprintf+0xe6>
    2454:	ea e0       	ldi	r30, 0x0A	; 10
    2456:	2e 9e       	mul	r2, r30
    2458:	20 0d       	add	r18, r0
    245a:	11 24       	eor	r1, r1
    245c:	22 2e       	mov	r2, r18
    245e:	f3 2d       	mov	r31, r3
    2460:	f0 62       	ori	r31, 0x20	; 32
    2462:	3f 2e       	mov	r3, r31
    2464:	08 c0       	rjmp	.+16     	; 0x2476 <vfprintf+0xe6>
    2466:	8c 36       	cpi	r24, 0x6C	; 108
    2468:	21 f4       	brne	.+8      	; 0x2472 <vfprintf+0xe2>
    246a:	83 2d       	mov	r24, r3
    246c:	80 68       	ori	r24, 0x80	; 128
    246e:	38 2e       	mov	r3, r24
    2470:	02 c0       	rjmp	.+4      	; 0x2476 <vfprintf+0xe6>
    2472:	88 36       	cpi	r24, 0x68	; 104
    2474:	41 f4       	brne	.+16     	; 0x2486 <vfprintf+0xf6>
    2476:	f7 01       	movw	r30, r14
    2478:	93 fd       	sbrc	r25, 3
    247a:	85 91       	lpm	r24, Z+
    247c:	93 ff       	sbrs	r25, 3
    247e:	81 91       	ld	r24, Z+
    2480:	7f 01       	movw	r14, r30
    2482:	81 11       	cpse	r24, r1
    2484:	b3 cf       	rjmp	.-154    	; 0x23ec <vfprintf+0x5c>
    2486:	98 2f       	mov	r25, r24
    2488:	9f 7d       	andi	r25, 0xDF	; 223
    248a:	95 54       	subi	r25, 0x45	; 69
    248c:	93 30       	cpi	r25, 0x03	; 3
    248e:	28 f4       	brcc	.+10     	; 0x249a <vfprintf+0x10a>
    2490:	0c 5f       	subi	r16, 0xFC	; 252
    2492:	1f 4f       	sbci	r17, 0xFF	; 255
    2494:	9f e3       	ldi	r25, 0x3F	; 63
    2496:	99 83       	std	Y+1, r25	; 0x01
    2498:	0d c0       	rjmp	.+26     	; 0x24b4 <vfprintf+0x124>
    249a:	83 36       	cpi	r24, 0x63	; 99
    249c:	31 f0       	breq	.+12     	; 0x24aa <vfprintf+0x11a>
    249e:	83 37       	cpi	r24, 0x73	; 115
    24a0:	71 f0       	breq	.+28     	; 0x24be <vfprintf+0x12e>
    24a2:	83 35       	cpi	r24, 0x53	; 83
    24a4:	09 f0       	breq	.+2      	; 0x24a8 <vfprintf+0x118>
    24a6:	59 c0       	rjmp	.+178    	; 0x255a <vfprintf+0x1ca>
    24a8:	21 c0       	rjmp	.+66     	; 0x24ec <vfprintf+0x15c>
    24aa:	f8 01       	movw	r30, r16
    24ac:	80 81       	ld	r24, Z
    24ae:	89 83       	std	Y+1, r24	; 0x01
    24b0:	0e 5f       	subi	r16, 0xFE	; 254
    24b2:	1f 4f       	sbci	r17, 0xFF	; 255
    24b4:	88 24       	eor	r8, r8
    24b6:	83 94       	inc	r8
    24b8:	91 2c       	mov	r9, r1
    24ba:	53 01       	movw	r10, r6
    24bc:	13 c0       	rjmp	.+38     	; 0x24e4 <vfprintf+0x154>
    24be:	28 01       	movw	r4, r16
    24c0:	f2 e0       	ldi	r31, 0x02	; 2
    24c2:	4f 0e       	add	r4, r31
    24c4:	51 1c       	adc	r5, r1
    24c6:	f8 01       	movw	r30, r16
    24c8:	a0 80       	ld	r10, Z
    24ca:	b1 80       	ldd	r11, Z+1	; 0x01
    24cc:	36 fe       	sbrs	r3, 6
    24ce:	03 c0       	rjmp	.+6      	; 0x24d6 <vfprintf+0x146>
    24d0:	69 2d       	mov	r22, r9
    24d2:	70 e0       	ldi	r23, 0x00	; 0
    24d4:	02 c0       	rjmp	.+4      	; 0x24da <vfprintf+0x14a>
    24d6:	6f ef       	ldi	r22, 0xFF	; 255
    24d8:	7f ef       	ldi	r23, 0xFF	; 255
    24da:	c5 01       	movw	r24, r10
    24dc:	0e 94 b4 13 	call	0x2768	; 0x2768 <strnlen>
    24e0:	4c 01       	movw	r8, r24
    24e2:	82 01       	movw	r16, r4
    24e4:	f3 2d       	mov	r31, r3
    24e6:	ff 77       	andi	r31, 0x7F	; 127
    24e8:	3f 2e       	mov	r3, r31
    24ea:	16 c0       	rjmp	.+44     	; 0x2518 <vfprintf+0x188>
    24ec:	28 01       	movw	r4, r16
    24ee:	22 e0       	ldi	r18, 0x02	; 2
    24f0:	42 0e       	add	r4, r18
    24f2:	51 1c       	adc	r5, r1
    24f4:	f8 01       	movw	r30, r16
    24f6:	a0 80       	ld	r10, Z
    24f8:	b1 80       	ldd	r11, Z+1	; 0x01
    24fa:	36 fe       	sbrs	r3, 6
    24fc:	03 c0       	rjmp	.+6      	; 0x2504 <vfprintf+0x174>
    24fe:	69 2d       	mov	r22, r9
    2500:	70 e0       	ldi	r23, 0x00	; 0
    2502:	02 c0       	rjmp	.+4      	; 0x2508 <vfprintf+0x178>
    2504:	6f ef       	ldi	r22, 0xFF	; 255
    2506:	7f ef       	ldi	r23, 0xFF	; 255
    2508:	c5 01       	movw	r24, r10
    250a:	0e 94 a9 13 	call	0x2752	; 0x2752 <strnlen_P>
    250e:	4c 01       	movw	r8, r24
    2510:	f3 2d       	mov	r31, r3
    2512:	f0 68       	ori	r31, 0x80	; 128
    2514:	3f 2e       	mov	r3, r31
    2516:	82 01       	movw	r16, r4
    2518:	33 fc       	sbrc	r3, 3
    251a:	1b c0       	rjmp	.+54     	; 0x2552 <vfprintf+0x1c2>
    251c:	82 2d       	mov	r24, r2
    251e:	90 e0       	ldi	r25, 0x00	; 0
    2520:	88 16       	cp	r8, r24
    2522:	99 06       	cpc	r9, r25
    2524:	b0 f4       	brcc	.+44     	; 0x2552 <vfprintf+0x1c2>
    2526:	b6 01       	movw	r22, r12
    2528:	80 e2       	ldi	r24, 0x20	; 32
    252a:	90 e0       	ldi	r25, 0x00	; 0
    252c:	0e 94 bf 13 	call	0x277e	; 0x277e <fputc>
    2530:	2a 94       	dec	r2
    2532:	f4 cf       	rjmp	.-24     	; 0x251c <vfprintf+0x18c>
    2534:	f5 01       	movw	r30, r10
    2536:	37 fc       	sbrc	r3, 7
    2538:	85 91       	lpm	r24, Z+
    253a:	37 fe       	sbrs	r3, 7
    253c:	81 91       	ld	r24, Z+
    253e:	5f 01       	movw	r10, r30
    2540:	b6 01       	movw	r22, r12
    2542:	90 e0       	ldi	r25, 0x00	; 0
    2544:	0e 94 bf 13 	call	0x277e	; 0x277e <fputc>
    2548:	21 10       	cpse	r2, r1
    254a:	2a 94       	dec	r2
    254c:	21 e0       	ldi	r18, 0x01	; 1
    254e:	82 1a       	sub	r8, r18
    2550:	91 08       	sbc	r9, r1
    2552:	81 14       	cp	r8, r1
    2554:	91 04       	cpc	r9, r1
    2556:	71 f7       	brne	.-36     	; 0x2534 <vfprintf+0x1a4>
    2558:	e8 c0       	rjmp	.+464    	; 0x272a <vfprintf+0x39a>
    255a:	84 36       	cpi	r24, 0x64	; 100
    255c:	11 f0       	breq	.+4      	; 0x2562 <vfprintf+0x1d2>
    255e:	89 36       	cpi	r24, 0x69	; 105
    2560:	41 f5       	brne	.+80     	; 0x25b2 <vfprintf+0x222>
    2562:	f8 01       	movw	r30, r16
    2564:	37 fe       	sbrs	r3, 7
    2566:	07 c0       	rjmp	.+14     	; 0x2576 <vfprintf+0x1e6>
    2568:	60 81       	ld	r22, Z
    256a:	71 81       	ldd	r23, Z+1	; 0x01
    256c:	82 81       	ldd	r24, Z+2	; 0x02
    256e:	93 81       	ldd	r25, Z+3	; 0x03
    2570:	0c 5f       	subi	r16, 0xFC	; 252
    2572:	1f 4f       	sbci	r17, 0xFF	; 255
    2574:	08 c0       	rjmp	.+16     	; 0x2586 <vfprintf+0x1f6>
    2576:	60 81       	ld	r22, Z
    2578:	71 81       	ldd	r23, Z+1	; 0x01
    257a:	07 2e       	mov	r0, r23
    257c:	00 0c       	add	r0, r0
    257e:	88 0b       	sbc	r24, r24
    2580:	99 0b       	sbc	r25, r25
    2582:	0e 5f       	subi	r16, 0xFE	; 254
    2584:	1f 4f       	sbci	r17, 0xFF	; 255
    2586:	f3 2d       	mov	r31, r3
    2588:	ff 76       	andi	r31, 0x6F	; 111
    258a:	3f 2e       	mov	r3, r31
    258c:	97 ff       	sbrs	r25, 7
    258e:	09 c0       	rjmp	.+18     	; 0x25a2 <vfprintf+0x212>
    2590:	90 95       	com	r25
    2592:	80 95       	com	r24
    2594:	70 95       	com	r23
    2596:	61 95       	neg	r22
    2598:	7f 4f       	sbci	r23, 0xFF	; 255
    259a:	8f 4f       	sbci	r24, 0xFF	; 255
    259c:	9f 4f       	sbci	r25, 0xFF	; 255
    259e:	f0 68       	ori	r31, 0x80	; 128
    25a0:	3f 2e       	mov	r3, r31
    25a2:	2a e0       	ldi	r18, 0x0A	; 10
    25a4:	30 e0       	ldi	r19, 0x00	; 0
    25a6:	a3 01       	movw	r20, r6
    25a8:	0e 94 fb 13 	call	0x27f6	; 0x27f6 <__ultoa_invert>
    25ac:	88 2e       	mov	r8, r24
    25ae:	86 18       	sub	r8, r6
    25b0:	45 c0       	rjmp	.+138    	; 0x263c <vfprintf+0x2ac>
    25b2:	85 37       	cpi	r24, 0x75	; 117
    25b4:	31 f4       	brne	.+12     	; 0x25c2 <vfprintf+0x232>
    25b6:	23 2d       	mov	r18, r3
    25b8:	2f 7e       	andi	r18, 0xEF	; 239
    25ba:	b2 2e       	mov	r11, r18
    25bc:	2a e0       	ldi	r18, 0x0A	; 10
    25be:	30 e0       	ldi	r19, 0x00	; 0
    25c0:	25 c0       	rjmp	.+74     	; 0x260c <vfprintf+0x27c>
    25c2:	93 2d       	mov	r25, r3
    25c4:	99 7f       	andi	r25, 0xF9	; 249
    25c6:	b9 2e       	mov	r11, r25
    25c8:	8f 36       	cpi	r24, 0x6F	; 111
    25ca:	c1 f0       	breq	.+48     	; 0x25fc <vfprintf+0x26c>
    25cc:	18 f4       	brcc	.+6      	; 0x25d4 <vfprintf+0x244>
    25ce:	88 35       	cpi	r24, 0x58	; 88
    25d0:	79 f0       	breq	.+30     	; 0x25f0 <vfprintf+0x260>
    25d2:	b5 c0       	rjmp	.+362    	; 0x273e <vfprintf+0x3ae>
    25d4:	80 37       	cpi	r24, 0x70	; 112
    25d6:	19 f0       	breq	.+6      	; 0x25de <vfprintf+0x24e>
    25d8:	88 37       	cpi	r24, 0x78	; 120
    25da:	21 f0       	breq	.+8      	; 0x25e4 <vfprintf+0x254>
    25dc:	b0 c0       	rjmp	.+352    	; 0x273e <vfprintf+0x3ae>
    25de:	e9 2f       	mov	r30, r25
    25e0:	e0 61       	ori	r30, 0x10	; 16
    25e2:	be 2e       	mov	r11, r30
    25e4:	b4 fe       	sbrs	r11, 4
    25e6:	0d c0       	rjmp	.+26     	; 0x2602 <vfprintf+0x272>
    25e8:	fb 2d       	mov	r31, r11
    25ea:	f4 60       	ori	r31, 0x04	; 4
    25ec:	bf 2e       	mov	r11, r31
    25ee:	09 c0       	rjmp	.+18     	; 0x2602 <vfprintf+0x272>
    25f0:	34 fe       	sbrs	r3, 4
    25f2:	0a c0       	rjmp	.+20     	; 0x2608 <vfprintf+0x278>
    25f4:	29 2f       	mov	r18, r25
    25f6:	26 60       	ori	r18, 0x06	; 6
    25f8:	b2 2e       	mov	r11, r18
    25fa:	06 c0       	rjmp	.+12     	; 0x2608 <vfprintf+0x278>
    25fc:	28 e0       	ldi	r18, 0x08	; 8
    25fe:	30 e0       	ldi	r19, 0x00	; 0
    2600:	05 c0       	rjmp	.+10     	; 0x260c <vfprintf+0x27c>
    2602:	20 e1       	ldi	r18, 0x10	; 16
    2604:	30 e0       	ldi	r19, 0x00	; 0
    2606:	02 c0       	rjmp	.+4      	; 0x260c <vfprintf+0x27c>
    2608:	20 e1       	ldi	r18, 0x10	; 16
    260a:	32 e0       	ldi	r19, 0x02	; 2
    260c:	f8 01       	movw	r30, r16
    260e:	b7 fe       	sbrs	r11, 7
    2610:	07 c0       	rjmp	.+14     	; 0x2620 <vfprintf+0x290>
    2612:	60 81       	ld	r22, Z
    2614:	71 81       	ldd	r23, Z+1	; 0x01
    2616:	82 81       	ldd	r24, Z+2	; 0x02
    2618:	93 81       	ldd	r25, Z+3	; 0x03
    261a:	0c 5f       	subi	r16, 0xFC	; 252
    261c:	1f 4f       	sbci	r17, 0xFF	; 255
    261e:	06 c0       	rjmp	.+12     	; 0x262c <vfprintf+0x29c>
    2620:	60 81       	ld	r22, Z
    2622:	71 81       	ldd	r23, Z+1	; 0x01
    2624:	80 e0       	ldi	r24, 0x00	; 0
    2626:	90 e0       	ldi	r25, 0x00	; 0
    2628:	0e 5f       	subi	r16, 0xFE	; 254
    262a:	1f 4f       	sbci	r17, 0xFF	; 255
    262c:	a3 01       	movw	r20, r6
    262e:	0e 94 fb 13 	call	0x27f6	; 0x27f6 <__ultoa_invert>
    2632:	88 2e       	mov	r8, r24
    2634:	86 18       	sub	r8, r6
    2636:	fb 2d       	mov	r31, r11
    2638:	ff 77       	andi	r31, 0x7F	; 127
    263a:	3f 2e       	mov	r3, r31
    263c:	36 fe       	sbrs	r3, 6
    263e:	0d c0       	rjmp	.+26     	; 0x265a <vfprintf+0x2ca>
    2640:	23 2d       	mov	r18, r3
    2642:	2e 7f       	andi	r18, 0xFE	; 254
    2644:	a2 2e       	mov	r10, r18
    2646:	89 14       	cp	r8, r9
    2648:	58 f4       	brcc	.+22     	; 0x2660 <vfprintf+0x2d0>
    264a:	34 fe       	sbrs	r3, 4
    264c:	0b c0       	rjmp	.+22     	; 0x2664 <vfprintf+0x2d4>
    264e:	32 fc       	sbrc	r3, 2
    2650:	09 c0       	rjmp	.+18     	; 0x2664 <vfprintf+0x2d4>
    2652:	83 2d       	mov	r24, r3
    2654:	8e 7e       	andi	r24, 0xEE	; 238
    2656:	a8 2e       	mov	r10, r24
    2658:	05 c0       	rjmp	.+10     	; 0x2664 <vfprintf+0x2d4>
    265a:	b8 2c       	mov	r11, r8
    265c:	a3 2c       	mov	r10, r3
    265e:	03 c0       	rjmp	.+6      	; 0x2666 <vfprintf+0x2d6>
    2660:	b8 2c       	mov	r11, r8
    2662:	01 c0       	rjmp	.+2      	; 0x2666 <vfprintf+0x2d6>
    2664:	b9 2c       	mov	r11, r9
    2666:	a4 fe       	sbrs	r10, 4
    2668:	0f c0       	rjmp	.+30     	; 0x2688 <vfprintf+0x2f8>
    266a:	fe 01       	movw	r30, r28
    266c:	e8 0d       	add	r30, r8
    266e:	f1 1d       	adc	r31, r1
    2670:	80 81       	ld	r24, Z
    2672:	80 33       	cpi	r24, 0x30	; 48
    2674:	21 f4       	brne	.+8      	; 0x267e <vfprintf+0x2ee>
    2676:	9a 2d       	mov	r25, r10
    2678:	99 7e       	andi	r25, 0xE9	; 233
    267a:	a9 2e       	mov	r10, r25
    267c:	09 c0       	rjmp	.+18     	; 0x2690 <vfprintf+0x300>
    267e:	a2 fe       	sbrs	r10, 2
    2680:	06 c0       	rjmp	.+12     	; 0x268e <vfprintf+0x2fe>
    2682:	b3 94       	inc	r11
    2684:	b3 94       	inc	r11
    2686:	04 c0       	rjmp	.+8      	; 0x2690 <vfprintf+0x300>
    2688:	8a 2d       	mov	r24, r10
    268a:	86 78       	andi	r24, 0x86	; 134
    268c:	09 f0       	breq	.+2      	; 0x2690 <vfprintf+0x300>
    268e:	b3 94       	inc	r11
    2690:	a3 fc       	sbrc	r10, 3
    2692:	11 c0       	rjmp	.+34     	; 0x26b6 <vfprintf+0x326>
    2694:	a0 fe       	sbrs	r10, 0
    2696:	06 c0       	rjmp	.+12     	; 0x26a4 <vfprintf+0x314>
    2698:	b2 14       	cp	r11, r2
    269a:	88 f4       	brcc	.+34     	; 0x26be <vfprintf+0x32e>
    269c:	28 0c       	add	r2, r8
    269e:	92 2c       	mov	r9, r2
    26a0:	9b 18       	sub	r9, r11
    26a2:	0e c0       	rjmp	.+28     	; 0x26c0 <vfprintf+0x330>
    26a4:	b2 14       	cp	r11, r2
    26a6:	60 f4       	brcc	.+24     	; 0x26c0 <vfprintf+0x330>
    26a8:	b6 01       	movw	r22, r12
    26aa:	80 e2       	ldi	r24, 0x20	; 32
    26ac:	90 e0       	ldi	r25, 0x00	; 0
    26ae:	0e 94 bf 13 	call	0x277e	; 0x277e <fputc>
    26b2:	b3 94       	inc	r11
    26b4:	f7 cf       	rjmp	.-18     	; 0x26a4 <vfprintf+0x314>
    26b6:	b2 14       	cp	r11, r2
    26b8:	18 f4       	brcc	.+6      	; 0x26c0 <vfprintf+0x330>
    26ba:	2b 18       	sub	r2, r11
    26bc:	02 c0       	rjmp	.+4      	; 0x26c2 <vfprintf+0x332>
    26be:	98 2c       	mov	r9, r8
    26c0:	21 2c       	mov	r2, r1
    26c2:	a4 fe       	sbrs	r10, 4
    26c4:	10 c0       	rjmp	.+32     	; 0x26e6 <vfprintf+0x356>
    26c6:	b6 01       	movw	r22, r12
    26c8:	80 e3       	ldi	r24, 0x30	; 48
    26ca:	90 e0       	ldi	r25, 0x00	; 0
    26cc:	0e 94 bf 13 	call	0x277e	; 0x277e <fputc>
    26d0:	a2 fe       	sbrs	r10, 2
    26d2:	17 c0       	rjmp	.+46     	; 0x2702 <vfprintf+0x372>
    26d4:	a1 fc       	sbrc	r10, 1
    26d6:	03 c0       	rjmp	.+6      	; 0x26de <vfprintf+0x34e>
    26d8:	88 e7       	ldi	r24, 0x78	; 120
    26da:	90 e0       	ldi	r25, 0x00	; 0
    26dc:	02 c0       	rjmp	.+4      	; 0x26e2 <vfprintf+0x352>
    26de:	88 e5       	ldi	r24, 0x58	; 88
    26e0:	90 e0       	ldi	r25, 0x00	; 0
    26e2:	b6 01       	movw	r22, r12
    26e4:	0c c0       	rjmp	.+24     	; 0x26fe <vfprintf+0x36e>
    26e6:	8a 2d       	mov	r24, r10
    26e8:	86 78       	andi	r24, 0x86	; 134
    26ea:	59 f0       	breq	.+22     	; 0x2702 <vfprintf+0x372>
    26ec:	a1 fe       	sbrs	r10, 1
    26ee:	02 c0       	rjmp	.+4      	; 0x26f4 <vfprintf+0x364>
    26f0:	8b e2       	ldi	r24, 0x2B	; 43
    26f2:	01 c0       	rjmp	.+2      	; 0x26f6 <vfprintf+0x366>
    26f4:	80 e2       	ldi	r24, 0x20	; 32
    26f6:	a7 fc       	sbrc	r10, 7
    26f8:	8d e2       	ldi	r24, 0x2D	; 45
    26fa:	b6 01       	movw	r22, r12
    26fc:	90 e0       	ldi	r25, 0x00	; 0
    26fe:	0e 94 bf 13 	call	0x277e	; 0x277e <fputc>
    2702:	89 14       	cp	r8, r9
    2704:	38 f4       	brcc	.+14     	; 0x2714 <vfprintf+0x384>
    2706:	b6 01       	movw	r22, r12
    2708:	80 e3       	ldi	r24, 0x30	; 48
    270a:	90 e0       	ldi	r25, 0x00	; 0
    270c:	0e 94 bf 13 	call	0x277e	; 0x277e <fputc>
    2710:	9a 94       	dec	r9
    2712:	f7 cf       	rjmp	.-18     	; 0x2702 <vfprintf+0x372>
    2714:	8a 94       	dec	r8
    2716:	f3 01       	movw	r30, r6
    2718:	e8 0d       	add	r30, r8
    271a:	f1 1d       	adc	r31, r1
    271c:	80 81       	ld	r24, Z
    271e:	b6 01       	movw	r22, r12
    2720:	90 e0       	ldi	r25, 0x00	; 0
    2722:	0e 94 bf 13 	call	0x277e	; 0x277e <fputc>
    2726:	81 10       	cpse	r8, r1
    2728:	f5 cf       	rjmp	.-22     	; 0x2714 <vfprintf+0x384>
    272a:	22 20       	and	r2, r2
    272c:	09 f4       	brne	.+2      	; 0x2730 <vfprintf+0x3a0>
    272e:	42 ce       	rjmp	.-892    	; 0x23b4 <vfprintf+0x24>
    2730:	b6 01       	movw	r22, r12
    2732:	80 e2       	ldi	r24, 0x20	; 32
    2734:	90 e0       	ldi	r25, 0x00	; 0
    2736:	0e 94 bf 13 	call	0x277e	; 0x277e <fputc>
    273a:	2a 94       	dec	r2
    273c:	f6 cf       	rjmp	.-20     	; 0x272a <vfprintf+0x39a>
    273e:	f6 01       	movw	r30, r12
    2740:	86 81       	ldd	r24, Z+6	; 0x06
    2742:	97 81       	ldd	r25, Z+7	; 0x07
    2744:	02 c0       	rjmp	.+4      	; 0x274a <vfprintf+0x3ba>
    2746:	8f ef       	ldi	r24, 0xFF	; 255
    2748:	9f ef       	ldi	r25, 0xFF	; 255
    274a:	2b 96       	adiw	r28, 0x0b	; 11
    274c:	e2 e1       	ldi	r30, 0x12	; 18
    274e:	0c 94 75 14 	jmp	0x28ea	; 0x28ea <__epilogue_restores__>

00002752 <strnlen_P>:
    2752:	fc 01       	movw	r30, r24
    2754:	05 90       	lpm	r0, Z+
    2756:	61 50       	subi	r22, 0x01	; 1
    2758:	70 40       	sbci	r23, 0x00	; 0
    275a:	01 10       	cpse	r0, r1
    275c:	d8 f7       	brcc	.-10     	; 0x2754 <strnlen_P+0x2>
    275e:	80 95       	com	r24
    2760:	90 95       	com	r25
    2762:	8e 0f       	add	r24, r30
    2764:	9f 1f       	adc	r25, r31
    2766:	08 95       	ret

00002768 <strnlen>:
    2768:	fc 01       	movw	r30, r24
    276a:	61 50       	subi	r22, 0x01	; 1
    276c:	70 40       	sbci	r23, 0x00	; 0
    276e:	01 90       	ld	r0, Z+
    2770:	01 10       	cpse	r0, r1
    2772:	d8 f7       	brcc	.-10     	; 0x276a <strnlen+0x2>
    2774:	80 95       	com	r24
    2776:	90 95       	com	r25
    2778:	8e 0f       	add	r24, r30
    277a:	9f 1f       	adc	r25, r31
    277c:	08 95       	ret

0000277e <fputc>:
    277e:	0f 93       	push	r16
    2780:	1f 93       	push	r17
    2782:	cf 93       	push	r28
    2784:	df 93       	push	r29
    2786:	fb 01       	movw	r30, r22
    2788:	23 81       	ldd	r18, Z+3	; 0x03
    278a:	21 fd       	sbrc	r18, 1
    278c:	03 c0       	rjmp	.+6      	; 0x2794 <fputc+0x16>
    278e:	8f ef       	ldi	r24, 0xFF	; 255
    2790:	9f ef       	ldi	r25, 0xFF	; 255
    2792:	2c c0       	rjmp	.+88     	; 0x27ec <fputc+0x6e>
    2794:	22 ff       	sbrs	r18, 2
    2796:	16 c0       	rjmp	.+44     	; 0x27c4 <fputc+0x46>
    2798:	46 81       	ldd	r20, Z+6	; 0x06
    279a:	57 81       	ldd	r21, Z+7	; 0x07
    279c:	24 81       	ldd	r18, Z+4	; 0x04
    279e:	35 81       	ldd	r19, Z+5	; 0x05
    27a0:	42 17       	cp	r20, r18
    27a2:	53 07       	cpc	r21, r19
    27a4:	44 f4       	brge	.+16     	; 0x27b6 <fputc+0x38>
    27a6:	a0 81       	ld	r26, Z
    27a8:	b1 81       	ldd	r27, Z+1	; 0x01
    27aa:	9d 01       	movw	r18, r26
    27ac:	2f 5f       	subi	r18, 0xFF	; 255
    27ae:	3f 4f       	sbci	r19, 0xFF	; 255
    27b0:	31 83       	std	Z+1, r19	; 0x01
    27b2:	20 83       	st	Z, r18
    27b4:	8c 93       	st	X, r24
    27b6:	26 81       	ldd	r18, Z+6	; 0x06
    27b8:	37 81       	ldd	r19, Z+7	; 0x07
    27ba:	2f 5f       	subi	r18, 0xFF	; 255
    27bc:	3f 4f       	sbci	r19, 0xFF	; 255
    27be:	37 83       	std	Z+7, r19	; 0x07
    27c0:	26 83       	std	Z+6, r18	; 0x06
    27c2:	14 c0       	rjmp	.+40     	; 0x27ec <fputc+0x6e>
    27c4:	8b 01       	movw	r16, r22
    27c6:	ec 01       	movw	r28, r24
    27c8:	fb 01       	movw	r30, r22
    27ca:	00 84       	ldd	r0, Z+8	; 0x08
    27cc:	f1 85       	ldd	r31, Z+9	; 0x09
    27ce:	e0 2d       	mov	r30, r0
    27d0:	09 95       	icall
    27d2:	89 2b       	or	r24, r25
    27d4:	e1 f6       	brne	.-72     	; 0x278e <fputc+0x10>
    27d6:	d8 01       	movw	r26, r16
    27d8:	16 96       	adiw	r26, 0x06	; 6
    27da:	8d 91       	ld	r24, X+
    27dc:	9c 91       	ld	r25, X
    27de:	17 97       	sbiw	r26, 0x07	; 7
    27e0:	01 96       	adiw	r24, 0x01	; 1
    27e2:	17 96       	adiw	r26, 0x07	; 7
    27e4:	9c 93       	st	X, r25
    27e6:	8e 93       	st	-X, r24
    27e8:	16 97       	sbiw	r26, 0x06	; 6
    27ea:	ce 01       	movw	r24, r28
    27ec:	df 91       	pop	r29
    27ee:	cf 91       	pop	r28
    27f0:	1f 91       	pop	r17
    27f2:	0f 91       	pop	r16
    27f4:	08 95       	ret

000027f6 <__ultoa_invert>:
    27f6:	fa 01       	movw	r30, r20
    27f8:	aa 27       	eor	r26, r26
    27fa:	28 30       	cpi	r18, 0x08	; 8
    27fc:	51 f1       	breq	.+84     	; 0x2852 <__ultoa_invert+0x5c>
    27fe:	20 31       	cpi	r18, 0x10	; 16
    2800:	81 f1       	breq	.+96     	; 0x2862 <__ultoa_invert+0x6c>
    2802:	e8 94       	clt
    2804:	6f 93       	push	r22
    2806:	6e 7f       	andi	r22, 0xFE	; 254
    2808:	6e 5f       	subi	r22, 0xFE	; 254
    280a:	7f 4f       	sbci	r23, 0xFF	; 255
    280c:	8f 4f       	sbci	r24, 0xFF	; 255
    280e:	9f 4f       	sbci	r25, 0xFF	; 255
    2810:	af 4f       	sbci	r26, 0xFF	; 255
    2812:	b1 e0       	ldi	r27, 0x01	; 1
    2814:	3e d0       	rcall	.+124    	; 0x2892 <__ultoa_invert+0x9c>
    2816:	b4 e0       	ldi	r27, 0x04	; 4
    2818:	3c d0       	rcall	.+120    	; 0x2892 <__ultoa_invert+0x9c>
    281a:	67 0f       	add	r22, r23
    281c:	78 1f       	adc	r23, r24
    281e:	89 1f       	adc	r24, r25
    2820:	9a 1f       	adc	r25, r26
    2822:	a1 1d       	adc	r26, r1
    2824:	68 0f       	add	r22, r24
    2826:	79 1f       	adc	r23, r25
    2828:	8a 1f       	adc	r24, r26
    282a:	91 1d       	adc	r25, r1
    282c:	a1 1d       	adc	r26, r1
    282e:	6a 0f       	add	r22, r26
    2830:	71 1d       	adc	r23, r1
    2832:	81 1d       	adc	r24, r1
    2834:	91 1d       	adc	r25, r1
    2836:	a1 1d       	adc	r26, r1
    2838:	20 d0       	rcall	.+64     	; 0x287a <__ultoa_invert+0x84>
    283a:	09 f4       	brne	.+2      	; 0x283e <__ultoa_invert+0x48>
    283c:	68 94       	set
    283e:	3f 91       	pop	r19
    2840:	2a e0       	ldi	r18, 0x0A	; 10
    2842:	26 9f       	mul	r18, r22
    2844:	11 24       	eor	r1, r1
    2846:	30 19       	sub	r19, r0
    2848:	30 5d       	subi	r19, 0xD0	; 208
    284a:	31 93       	st	Z+, r19
    284c:	de f6       	brtc	.-74     	; 0x2804 <__ultoa_invert+0xe>
    284e:	cf 01       	movw	r24, r30
    2850:	08 95       	ret
    2852:	46 2f       	mov	r20, r22
    2854:	47 70       	andi	r20, 0x07	; 7
    2856:	40 5d       	subi	r20, 0xD0	; 208
    2858:	41 93       	st	Z+, r20
    285a:	b3 e0       	ldi	r27, 0x03	; 3
    285c:	0f d0       	rcall	.+30     	; 0x287c <__ultoa_invert+0x86>
    285e:	c9 f7       	brne	.-14     	; 0x2852 <__ultoa_invert+0x5c>
    2860:	f6 cf       	rjmp	.-20     	; 0x284e <__ultoa_invert+0x58>
    2862:	46 2f       	mov	r20, r22
    2864:	4f 70       	andi	r20, 0x0F	; 15
    2866:	40 5d       	subi	r20, 0xD0	; 208
    2868:	4a 33       	cpi	r20, 0x3A	; 58
    286a:	18 f0       	brcs	.+6      	; 0x2872 <__ultoa_invert+0x7c>
    286c:	49 5d       	subi	r20, 0xD9	; 217
    286e:	31 fd       	sbrc	r19, 1
    2870:	40 52       	subi	r20, 0x20	; 32
    2872:	41 93       	st	Z+, r20
    2874:	02 d0       	rcall	.+4      	; 0x287a <__ultoa_invert+0x84>
    2876:	a9 f7       	brne	.-22     	; 0x2862 <__ultoa_invert+0x6c>
    2878:	ea cf       	rjmp	.-44     	; 0x284e <__ultoa_invert+0x58>
    287a:	b4 e0       	ldi	r27, 0x04	; 4
    287c:	a6 95       	lsr	r26
    287e:	97 95       	ror	r25
    2880:	87 95       	ror	r24
    2882:	77 95       	ror	r23
    2884:	67 95       	ror	r22
    2886:	ba 95       	dec	r27
    2888:	c9 f7       	brne	.-14     	; 0x287c <__ultoa_invert+0x86>
    288a:	00 97       	sbiw	r24, 0x00	; 0
    288c:	61 05       	cpc	r22, r1
    288e:	71 05       	cpc	r23, r1
    2890:	08 95       	ret
    2892:	9b 01       	movw	r18, r22
    2894:	ac 01       	movw	r20, r24
    2896:	0a 2e       	mov	r0, r26
    2898:	06 94       	lsr	r0
    289a:	57 95       	ror	r21
    289c:	47 95       	ror	r20
    289e:	37 95       	ror	r19
    28a0:	27 95       	ror	r18
    28a2:	ba 95       	dec	r27
    28a4:	c9 f7       	brne	.-14     	; 0x2898 <__ultoa_invert+0xa2>
    28a6:	62 0f       	add	r22, r18
    28a8:	73 1f       	adc	r23, r19
    28aa:	84 1f       	adc	r24, r20
    28ac:	95 1f       	adc	r25, r21
    28ae:	a0 1d       	adc	r26, r0
    28b0:	08 95       	ret

000028b2 <__prologue_saves__>:
    28b2:	2f 92       	push	r2
    28b4:	3f 92       	push	r3
    28b6:	4f 92       	push	r4
    28b8:	5f 92       	push	r5
    28ba:	6f 92       	push	r6
    28bc:	7f 92       	push	r7
    28be:	8f 92       	push	r8
    28c0:	9f 92       	push	r9
    28c2:	af 92       	push	r10
    28c4:	bf 92       	push	r11
    28c6:	cf 92       	push	r12
    28c8:	df 92       	push	r13
    28ca:	ef 92       	push	r14
    28cc:	ff 92       	push	r15
    28ce:	0f 93       	push	r16
    28d0:	1f 93       	push	r17
    28d2:	cf 93       	push	r28
    28d4:	df 93       	push	r29
    28d6:	cd b7       	in	r28, 0x3d	; 61
    28d8:	de b7       	in	r29, 0x3e	; 62
    28da:	ca 1b       	sub	r28, r26
    28dc:	db 0b       	sbc	r29, r27
    28de:	0f b6       	in	r0, 0x3f	; 63
    28e0:	f8 94       	cli
    28e2:	de bf       	out	0x3e, r29	; 62
    28e4:	0f be       	out	0x3f, r0	; 63
    28e6:	cd bf       	out	0x3d, r28	; 61
    28e8:	09 94       	ijmp

000028ea <__epilogue_restores__>:
    28ea:	2a 88       	ldd	r2, Y+18	; 0x12
    28ec:	39 88       	ldd	r3, Y+17	; 0x11
    28ee:	48 88       	ldd	r4, Y+16	; 0x10
    28f0:	5f 84       	ldd	r5, Y+15	; 0x0f
    28f2:	6e 84       	ldd	r6, Y+14	; 0x0e
    28f4:	7d 84       	ldd	r7, Y+13	; 0x0d
    28f6:	8c 84       	ldd	r8, Y+12	; 0x0c
    28f8:	9b 84       	ldd	r9, Y+11	; 0x0b
    28fa:	aa 84       	ldd	r10, Y+10	; 0x0a
    28fc:	b9 84       	ldd	r11, Y+9	; 0x09
    28fe:	c8 84       	ldd	r12, Y+8	; 0x08
    2900:	df 80       	ldd	r13, Y+7	; 0x07
    2902:	ee 80       	ldd	r14, Y+6	; 0x06
    2904:	fd 80       	ldd	r15, Y+5	; 0x05
    2906:	0c 81       	ldd	r16, Y+4	; 0x04
    2908:	1b 81       	ldd	r17, Y+3	; 0x03
    290a:	aa 81       	ldd	r26, Y+2	; 0x02
    290c:	b9 81       	ldd	r27, Y+1	; 0x01
    290e:	ce 0f       	add	r28, r30
    2910:	d1 1d       	adc	r29, r1
    2912:	0f b6       	in	r0, 0x3f	; 63
    2914:	f8 94       	cli
    2916:	de bf       	out	0x3e, r29	; 62
    2918:	0f be       	out	0x3f, r0	; 63
    291a:	cd bf       	out	0x3d, r28	; 61
    291c:	ed 01       	movw	r28, r26
    291e:	08 95       	ret

00002920 <_exit>:
    2920:	f8 94       	cli

00002922 <__stop_program>:
    2922:	ff cf       	rjmp	.-2      	; 0x2922 <__stop_program>
